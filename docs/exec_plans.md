# Execution Planning Template

Use this guide when a request spans hours or touches multiple systems (API, web, shared packages, or Rust services). Capture enough detail so reviewers can understand scope, risks, and how correctness will be proved before editing code or docs.

## Structure

1. **Objective** – One sentence on the outcome (e.g., “Add campaign landing route and hook it up to Prisma-based reservations”).
2. **Background** – Dependencies, related tickets, architecture notes, or previous work.
3. **Scope** – APIs, services, and directories that will be touched; call out what will stay untouched.
4. **Steps** – Ordered checklist (analysis → implementation → tests) with owners if the work will be split.
5. **Risks & Mitigations** – Identify unstable dependencies (Prisma migrations, shared SDK safety, Rust rebuild time) and how you will guard against regression.
6. **Verification** – List exact commands to run before claiming success (e.g., `pnpm --dir platform/apps/api test:smoke`, `pnpm --dir platform/apps/web test`, `pnpm lint:web`, `pnpm --dir platform/apps/web test:e2e`, `pnpm ci:sdk`). Cloud runs should repeat these commands in CI if possible.
7. **Documentation / Follow-up** – Note which docs to update (this folder, service runbooks, alerts) and whether new env vars, migrations, or release notes are required.

## Example

- Objective: “Expose reservation stats via API and show widget on marketing homepage.”
- Background: link to `docs/roadmap-public.md` and note Prisma schema used by `platform/apps/api/prisma/reservations`.
- Scope: update `platform/apps/api/src/reservations`, add new Next.js route under `platform/apps/web/app/reservations`, extend shared type in `platform/packages/shared`.
- Steps:
  1. Draft API contract and Prisma query.
  2. Implement resolver and add tests.
  3. Wire up web route/component and run Vitest/Playwright.
  4. Update docs and changelog.
- Risks: Prisma migration drift → run `pnpm --dir platform/apps/api prisma:migrate dev`.
- Verification: run the lint/test commands above plus `pnpm build` if the change touches shared packages; confirm `pnpm --dir platform/apps/web budgets`.

Keep this template near the top of any large task PR so reviewers immediately understand how the work was validated.

## Plan: Vercel Standards Foundation (Turbo + pnpm 9.15.9)

- Objective: Introduce Turbo build pipelines and upgrade pnpm tooling to align Keepr with Vercel monorepo standards.
- Background: Prior tooling used pnpm 7 with sequential build scripts; Vercel repos use pnpm 9/10 and Turbo caching.
- Scope: `package.json`, `pnpm-lock.yaml`, `turbo.json`, `platform/apps/api/package.json`, `platform/apps/web/package.json`, `Dockerfile.web`, `Dockerfile.api`, `.github/workflows/ci.yml`, `docs/repo_summary.md`, `docs/RAILWAY_TROUBLESHOOTING.md`, new `docs/vercel-standards-checklist.md`.
- Steps:
  1. Add `turbo.json` and wire root build scripts to use Turbo; align API/Web build scripts for dependency-based builds.
  2. Upgrade pnpm version in root config, CI, Dockerfiles, and docs.
  3. Regenerate `pnpm-lock.yaml` with pnpm 9.15.9.
  4. Publish a Vercel standards checklist doc and update repo summary.
- Risks & Mitigations: lockfile format upgrade (run `pnpm install` with new version); Prisma client generation now happens in API build (verify CI still generates client); web build may require env vars (use `SKIP_ENV_VALIDATION` if needed).
- Verification: `pnpm lint:web`, `pnpm build`, `pnpm typecheck`, `pnpm --dir platform/apps/api test:smoke`, `cargo test` (each `platform/services/*`).
- Status: Completed; local verification run, CI run pending for typecheck/Rust jobs.

## Plan: Vercel Deploy Alignment + Observability Conventions

- Objective: Align Vercel deployment config with the web app location, document Changesets usage, and establish observability/reliability conventions.
- Background: `vercel.json` is minimal and does not reflect the monorepo layout or current API routing strategy; observability expectations are spread across multiple docs.
- Scope: `vercel.json`, `docs/repo_summary.md`, `docs/changesets.md`, `docs/observability-conventions.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Update `vercel.json` to build the web app from the workspace and document the expected routing model.
  2. Add a Changesets usage guide for shared packages.
  3. Publish observability/reliability conventions and link them from repo summary.
- Risks & Mitigations: Vercel build path drift -> keep build/output paths tied to `@keepr/web` scripts; documentation drift -> link new docs from `docs/repo_summary.md` and update checklist.
- Verification: `pnpm lint`.
- Status: Completed; verification run.

## Plan: API Contract Types (SDK)

- Objective: Generate typed SDK shapes from the API OpenAPI spec to tighten web/API contract alignment.
- Background: `platform/apps/api/openapi.json` is generated by the NestJS Swagger config via `openapi:generate`.
- Scope: `platform/packages/sdk`, `platform/apps/api/openapi.json`, `docs/repo_summary.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add `openapi-typescript` and a script to emit `src/openapi-types.ts`.
  2. Export OpenAPI types from the SDK entrypoint.
  3. Update docs and changelog to reflect the new workflow.
- Risks & Mitigations: spec drift -> re-run `pnpm --dir platform/apps/api openapi:generate` before regenerating types; large diffs -> keep the file generated-only.
- Verification: `pnpm --dir platform/packages/sdk openapi:types`, `pnpm --dir platform/packages/sdk typecheck`.
- Status: Completed; local verification run.

## Plan: Feature Flag Evaluation Endpoints

- Objective: Provide authenticated flag evaluation endpoints for runtime gating without exposing admin CRUD.
- Background: Admin flag management lives under `/admin/flags`, but the app lacked a read-only evaluation API.
- Scope: `platform/apps/api/src/feature-flags`, `platform/apps/api/src/admin/feature-flag.service.ts`, `platform/apps/api/src/app.module.ts`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add `/flags` and `/flags/:key` endpoints with JWT + scope validation.
  2. Add an evaluated flag snapshot method in the feature flag service.
  3. Update docs and changelog for the new flag surface.
- Risks & Mitigations: flag leakage -> require auth and scope guard; campground mismatch -> rely on `x-campground-id` enforcement.
- Verification: `pnpm --dir platform/apps/api test:smoke`.
- Status: Completed; verification run.

## Plan: Rust Readiness Endpoints

- Objective: Align Rust services with API readiness checks for deploy gating.
- Background: Rust services exposed `/health` only; API exposes `/ready` for readiness probes.
- Scope: `platform/services/*/src/main.rs`, `docs/observability-conventions.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add `/ready` routes (aliasing existing health payloads).
  2. Update observability docs and checklist status.
- Risks & Mitigations: readiness semantics -> keep lightweight readiness until dependency checks are added.
- Verification: `cargo test --manifest-path platform/services/availability-rs/Cargo.toml` (plus other Rust services when touching readiness logic).
- Status: Completed; verification run.

## Plan: API OpenTelemetry Bootstrap

- Objective: Add optional OTel auto-instrumentation for the API when OTLP is configured.
- Background: Trace headers are already propagated; exporter wiring lets traces flow to OTLP backends.
- Scope: `platform/apps/api/src/otel.ts`, `platform/apps/api/src/main.ts`, `platform/apps/api/package.json`, `docs/observability-conventions.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add OTel dependencies and bootstrap file guarded by `OTEL_ENABLED`/`OTEL_EXPORTER_OTLP_ENDPOINT`.
  2. Import the bootstrap early in `main.ts`.
  3. Update observability docs and checklist notes.
- Risks & Mitigations: init order -> import bootstrap before app creation; env drift -> document `OTEL_ENABLED` and endpoint.
- Verification: `pnpm --dir platform/apps/api test:smoke`.
- Status: Completed; verification run.

## Plan: Rust OpenTelemetry Exporters

- Objective: Export Rust service traces to OTLP when configured and tie spans to incoming trace context.
- Background: Rust services emit structured spans but do not export to an OTLP backend.
- Scope: `platform/services/*/src/main.rs`, `platform/services/*/Cargo.toml`, `docs/observability-conventions.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add OTel dependencies and optional tracer initialization guarded by envs.
  2. Set parent context from inbound `traceparent` headers when present.
  3. Update docs and checklist notes.
- Risks & Mitigations: exporter misconfig -> guard on `OTEL_ENABLED`/endpoint; runtime overhead -> optional init only.
- Verification: `cargo test --manifest-path platform/services/availability-rs/Cargo.toml`, `cargo test --manifest-path platform/services/payment-processor-rs/Cargo.toml`, `cargo test --manifest-path platform/services/auth-service-rs/Cargo.toml`.
- Status: Completed; verification run.

## Plan: Web OpenTelemetry Bootstrap

- Objective: Add optional OTLP tracing for the web app using the Vercel OTel SDK.
- Background: Next.js supports instrumentation hooks; web tracing should align with API/Rust service names.
- Scope: `platform/apps/web/instrumentation.ts`, `platform/apps/web/otel.ts`, `platform/apps/web/package.json`, `docs/observability-conventions.md`, `docs/repo_summary.md`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add OTel dependencies and bootstrap module.
  2. Load the OTel bootstrap when OTLP is configured.
  3. Update documentation and checklist notes.
- Risks & Mitigations: missing endpoint -> guard init; Vercel compatibility -> use `@vercel/otel`.
- Verification: `pnpm --dir platform/apps/web test`.
- Status: Completed; verification run.

## Plan: OpenAPI Contract Test

- Objective: Assert core API routes are captured in the OpenAPI spec to guard against contract drift.
- Background: OpenAPI spec is committed and used to generate SDK types; tests should pin core paths.
- Scope: `platform/apps/api/src/__tests__/openapi.contract.spec.ts`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add a Jest contract test that loads `openapi.json` and asserts key endpoints.
  2. Update checklist/changelog to reference the contract coverage.
- Risks & Mitigations: stale spec -> re-run `pnpm --dir platform/apps/api openapi:generate` before updating the file.
- Verification: `pnpm --dir platform/apps/api test -- --runTestsByPath src/__tests__/openapi.contract.spec.ts`.
- Status: Completed; verification run.

## Plan: Web OpenAPI Type Contract

- Objective: Use SDK OpenAPI types to enforce key web ↔ API routes at compile time.
- Background: Web consumes API endpoints; type-level checks avoid drift without runtime coupling.
- Scope: `platform/apps/web/lib/openapi-contract.ts`, `platform/apps/web/package.json`, `docs/vercel-standards-checklist.md`, `platform/CHANGELOG.md`.
- Steps:
  1. Add SDK as a dev dependency in the web app.
  2. Add type-level assertions for core paths/methods.
  3. Update docs/changelog.
- Risks & Mitigations: missing SDK build -> run `pnpm --dir platform/packages/sdk build` if types are stale.
- Verification: `pnpm --dir platform/apps/web typecheck`.
- Status: Completed; verification run.

## Plan: Best End-State Architecture & Migration

- Objective: Define the target architecture, runtime tier mapping, and migration plan that maximize product reliability and performance.
- Background: Current architecture blends Next.js, NestJS, and Rust services; Vercel-only deployment is not sufficient for long-running services and realtime.
- Scope: `docs/target-architecture.md`, `docs/runtime-tier-map.md`, `docs/migration-plan-best-end-state.md`, `docs/repo_summary.md`.
- Steps:
  1. Draft target architecture and SLOs with a clear runtime component map.
  2. Map Keepr modules to runtime tiers (edge/core/async/realtime).
  3. Produce phased migration plan with verification commands and risk register.
- Risks & Mitigations: architectural drift -> document and review quarterly; migration scope creep -> phase gates and exit criteria; platform assumptions -> validate against current deployment stack.
- Verification: documentation review; no runtime commands required.
- Status: Completed; docs added.

## Plan: AI UI Builder (json-render)

- Objective: Add a json-render powered AI UI builder for analytics dashboards, report composers, and staff workflows in Keepr.
- Background: json-render source at `/Users/josh/Documents/GitHub/github extra stuff/json-render-main`; use published `@json-render/react` renderer with Keepr AI provider endpoints.
- Scope: `platform/apps/api/src/ai`, `platform/apps/web/app/ai`, `platform/apps/web/components/ai`, `platform/apps/web/lib/page-registry.ts`.
- Steps:
  1. Add AI UI builder API endpoint with prompt sanitization, schema validation, and fallback tree.
  2. Add web builder page and component registry for dashboard/report/workflow templates.
  3. Wire page registry entry and run verification commands.
- Risks & Mitigations: prompt injection -> use `PromptSanitizerService`; malformed JSON -> validate + fallback; catalog/registry drift -> document follow-up for shared catalog.
- Verification: `pnpm --dir platform/apps/api test:smoke`, `pnpm lint:web`.
- Documentation / Follow-up: note catalog sharing plan in docs; update repo summary if new commands or structure change.
- Status: Completed; changelog updated and verification run.

## Plan: AI UI Builder Integration (phase 2)

- Objective: Persist generated layouts and connect them to live dashboards, reports, and workflows inside Keepr.
- Background: `/ai/ui-builder` renders json-render layouts today; drafts are stored locally per campground.
- Scope: add layout storage in `platform/apps/api`, wire `platform/apps/web/app/ai/ui-builder`, and integrate apply/publish flows in analytics, reports, and operations views. Keep mobile apps out of scope.
- Steps:
  1. Define `UiLayout` storage (campground scope, builder type, JSON tree, prompt metadata, versioning).
  2. Add CRUD API endpoints for layouts with auth/role checks and validation.
  3. Update the UI builder to save/load from the API when available; keep local drafts as fallback.
  4. Add "Apply layout" controls in dashboards/reports/workflows with a default layout fallback.
  5. Add audit logging + feature flag gates for publish actions and action bindings.
- Risks & Mitigations: schema drift -> share JSON schema in shared package; large trees -> cap size and validate; permissions -> enforce org + role checks.
- Verification: `pnpm --dir platform/apps/api test:smoke`, `pnpm lint:web`, `pnpm --dir platform/apps/web test`, `pnpm build`.
- Documentation / Follow-up: update `docs/architecture.mmd` and `docs/frontend.mmd` with the layout lifecycle; note new feature flag and env vars if added.
- Status: Proposed; awaiting approval.

## Plan: Chat Widget Upgrade (Vercel parity)

- Objective: Bring Keepr's guest, portal, staff, and support chat UX to Vercel Chat SDK quality, with public chats session-only and in-chat ticketing for staff support.
- Background: Reference `docs/chat-widget-upgrade-todo.md` and the Vercel Chat SDK template at `/Users/josh/Documents/GitHub/github extra stuff/ai-chatbot-main`; existing widgets live in `platform/apps/web/components/chat`, `platform/apps/web/components/ai`, and `platform/apps/web/components/support`.
- Scope: `platform/apps/web/components/chat`, `platform/apps/web/components/ai`, `platform/apps/web/components/support`, `platform/apps/web/components/dashboard`, `platform/apps/web/components/portal`, `platform/apps/api/src/chat`, `platform/apps/api/src/ai`, `platform/apps/web/lib`, `docs/chat-widget-upgrade-todo.md`.
- Steps:
  1. Phase 0: unify chat shell + message rendering, align suggested prompts, and baseline tool approval UI for staff.
  2. Phase 1: add AI SDK-compatible streaming adapter (SSE/proxy) and wire `@ai-sdk/react`-style UI patterns.
  3. Phase 1b: add authenticated chat history list + resume; keep public guest chat session-only.
  4. Phase 2: add attachments + artifact sidecar (quotes, availability, reports).
  5. Phase 3: add in-chat ticketing + email fallback for staff-to-Keepr support.
  6. Run verification commands after each batch.
- Risks & Mitigations: streaming adapter complexity -> incremental rollout + feature flags; PII retention -> session-only public chat + retention policy; action safety -> confirmations + audit trail; attachment storage -> choose storage provider with scoped access.
- Verification: `pnpm lint:web`, `pnpm --dir platform/apps/api test:smoke`, `pnpm --dir platform/apps/web test`, `pnpm --dir platform/apps/web test:e2e`, `pnpm build`.
- Documentation / Follow-up: update `docs/frontend.mmd` as shared chat shell conventions emerge; keep `docs/chat-widget-upgrade-todo.md` current as phases ship.
- Status: Step 6 complete (unit + Playwright coverage, feature flag rollout gates, k6 load test script, streaming/render perf tweaks).
- Status: In progress; Phase 0 complete; Phase 1 streaming + message actions + history panel delivered; Phase 1b conversation list + resume delivered; feedback/regenerate persistence delivered; Phase 2 attachments upload + preview delivered; staff history search/filters + auto-titles delivered; artifact sidecar delivered; feedback/regenerate analytics events delivered; attachment content type typing + support/partner history role filters fixed for web build; Phase 3 support ticket composer with severity, transcript, attachments, and SLA/email fallback delivered; json-render report/graph cards now render in the chat artifact panel; occupancy/revenue tools now emit json-render payloads for inline charts/tables; tool call inputs/outputs + jump-to-latest scroll controls now live; markdown rendering enabled for chat messages; GFM tables + code block copy buttons, internal note visibility, new message marker, and message-level animations/skeletons shipped; Step 1 UX rules, microcopy, and mobile/kiosk guidelines documented with long-message scroll affordances and keyboard support; Step 2 guest/staff workflow coverage delivered (reservation change requests, post-stay prompts, structured availability/balance/task cards, audit logging for tool actions); Step 3 message parts schema + transcript export + conversation delete endpoints delivered; chat tool execution endpoints extended for staff/guest; public booking chat set to session-only persistence; mode-specific prompts and PII guardrails now cover public/portal/support/staff; staff approvals now include action summaries and hold tools; SSE streaming avoids duplicate content and tool result facts reduce contradictory summaries; chat scroll containment hardened with non-passive wheel/touch capture to stop page scroll bleed on trackpad/touch; Step 5 security/compliance/observability complete (role-based access enforcement, rate limiting, consent endpoints, PII log redaction, chat telemetry for actions/tools/streaming, AI budget warnings).

## Plan: Campground Onboarding Finalization

- Objective: Finalize campground ownership + bookability on launch, align onboarding step payloads, and tighten onboarding invite/AI import safety.
- Background: Onboarding flow spans `platform/apps/web/app/(public)/onboarding` and `platform/apps/api/src/onboarding` with early-access invites and AI import.
- Scope: `platform/apps/api/src/onboarding`, `platform/apps/api/src/onboarding/ai-import`, `platform/apps/web/app/(public)/onboarding`, `platform/CHANGELOG.md`.
- Steps:
  1. Update API to finalize launch and accept flat/nested onboarding payloads; add invite access checks and filename sanitization.
  2. Align web onboarding payloads and back-compat parsing.
  3. Update changelog and run verification commands.
- Risks & Mitigations: missing owner user -> fallback to invite email lookup; payload drift -> back-compat parsing on web + nested support in API; auth edge cases -> allow platform staff to bypass.
- Verification: `pnpm --dir platform/apps/api test:smoke`, `pnpm lint:web`.
- Documentation / Follow-up: capture any onboarding UX gaps found during regression QA.
- Status: Completed; verification run.

## Plan: Onboarding Reservation Import Hardening

- Objective: Ensure onboarding reservation import enforces token scope/expiry, uses active sites only, respects conflict checks, and honors system pricing.
- Background: Onboarding reservation import endpoints are used by `platform/apps/web/app/(public)/onboarding` with early-access tokens.
- Scope: `platform/apps/api/src/data-import`, `platform/apps/web/app/(public)/onboarding`, `platform/CHANGELOG.md`.
- Steps:
  1. Enforce onboarding token expiry/scope and tighten import execution rules (conflicts, system pricing, guest dedupe).
  2. Align onboarding reservation import API base handling in web client.
  3. Run verification commands and update changelog.
- Risks & Mitigations: system pricing gaps -> fall back to CSV unless explicitly toggled; inactive sites in imports -> filter and reject at execution; token expiry edge cases -> validate invite/session expirations.
- Verification: `pnpm --dir platform/apps/api test:smoke`, `pnpm lint:web`.
- Documentation / Follow-up: confirm whether an explicit conflict override should be supported in UI/API.
- Status: Completed; verification run.

## Plan: Onboarding Import Checklist + Coverage

- Objective: Guide onboarding users to export the right forms from their prior system, track missing fields, and allow a warning override.
- Background: AI import flow already classifies uploads but lacks system-specific guidance and completeness tracking.
- Scope: `platform/apps/api/src/onboarding/ai-import`, `platform/apps/web/app/(public)/onboarding/[token]/steps/DataImport.tsx`, `platform/apps/web/app/(public)/onboarding/[token]/components/ai-import`, `platform/CHANGELOG.md`.
- Steps:
  1. Add import requirements + coverage endpoint for system-specific forms and missing fields.
  2. Update onboarding AI import UI with checklist, missing info panel, and override flow.
  3. Persist system selection + override state on continue and highlight next exports to grab.
  4. Add data_import draft-save endpoint and show import metadata on Review/Launch.
  5. Sync draft coverage into wizard state and feed import status into go-live warnings.
  6. Run verification commands and update changelog.
- Risks & Mitigations: missing columns in PDFs/images -> rely on AI extraction before coverage; system export naming drift -> keep forms descriptive and allow "Other" option; missing required data -> explicit warning + checkbox override.
- Verification: `pnpm --dir platform/apps/api test:smoke`, `pnpm lint:web`.
- Documentation / Follow-up: persisted system selection + override acceptance in the `data_import` payload; added draft-save endpoint + Review/Launch import metadata panel; synced draft changes to wizard state + go-live warnings.
- Status: Completed; verification run; follow-up applied for data_import persistence + next-exports prompt + draft-save/review panel + go-live warning sync.

## Plan: API Jest Worker Exit Mitigation

- Objective: Eliminate Jest worker exit warnings and stabilize API test teardown.
- Background: `pnpm --dir platform/apps/api test` consistently warned about worker processes failing to exit gracefully across multiple test batches.
- Scope: `platform/apps/api/src/security/security-events.service.ts`, `platform/apps/api/src/security/account-lockout.service.ts`, `platform/apps/api/src/chat/chat.service.ts`, `platform/apps/api/src/holds/holds.service.ts`, `platform/apps/api/src/queues/bull-queue.service.ts`, `platform/apps/api/src/webhooks/webhook-delivery.service.ts`, `platform/apps/api/src/developer-api/webhook.service.ts`, `platform/apps/api/src/developer-api/webhook-admin.controller.ts`, `platform/apps/api/src/backup/backup.service.ts`, `platform/apps/api/src/campgrounds/campground-review-connectors.service.ts`, `platform/apps/api/src/payments/reconciliation.service.ts`, `platform/apps/api/test/jest-setup.ts`, `platform/apps/api/jest.config.js`, `platform/apps/api/package.json`, `platform/CHANGELOG.md`.
- Steps:
  1. Add `unref()` + clear behavior for background intervals and abort timeouts in API services that schedule timers.
  2. Guard alert webhook URLs and add abort timeout handling for reconciliation alerts.
  3. Add Jest setup hook to close the undici dispatcher and optionally log active handles.
  4. Default API tests to run in-band; set `JEST_RUN_IN_BAND=false` and `JEST_MAX_WORKERS` to re-enable workers when needed.
  5. Rerun `pnpm test` (or `pnpm --dir platform/apps/api test`) to confirm the warning is gone.
- Risks & Mitigations: slower API test runtime -> accept slower runs while stabilizing; potential masking of underlying leaks -> keep optional `JEST_DEBUG_HANDLES` logging and track a follow-up to re-enable workers once root cause is isolated.
- Verification: `pnpm test`.
- Documentation / Follow-up: track a future work item to re-enable Jest workers after isolating any lingering handles.
- Status: Completed; in-band default with env toggle available.

## Recent living-doc updates

- **2026-01-12**: `docs/repo_summary.md` now highlights `docs/architecture.mmd`, `docs/frontend.mmd`, and this `docs/exec_plans.md` file as the go-to living references for architecture, UX, and cross-system execution plans; refresh all three whenever a major entry point, environment, or verification command changes.
- **2026-01-18**: Added `scripts/status.sh` as the local `/status` helper for Codex environment snapshots; updated repo summary to document the helper command.
