"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// src/serverless.ts
var serverless_exports = {};
__export(serverless_exports, {
  default: () => serverless_default,
  handler: () => handler
});
module.exports = __toCommonJS(serverless_exports);
var import_reflect_metadata2 = require("reflect-metadata");
var import_serverless_express = __toESM(require("@codegenie/serverless-express"));

// src/app.bootstrap.ts
var import_reflect_metadata = require("reflect-metadata");
var import_core2 = require("@nestjs/core");
var import_common304 = require("@nestjs/common");

// src/app.module.ts
var import_common300 = require("@nestjs/common");
var import_config2 = require("@nestjs/config");

// src/prisma/prisma.service.ts
var import_common = require("@nestjs/common");
var import_client = require("@prisma/client");
var import_adapter_pg = require("@prisma/adapter-pg");
var PrismaService = class extends import_client.PrismaClient {
  constructor() {
    const connectionString = process.env.DATABASE_URL || process.env.PLATFORM_DATABASE_URL;
    if (!connectionString) {
      console.error("No DATABASE_URL or PLATFORM_DATABASE_URL found");
    }
    const adapter = new import_adapter_pg.PrismaPg({ connectionString });
    super({ adapter });
  }
  async onModuleInit() {
    await this.$connect();
  }
  async enableShutdownHooks(app) {
    process.on("beforeExit", async () => {
      await app.close();
    });
  }
};
PrismaService = __decorateClass([
  (0, import_common.Injectable)()
], PrismaService);

// src/app.module.ts
var import_schedule17 = require("@nestjs/schedule");

// src/auth/auth.module.ts
var import_common7 = require("@nestjs/common");
var import_jwt = require("@nestjs/jwt");
var import_passport3 = require("@nestjs/passport");
var import_config = require("@nestjs/config");

// src/auth/auth.controller.ts
var import_common4 = require("@nestjs/common");

// src/auth/guards/jwt-auth.guard.ts
var import_common2 = require("@nestjs/common");
var import_passport = require("@nestjs/passport");
var JwtAuthGuard = class extends (0, import_passport.AuthGuard)("jwt") {
  canActivate(context) {
    return super.canActivate(context);
  }
};
JwtAuthGuard = __decorateClass([
  (0, import_common2.Injectable)()
], JwtAuthGuard);

// src/auth/guards/roles.guard.ts
var import_common3 = require("@nestjs/common");
var ROLES_KEY = "roles";
var Roles = (...roles) => (0, import_common3.SetMetadata)(ROLES_KEY, roles);
var RolesGuard = class {
  constructor(reflector) {
    this.reflector = reflector;
  }
  canActivate(context) {
    const requiredRoles = this.reflector.getAllAndOverride(ROLES_KEY, [
      context.getHandler(),
      context.getClass()
    ]);
    if (!requiredRoles || requiredRoles.length === 0) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const campgroundId = request.params?.campgroundId || request.query?.campgroundId || request.body?.campgroundId || request.campgroundId || request.headers["x-campground-id"];
    if (!user || !user.memberships) {
      return false;
    }
    const membership = user.memberships.find(
      (m) => m.campgroundId === campgroundId
    );
    if (!membership) {
      return false;
    }
    return requiredRoles.includes(membership.role);
  }
};
RolesGuard = __decorateClass([
  (0, import_common3.Injectable)()
], RolesGuard);

// src/auth/auth.controller.ts
var AuthController = class {
  constructor(authService) {
    this.authService = authService;
  }
  register(dto) {
    return this.authService.register(dto);
  }
  login(dto) {
    return this.authService.login(dto);
  }
  getProfile(req) {
    return this.authService.getProfile(req.user.id);
  }
  acceptInvite(dto) {
    return this.authService.acceptInvite(dto);
  }
};
__decorateClass([
  (0, import_common4.Post)("register"),
  __decorateParam(0, (0, import_common4.Body)())
], AuthController.prototype, "register", 1);
__decorateClass([
  (0, import_common4.Post)("login"),
  __decorateParam(0, (0, import_common4.Body)())
], AuthController.prototype, "login", 1);
__decorateClass([
  (0, import_common4.Get)("me"),
  (0, import_common4.UseGuards)(JwtAuthGuard),
  __decorateParam(0, (0, import_common4.Request)())
], AuthController.prototype, "getProfile", 1);
__decorateClass([
  (0, import_common4.Post)("invitations/accept"),
  __decorateParam(0, (0, import_common4.Body)())
], AuthController.prototype, "acceptInvite", 1);
AuthController = __decorateClass([
  (0, import_common4.Controller)("auth")
], AuthController);

// src/auth/auth.service.ts
var import_common5 = require("@nestjs/common");
var bcrypt = __toESM(require("bcryptjs"));
var AuthService = class {
  constructor(prisma, jwtService) {
    this.prisma = prisma;
    this.jwtService = jwtService;
  }
  async register(dto) {
    const existing = await this.prisma.user.findUnique({
      where: { email: dto.email.toLowerCase() }
    });
    if (existing) {
      throw new import_common5.ConflictException("Email already registered");
    }
    const passwordHash = await bcrypt.hash(dto.password, 12);
    const user = await this.prisma.user.create({
      data: {
        email: dto.email.toLowerCase(),
        passwordHash,
        firstName: dto.firstName,
        lastName: dto.lastName
      }
    });
    const token = this.generateToken(user.id, user.email);
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      token
    };
  }
  async login(dto) {
    const user = await this.prisma.user.findUnique({
      where: { email: dto.email.toLowerCase() },
      include: {
        memberships: {
          include: { campground: { select: { id: true, name: true, slug: true } } }
        }
      }
    });
    if (!user || !user.isActive) {
      throw new import_common5.UnauthorizedException("Invalid credentials");
    }
    const passwordValid = await bcrypt.compare(dto.password, user.passwordHash);
    if (!passwordValid) {
      throw new import_common5.UnauthorizedException("Invalid credentials");
    }
    const token = this.generateToken(user.id, user.email);
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      campgrounds: user.memberships.map((m) => ({
        id: m.campground.id,
        name: m.campground.name,
        slug: m.campground.slug,
        role: m.role
      })),
      token
    };
  }
  async getProfile(userId) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        memberships: {
          include: { campground: { select: { id: true, name: true, slug: true } } }
        }
      }
    });
    if (!user) {
      throw new import_common5.UnauthorizedException("User not found");
    }
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      campgrounds: user.memberships.map((m) => ({
        id: m.campground.id,
        name: m.campground.name,
        slug: m.campground.slug,
        role: m.role
      }))
    };
  }
  generateToken(userId, email) {
    return this.jwtService.sign(
      { sub: userId, email },
      { expiresIn: "7d" }
    );
  }
  async acceptInvite(dto) {
    const invite = await this.prisma.inviteToken.findUnique({
      where: { token: dto.token },
      include: { user: true }
    });
    if (!invite || invite.redeemedAt) {
      throw new import_common5.UnauthorizedException("Invalid or already used invite");
    }
    if (invite.expiresAt < /* @__PURE__ */ new Date()) {
      throw new import_common5.UnauthorizedException("Invite has expired");
    }
    const passwordHash = await bcrypt.hash(dto.password, 12);
    const user = await this.prisma.user.update({
      where: { id: invite.userId },
      data: {
        passwordHash,
        firstName: dto.firstName,
        lastName: dto.lastName,
        isActive: true
      }
    });
    await this.prisma.inviteToken.update({
      where: { id: invite.id },
      data: { redeemedAt: /* @__PURE__ */ new Date() }
    });
    const token = this.generateToken(user.id, user.email);
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      token
    };
  }
};
AuthService = __decorateClass([
  (0, import_common5.Injectable)()
], AuthService);

// src/auth/strategies/jwt.strategy.ts
var import_common6 = require("@nestjs/common");
var import_passport2 = require("@nestjs/passport");
var import_passport_jwt = require("passport-jwt");
var JwtStrategy = class extends (0, import_passport2.PassportStrategy)(import_passport_jwt.Strategy) {
  constructor(config2, prisma) {
    super({
      jwtFromRequest: import_passport_jwt.ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: config2.get("JWT_SECRET") || "dev-secret-change-me"
    });
    this.config = config2;
    this.prisma = prisma;
  }
  async validate(payload) {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.sub },
      include: {
        memberships: {
          include: { campground: true }
        }
      }
    });
    if (!user || !user.isActive) {
      throw new import_common6.UnauthorizedException();
    }
    const memberships = user.memberships.map((m) => ({
      id: m.id,
      campgroundId: m.campgroundId,
      role: m.role,
      campground: m.campground ? { id: m.campground.id, name: m.campground.name, slug: m.campground.slug } : void 0
    }));
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      region: user.region ?? null,
      platformRole: user.platformRole ?? null,
      platformRegion: user.platformRegion ?? null,
      platformActive: user.platformActive ?? true,
      ownershipRoles: user.ownershipRoles ?? [],
      role: memberships[0]?.role ?? null,
      memberships
    };
  }
};
JwtStrategy = __decorateClass([
  (0, import_common6.Injectable)()
], JwtStrategy);

// src/auth/auth.module.ts
var AuthModule = class {
};
AuthModule = __decorateClass([
  (0, import_common7.Module)({
    imports: [
      import_passport3.PassportModule.register({ defaultStrategy: "jwt" }),
      import_jwt.JwtModule.registerAsync({
        imports: [import_config.ConfigModule],
        useFactory: (config2) => ({
          secret: config2.get("JWT_SECRET") || "dev-secret-change-me",
          signOptions: { expiresIn: "7d" }
        }),
        inject: [import_config.ConfigService]
      })
    ],
    controllers: [AuthController],
    providers: [AuthService, JwtStrategy, PrismaService],
    exports: [AuthService, import_jwt.JwtModule]
  })
], AuthModule);

// src/organizations/organizations.module.ts
var import_common10 = require("@nestjs/common");

// src/organizations/organizations.service.ts
var import_common8 = require("@nestjs/common");
var OrganizationsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  findAll() {
    return this.prisma.organization.findMany();
  }
  create(data) {
    return this.prisma.organization.create({ data });
  }
};
OrganizationsService = __decorateClass([
  (0, import_common8.Injectable)()
], OrganizationsService);

// src/organizations/organizations.controller.ts
var import_common9 = require("@nestjs/common");
var OrganizationsController = class {
  constructor(orgs) {
    this.orgs = orgs;
  }
  findAll() {
    return this.orgs.findAll();
  }
  create(body) {
    return this.orgs.create(body);
  }
};
__decorateClass([
  (0, import_common9.Get)()
], OrganizationsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common9.Post)(),
  __decorateParam(0, (0, import_common9.Body)())
], OrganizationsController.prototype, "create", 1);
OrganizationsController = __decorateClass([
  (0, import_common9.UseGuards)(JwtAuthGuard),
  (0, import_common9.Controller)("organizations")
], OrganizationsController);

// src/organizations/organizations.module.ts
var OrganizationsModule = class {
};
OrganizationsModule = __decorateClass([
  (0, import_common10.Module)({
    controllers: [OrganizationsController],
    providers: [OrganizationsService, PrismaService],
    exports: [OrganizationsService]
  })
], OrganizationsModule);

// src/campgrounds/campgrounds.module.ts
var import_common28 = require("@nestjs/common");

// src/campgrounds/campgrounds.service.ts
var import_common11 = require("@nestjs/common");
var bcrypt2 = __toESM(require("bcryptjs"));
var import_client2 = require("@prisma/client");
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_promises = __toESM(require("dns/promises"));
var CampgroundsService = class {
  constructor(prisma, emailService, audit, assets, reviewConnectors) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.audit = audit;
    this.assets = assets;
    this.reviewConnectors = reviewConnectors;
    this.INVITE_RESEND_COOLDOWN_MS = 10 * 60 * 1e3;
    // 10 minutes
    this.EXTERNAL_ORG_NAME = "External Inventory";
    this.DEFAULT_SLA_MINUTES = Number(process.env.DEFAULT_SLA_MINUTES || 30);
    this.amenityKeyMap = {
      power_supply: "Power",
      drinking_water: "Drinking Water",
      sanitary_dump_station: "Dump Station",
      internet_access: "Internet",
      wifi: "WiFi",
      shower: "Showers",
      toilet: "Restrooms",
      picnic_table: "Picnic Table",
      firepit: "Fire Pits",
      bbq: "BBQ",
      playground: "Playground",
      swimming_pool: "Pool",
      laundry: "Laundry",
      store: "Camp Store",
      dog: "Pet Friendly",
      fee: "Fees Apply",
      caravan: "RV Sites",
      tent: "Tent Sites",
      backcountry: "Backcountry",
      cabin: "Cabins",
      reservation: "Reservations",
      charge: "EV Charging"
    };
  }
  slugifyName(name) {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").slice(0, 64) || `camp-${(0, import_crypto.randomBytes)(3).toString("hex")}`;
  }
  normalizeName(name) {
    return (name || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
  }
  nameSimilarity(a, b) {
    if (!a || !b) return 0;
    const aParts = new Set(this.normalizeName(a).split(" ").filter(Boolean));
    const bParts = new Set(this.normalizeName(b).split(" ").filter(Boolean));
    if (aParts.size === 0 || bParts.size === 0) return 0;
    let overlap = 0;
    for (const part of aParts) {
      if (bParts.has(part)) overlap++;
    }
    return overlap / Math.max(aParts.size, bParts.size);
  }
  extractAmenitiesFromTags(tags) {
    if (!tags) return [];
    const amenities = /* @__PURE__ */ new Set();
    for (const [key, label] of Object.entries(this.amenityKeyMap)) {
      if (tags[key] || tags[`amenity:${key}`]) {
        amenities.add(label);
      }
    }
    if (tags["internet_access"] === "wlan" || tags["internet_access"] === "yes") {
      amenities.add("WiFi");
    }
    if (tags["sanitary_dump_station"] === "yes") {
      amenities.add("Dump Station");
    }
    if (tags["power_supply"] === "yes") {
      amenities.add("Power");
    }
    if (tags["caravan_site"] === "yes" || tags["caravan"] === "yes") {
      amenities.add("RV Sites");
    }
    if (tags["tents"] === "yes" || tags["tent"] === "yes") {
      amenities.add("Tent Sites");
    }
    if (tags["cabins"] === "yes" || tags["cabin"] === "yes") {
      amenities.add("Cabins");
    }
    return Array.from(amenities);
  }
  amenitySummaryFromTags(tags) {
    if (!tags) return void 0;
    const summary = {};
    for (const [key, label] of Object.entries(this.amenityKeyMap)) {
      if (tags[key] !== void 0) {
        summary[label] = tags[key];
      }
    }
    if (tags["internet_access"]) summary["Internet"] = tags["internet_access"];
    if (tags["sanitary_dump_station"]) summary["Dump Station"] = tags["sanitary_dump_station"];
    if (tags["power_supply"]) summary["Power"] = tags["power_supply"];
    return Object.keys(summary).length ? summary : void 0;
  }
  computeBlendedReviewScore(sources, fallback) {
    if (!sources || sources.length === 0) {
      return { score: fallback ?? null, count: void 0 };
    }
    let weightedSum = 0;
    let totalWeight = 0;
    let totalCount = 0;
    for (const src of sources) {
      if (src.rating === void 0 || src.rating === null) continue;
      const weight = src.weight ?? 1;
      weightedSum += Number(src.rating) * weight;
      totalWeight += weight;
      if (src.count) totalCount += src.count;
    }
    const score = totalWeight > 0 ? weightedSum / totalWeight : fallback ?? null;
    return { score, count: totalCount || void 0 };
  }
  async refreshExternalReviews(campgroundId, opts) {
    const cg = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: {
        id: true,
        dataSource: true,
        dataSourceId: true,
        reviewScore: true,
        reviewCount: true,
        reviewSources: true
      }
    });
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    const reviews = await this.reviewConnectors.collectExternalReviews({
      googlePlaceId: opts?.googlePlaceId || (cg.dataSource === "google_places" ? cg.dataSourceId || void 0 : void 0),
      rvLifeId: opts?.rvLifeId
    });
    const blended = this.computeBlendedReviewScore(
      reviews.map((r) => ({ source: r.source, rating: r.rating ?? void 0, count: r.count ?? void 0 })),
      cg.reviewScore
    );
    return this.prisma.campground.update({
      where: { id: cg.id },
      data: {
        reviewScore: blended.score ?? cg.reviewScore ?? null,
        reviewCount: blended.count ?? cg.reviewCount ?? 0,
        reviewSources: reviews,
        reviewsUpdatedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async mirrorCampgroundPhotos(campgroundId) {
    const cg = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: { id: true, photos: true }
    });
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    if (!cg.photos || cg.photos.length === 0) return { updated: false, photos: [], meta: [] };
    const { photos, meta } = await this.assets.mirrorPhotos(cg.photos);
    const updated = await this.prisma.campground.update({
      where: { id: cg.id },
      data: {
        photos,
        photosMeta: meta ?? []
      }
    });
    return { updated: true, photos: updated.photos, meta: updated.photosMeta };
  }
  async updatePhotos(campgroundId, dto, organizationId, actorId) {
    const cg = await this.prisma.campground.findUnique({ where: { id: campgroundId }, select: { id: true, organizationId: true, photos: true } });
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    if (organizationId && cg.organizationId !== organizationId) throw new import_common11.ForbiddenException("Unauthorized");
    const unique = Array.from(new Set(dto.photos.filter(Boolean)));
    if (unique.length === 0) throw new import_common11.BadRequestException("At least one photo is required");
    const updated = await this.prisma.campground.update({
      where: { id: campgroundId },
      data: {
        photos: unique,
        heroImageUrl: dto.heroImageUrl ?? void 0
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "campground.photos.update",
      entity: "campground",
      entityId: campgroundId,
      before: { photos: cg.photos },
      after: { photos: updated.photos, hero: dto.heroImageUrl ?? updated.heroImageUrl ?? null },
      ip: null,
      userAgent: null
    });
    await this.prisma.analyticsEvent.create({
      data: {
        sessionId: (0, import_crypto2.randomUUID)(),
        eventName: "admin_image_reorder",
        campground: { connect: { id: campgroundId } },
        metadata: { count: updated.photos.length }
      }
    });
    return updated;
  }
  async ensureExternalOrganization(organizationId) {
    if (organizationId) return organizationId;
    if (process.env.EXTERNAL_ORG_ID) return process.env.EXTERNAL_ORG_ID;
    const existing = await this.prisma.organization.findFirst({
      where: { name: this.EXTERNAL_ORG_NAME }
    });
    if (existing) return existing.id;
    const org = await this.prisma.organization.create({
      data: { name: this.EXTERNAL_ORG_NAME }
    });
    return org.id;
  }
  async findNearbyCampground(name, latitude, longitude) {
    if (latitude === void 0 || longitude === void 0 || latitude === null || longitude === null) return null;
    const lat = Number(latitude);
    const lon = Number(longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    const delta = 0.1;
    const candidates = await this.prisma.campground.findMany({
      where: {
        latitude: { gte: lat - delta, lte: lat + delta },
        longitude: { gte: lon - delta, lte: lon + delta }
      },
      take: 10
    });
    if (!name) return candidates[0] || null;
    const scored = candidates.map((c) => ({
      campground: c,
      score: this.nameSimilarity(name, c.name)
    })).sort((a, b) => b.score - a.score);
    return scored[0]?.score && scored[0].score >= 0.4 ? scored[0].campground : null;
  }
  listByOrganization(organizationId) {
    return this.prisma.campground.findMany({ where: { organizationId } });
  }
  listAll(orgId) {
    if (orgId) {
      return this.prisma.campground.findMany({ where: { organizationId: orgId } });
    }
    return this.prisma.campground.findMany();
  }
  // Public campgrounds (published only)
  listPublic() {
    return this.prisma.campground.findMany({
      where: { OR: [{ isPublished: true }, { isExternal: true }] },
      select: {
        id: true,
        name: true,
        slug: true,
        city: true,
        state: true,
        country: true,
        tagline: true,
        heroImageUrl: true,
        amenities: true,
        photos: true,
        isExternal: true,
        isBookable: true,
        externalUrl: true,
        reviewScore: true,
        reviewCount: true,
        reviewSources: true,
        amenitySummary: true
      }
    });
  }
  findOne(id, orgId) {
    return this.prisma.campground.findFirst({ where: { id, ...orgId ? { organizationId: orgId } : {} } });
  }
  async updateSlaMinutes(id, slaMinutes, orgId) {
    if (slaMinutes < 1 || slaMinutes > 720) {
      throw new import_common11.ConflictException("slaMinutes must be between 1 and 720");
    }
    await this.assertCampgroundScoped(id, orgId);
    return this.prisma.campground.update({
      where: { id },
      data: { slaMinutes }
    });
  }
  async lookupTxt(domain) {
    try {
      const txt = await import_promises.default.resolveTxt(domain);
      return txt.flat();
    } catch (err) {
      return [];
    }
  }
  evaluateSpf(txtRecords) {
    const spf = txtRecords.find((t) => t.toLowerCase().startsWith("v=spf1"));
    if (!spf) return { status: "fail", record: null };
    if (spf.includes("-all") || spf.includes("~all") || spf.includes("?all") || spf.includes("+all")) {
      return { status: "pass", record: spf };
    }
    return { status: "unknown", record: spf };
  }
  evaluateDmarc(txtRecords) {
    const rec = txtRecords.find((t) => t.toLowerCase().startsWith("v=dmarc1"));
    if (!rec) return { status: "fail", record: null };
    return { status: "pass", record: rec };
  }
  async verifySenderDomain(id, domain, orgId) {
    await this.assertCampgroundScoped(id, orgId);
    const normalized = domain.trim().toLowerCase();
    const spfTxt = await this.lookupTxt(normalized);
    const dmarcTxt = await this.lookupTxt(`_dmarc.${normalized}`);
    const spf = this.evaluateSpf(spfTxt);
    const dmarc = this.evaluateDmarc(dmarcTxt);
    const status = spf.status === "pass" && dmarc.status === "pass" ? "verified" : "failed";
    const updated = await this.prisma.campground.update({
      where: { id },
      data: {
        senderDomain: normalized,
        senderDomainStatus: status,
        senderDomainCheckedAt: /* @__PURE__ */ new Date(),
        senderDomainSpf: spf.record,
        senderDomainDmarc: dmarc.record
      }
    });
    return {
      status,
      spf,
      dmarc,
      checkedAt: updated.senderDomainCheckedAt
    };
  }
  async updateOpsSettings(id, data, orgId) {
    await this.assertCampgroundScoped(id, orgId);
    return this.prisma.campground.update({
      where: { id },
      data: {
        quietHoursStart: data.quietHoursStart ?? null,
        quietHoursEnd: data.quietHoursEnd ?? null,
        routingAssigneeId: data.routingAssigneeId ?? null
      }
    });
  }
  async updateStoreHours(id, open, close, orgId) {
    if (open !== void 0 && (open < 0 || open > 23)) {
      throw new import_common11.ConflictException("storeOpenHour must be between 0 and 23");
    }
    if (close !== void 0 && (close < 0 || close > 23)) {
      throw new import_common11.ConflictException("storeCloseHour must be between 0 and 23");
    }
    if (open !== void 0 && close !== void 0 && open >= close) {
      throw new import_common11.ConflictException("storeOpenHour must be before storeCloseHour");
    }
    const cg = await this.findOne(id, orgId);
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    return this.prisma.campground.update({
      where: { id },
      data: {
        ...open !== void 0 ? { storeOpenHour: open } : {},
        ...close !== void 0 ? { storeCloseHour: close } : {}
      }
    });
  }
  async updateOrderWebhook(id, orderWebhookUrl, orgId) {
    const cg = await this.findOne(id, orgId);
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    return this.prisma.campground.update({
      where: { id },
      data: { orderWebhookUrl: orderWebhookUrl || null }
    });
  }
  async updateAnalytics(id, data, orgId) {
    const cg = await this.findOne(id, orgId);
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    return this.prisma.campground.update({
      where: { id },
      data: {
        gaMeasurementId: data.gaMeasurementId ?? null,
        metaPixelId: data.metaPixelId ?? null
      }
    });
  }
  async updateNpsSettings(id, data, orgId) {
    const cg = await this.findOne(id, orgId);
    if (!cg) throw new import_common11.NotFoundException("Campground not found");
    if (data.npsSendHour !== void 0 && data.npsSendHour !== null) {
      if (data.npsSendHour < 0 || data.npsSendHour > 23) {
        throw new import_common11.BadRequestException("npsSendHour must be between 0 and 23");
      }
    }
    return this.prisma.campground.update({
      where: { id },
      data: {
        ...data.npsAutoSendEnabled !== void 0 ? { npsAutoSendEnabled: data.npsAutoSendEnabled } : {},
        ...data.npsSendHour !== void 0 ? { npsSendHour: data.npsSendHour } : {},
        ...data.npsTemplateId !== void 0 ? { npsTemplateId: data.npsTemplateId } : {},
        ...data.npsSchedule !== void 0 ? { npsSchedule: data.npsSchedule } : {}
      }
    });
  }
  // Find by slug with full public details including events and site classes
  async findBySlug(slug) {
    const campground = await this.prisma.campground.findUnique({
      where: { slug },
      include: {
        siteClasses: {
          where: { isActive: true },
          orderBy: { defaultRate: "asc" }
        },
        events: {
          where: {
            isPublished: true,
            isCancelled: false,
            startDate: { gte: /* @__PURE__ */ new Date() }
          },
          orderBy: { startDate: "asc" },
          take: 10
        },
        promotions: {
          where: { isActive: true },
          orderBy: { createdAt: "desc" }
        }
      }
    });
    return campground;
  }
  create(data) {
    const {
      taxState,
      taxLocal,
      seasonStart,
      seasonEnd,
      dataSourceUpdatedAt,
      amenities,
      photos,
      reviewScore,
      reviewCount,
      ...rest
    } = data;
    return this.prisma.campground.create({
      data: {
        ...rest,
        taxState: taxState ? Number(taxState) : null,
        taxLocal: taxLocal ? Number(taxLocal) : null,
        seasonStart: seasonStart ? new Date(seasonStart) : null,
        seasonEnd: seasonEnd ? new Date(seasonEnd) : null,
        dataSourceUpdatedAt: dataSourceUpdatedAt ? new Date(dataSourceUpdatedAt) : null,
        amenities: amenities ?? [],
        photos: photos ?? [],
        isBookable: rest?.isBookable ?? true,
        isExternal: rest?.isExternal ?? false,
        externalUrl: rest?.externalUrl ?? null,
        nonBookableReason: rest?.nonBookableReason ?? null,
        reviewScore: reviewScore !== void 0 ? Number(reviewScore) : null,
        reviewCount: reviewCount !== void 0 ? Number(reviewCount) : 0
      }
    });
  }
  async upsertExternalCampground(payload) {
    const organizationId = await this.ensureExternalOrganization(payload.organizationId);
    const dataSourceKey = payload.dataSource && payload.dataSourceId ? { dataSource: payload.dataSource, dataSourceId: payload.dataSourceId } : null;
    let existing = dataSourceKey ? await this.prisma.campground.findFirst({ where: dataSourceKey }) : null;
    if (!existing) {
      existing = await this.findNearbyCampground(payload.name, payload.latitude, payload.longitude);
    }
    const slug = payload.slug || existing?.slug || this.slugifyName(payload.name);
    const amenitySummaryRaw = payload.amenitySummary ?? existing?.amenitySummary;
    const amenitySummary = amenitySummaryRaw === null || amenitySummaryRaw === void 0 ? void 0 : amenitySummaryRaw;
    const reviewSourcesRaw = payload.reviewSources ?? existing?.reviewSources;
    const reviewSources = reviewSourcesRaw === null || reviewSourcesRaw === void 0 ? void 0 : reviewSourcesRaw;
    const now = /* @__PURE__ */ new Date();
    const blended = this.computeBlendedReviewScore(
      payload.reviewSources,
      payload.reviewScore ?? existing?.reviewScore
    );
    const photosMetaRaw = payload.photosMeta ?? existing?.photosMeta;
    const photosMeta = photosMetaRaw === null || photosMetaRaw === void 0 ? void 0 : Array.isArray(photosMetaRaw) ? photosMetaRaw : photosMetaRaw;
    const data = {
      organizationId,
      name: payload.name,
      slug,
      city: payload.city ?? existing?.city,
      state: payload.state ?? existing?.state,
      country: payload.country ?? existing?.country,
      address1: payload.address1 ?? existing?.address1,
      address2: payload.address2 ?? existing?.address2,
      postalCode: payload.postalCode ?? existing?.postalCode,
      latitude: payload.latitude ?? existing?.latitude,
      longitude: payload.longitude ?? existing?.longitude,
      timezone: payload.timezone ?? existing?.timezone,
      phone: payload.phone ?? existing?.phone,
      email: payload.email ?? existing?.email,
      website: payload.website ?? existing?.website,
      externalUrl: payload.externalUrl ?? payload.website ?? existing?.externalUrl,
      isExternal: true,
      isBookable: payload.isBookable ?? false,
      nonBookableReason: payload.nonBookableReason ?? existing?.nonBookableReason ?? "View-only listing",
      isPublished: payload.isPublished ?? true,
      dataSource: payload.dataSource ?? existing?.dataSource ?? "osm",
      dataSourceId: payload.dataSourceId ?? existing?.dataSourceId,
      dataSourceUpdatedAt: payload.dataSourceUpdatedAt ? new Date(payload.dataSourceUpdatedAt) : existing?.dataSourceUpdatedAt,
      amenities: payload.amenities ?? existing?.amenities ?? [],
      amenitySummary,
      photos: payload.photos ?? existing?.photos ?? [],
      photosMeta,
      reviewScore: blended.score ?? null,
      reviewCount: payload.reviewCount ?? blended.count ?? existing?.reviewCount ?? 0,
      reviewSources,
      reviewsUpdatedAt: payload.reviewsUpdatedAt ? new Date(payload.reviewsUpdatedAt) : existing?.reviewsUpdatedAt,
      importedAt: payload.dataSourceUpdatedAt ? new Date(payload.dataSourceUpdatedAt) : existing?.importedAt ?? now,
      provenance: {
        ...existing?.provenance,
        lastIngestSource: payload.dataSource ?? existing?.dataSource ?? "osm",
        lastIngestedAt: now.toISOString()
      }
    };
    if (existing) {
      return this.prisma.campground.update({
        where: { id: existing.id },
        data
      });
    }
    return this.prisma.campground.create({
      data
    });
  }
  async ingestFromOsm(options = {}) {
    const bbox = options.bbox || // Broad North America box (lat, lon)
    "14.0,-171.0,83.0,-52.0";
    const query = `
      [out:json][timeout:180];
      (
        node["tourism"="camp_site"](${bbox});
        way["tourism"="camp_site"](${bbox});
        relation["tourism"="camp_site"](${bbox});
      );
      out center;
    `;
    const res = await globalThis.fetch("https://overpass-api.de/api/interpreter", {
      method: "POST",
      headers: { "Content-Type": "text/plain" },
      body: query
    });
    if (!res.ok) {
      throw new import_common11.ConflictException("Failed to pull OSM data");
    }
    const json = await res.json();
    const elements = Array.isArray(json?.elements) ? json.elements : [];
    const limited = options.limit ? elements.slice(0, options.limit) : elements;
    let upserted = 0;
    for (const el of limited) {
      const tags = el.tags || {};
      const center = el.center || (el.type === "node" ? { lat: el.lat, lon: el.lon } : null);
      if (!center) continue;
      await this.upsertExternalCampground({
        name: tags.name || tags.ref || `Campground ${el.id}`,
        slug: tags.slug,
        latitude: center.lat,
        longitude: center.lon,
        city: tags["addr:city"],
        state: tags["addr:state"] || tags["addr:province"],
        country: tags["addr:country"],
        postalCode: tags["addr:postcode"],
        website: tags.website || tags.url,
        externalUrl: tags.website || tags.url,
        phone: tags.phone,
        amenities: this.extractAmenitiesFromTags(tags),
        amenitySummary: this.amenitySummaryFromTags(tags),
        photos: tags.image ? [tags.image] : void 0,
        dataSource: "osm",
        dataSourceId: `${el.type}:${el.id}`,
        dataSourceUpdatedAt: tags["source:date"],
        isBookable: false,
        isPublished: true
      });
      upserted++;
    }
    return { processed: limited.length, upserted };
  }
  async getExternalIngestStatus() {
    const [totals, published, bookable, freshest, sources] = await Promise.all([
      this.prisma.campground.count({ where: { isExternal: true } }),
      this.prisma.campground.count({ where: { isExternal: true, isPublished: true } }),
      this.prisma.campground.count({ where: { isExternal: true, isBookable: true } }),
      this.prisma.campground.findFirst({
        where: { isExternal: true },
        orderBy: [{ importedAt: "desc" }, { dataSourceUpdatedAt: "desc" }],
        select: { importedAt: true, dataSourceUpdatedAt: true }
      }),
      this.prisma.campground.groupBy({
        by: ["dataSource"],
        where: { isExternal: true },
        _count: { _all: true }
      })
    ]);
    return {
      externalTotal: totals,
      externalPublished: published,
      externalBookable: bookable,
      lastImportedAt: freshest?.importedAt ?? null,
      lastSourceUpdatedAt: freshest?.dataSourceUpdatedAt ?? null,
      sources: sources.map((s) => ({ source: s.dataSource ?? "unknown", count: s._count._all }))
    };
  }
  async remove(id) {
    return this.prisma.campground.delete({ where: { id } });
  }
  async updateDepositRule(id, depositRule, depositPercentage, depositConfig) {
    return this.prisma.campground.update({
      where: { id },
      data: {
        depositRule,
        depositPercentage: depositPercentage ?? null,
        depositConfig: depositConfig ?? null
      }
    });
  }
  async updateBranding(id, data, organizationId) {
    await this.assertCampgroundScoped(id, organizationId);
    return this.prisma.campground.update({
      where: { id },
      data: {
        logoUrl: data.logoUrl ?? null,
        primaryColor: data.primaryColor ?? null,
        accentColor: data.accentColor ?? null,
        secondaryColor: data.secondaryColor ?? null,
        buttonColor: data.buttonColor ?? null,
        brandFont: data.brandFont ?? null,
        emailHeader: data.emailHeader ?? null,
        receiptFooter: data.receiptFooter ?? null,
        brandingNote: data.brandingNote ?? null
      }
    });
  }
  async updatePolicies(id, data, organizationId) {
    await this.assertCampgroundScoped(id, organizationId);
    return this.prisma.campground.update({
      where: { id },
      data: {
        cancellationPolicyType: data.cancellationPolicyType ?? null,
        cancellationWindowHours: data.cancellationWindowHours ?? null,
        cancellationFeeType: data.cancellationFeeType ?? null,
        cancellationFeeFlatCents: data.cancellationFeeFlatCents ?? null,
        cancellationFeePercent: data.cancellationFeePercent ?? null,
        cancellationNotes: data.cancellationNotes ?? null
      }
    });
  }
  async getMembers(id) {
    const memberships = await this.prisma.campgroundMembership.findMany({
      where: { campgroundId: id },
      include: {
        user: { select: { id: true, firstName: true, lastName: true, email: true, isActive: true } }
      },
      orderBy: { createdAt: "desc" }
    });
    const userIds = memberships.map((m) => m.userId);
    const invites = await this.prisma.inviteToken.findMany({
      where: { campgroundId: id, userId: { in: userIds } },
      orderBy: { createdAt: "desc" }
    });
    const latestInviteByUser = {};
    for (const inv of invites) {
      if (!latestInviteByUser[inv.userId]) {
        latestInviteByUser[inv.userId] = inv;
      }
    }
    return memberships.map((m) => {
      const invite = latestInviteByUser[m.userId];
      return {
        id: m.id,
        role: m.role,
        user: m.user,
        createdAt: m.createdAt,
        lastInviteSentAt: invite?.createdAt ?? null,
        lastInviteRedeemedAt: invite?.redeemedAt ?? null,
        inviteExpiresAt: invite?.expiresAt ?? null
      };
    });
  }
  async assertAnotherOwner(campgroundId, excludeMembershipId) {
    const ownerCount = await this.prisma.campgroundMembership.count({
      where: {
        campgroundId,
        role: import_client2.UserRole.owner,
        ...excludeMembershipId ? { id: { not: excludeMembershipId } } : {}
      }
    });
    if (ownerCount <= 0) {
      throw new import_common11.ConflictException("At least one owner is required");
    }
  }
  generateInviteToken() {
    return (0, import_crypto.randomBytes)(20).toString("hex");
  }
  inviteExpiresAt() {
    const d = /* @__PURE__ */ new Date();
    d.setDate(d.getDate() + 7);
    return d;
  }
  async assertCampgroundScoped(campgroundId, organizationId) {
    if (!organizationId) return;
    const found = await this.prisma.campground.findFirst({
      where: { id: campgroundId, organizationId }
    });
    if (!found) {
      throw new import_common11.ForbiddenException("Campground not found in your organization");
    }
  }
  async addMember(campgroundId, data, actorId) {
    const email = data.email.toLowerCase().trim();
    const existingUser = await this.prisma.user.findUnique({ where: { email } });
    let userId = existingUser?.id;
    if (!existingUser) {
      const passwordHash = await bcrypt2.hash(Math.random().toString(36), 12);
      const user2 = await this.prisma.user.create({
        data: {
          email,
          passwordHash,
          firstName: data.firstName || "Pending",
          lastName: data.lastName || "User",
          isActive: true
        }
      });
      userId = user2.id;
    }
    if (!userId) {
      throw new import_common11.ConflictException("Failed to create user for membership");
    }
    const ensuredUserId = userId;
    const existingMembership = await this.prisma.campgroundMembership.findUnique({
      where: {
        userId_campgroundId: {
          userId: ensuredUserId,
          campgroundId
        }
      }
    });
    if (existingMembership) {
      throw new import_common11.ConflictException("User already a member of this campground");
    }
    const membership = await this.prisma.campgroundMembership.create({
      data: { userId: ensuredUserId, campgroundId, role: data.role }
    });
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, firstName: true, lastName: true, email: true, isActive: true }
    });
    let inviteToken = null;
    if (user && (!user.isActive || existingUser == null)) {
      inviteToken = this.generateInviteToken();
      await this.prisma.inviteToken.create({
        data: {
          token: inviteToken,
          userId,
          campgroundId,
          expiresAt: this.inviteExpiresAt()
        }
      });
    }
    if (user?.email) {
      const name = [user.firstName, user.lastName].filter(Boolean).join(" ") || "there";
      const roleLabel = data.role.replace("_", " ");
      const baseUrl = process.env.FRONTEND_URL || "https://app.campreserv.com";
      const inviteUrl = inviteToken ? `${baseUrl}/invite?token=${inviteToken}` : `${baseUrl}/login`;
      this.emailService.sendEmail({
        to: user.email,
        subject: `You've been added to a campground as ${roleLabel}`,
        html: `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 540px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #0f172a; margin-bottom: 12px;">Welcome, ${name}!</h2>
            <p style="color: #475569; line-height: 1.5;">
              You've been granted <strong>${roleLabel}</strong> access to a campground in Campreserv.
            </p>
            <p style="color: #475569; line-height: 1.5;">
              Sign in with your email. ${inviteToken ? "Use the button below to set your password." : "If you don't have a password yet, use the reset link on the login page to set one."}
            </p>
            <div style="margin: 24px 0;">
              <a href="${inviteUrl}" style="display: inline-block; padding: 12px 18px; background: #0ea5e9; color: white; border-radius: 10px; text-decoration: none; font-weight: 600;">
                ${inviteToken ? "Accept invite" : "Go to app"}
              </a>
            </div>
            <div style="margin-top: 20px; padding: 16px; background: #ecfeff; border: 1px solid #cffafe; border-radius: 10px; color: #0ea5e9;">
              Tip: Save this email for your records.
            </div>
          </div>
        `
      }).catch(() => {
      });
    }
    const result = {
      id: membership.id,
      role: membership.role,
      createdAt: membership.createdAt,
      user
    };
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "member.added",
      entity: "campground_membership",
      entityId: membership.id,
      after: { role: membership.role, userId: ensuredUserId }
    });
    return result;
  }
  async resendInvite(campgroundId, membershipId, actorId) {
    const membership = await this.prisma.campgroundMembership.findFirst({
      where: { id: membershipId, campgroundId },
      include: { user: true }
    });
    if (!membership) {
      throw new import_common11.NotFoundException("Membership not found");
    }
    const latestInvite = await this.prisma.inviteToken.findFirst({
      where: { campgroundId, userId: membership.userId },
      orderBy: { createdAt: "desc" }
    });
    const now = Date.now();
    if (latestInvite && !latestInvite.redeemedAt) {
      const createdMs = new Date(latestInvite.createdAt).getTime();
      if (now - createdMs < this.INVITE_RESEND_COOLDOWN_MS) {
        const waitMs = this.INVITE_RESEND_COOLDOWN_MS - (now - createdMs);
        const waitMinutes = Math.ceil(waitMs / 6e4);
        throw new import_common11.ConflictException(`Please wait ${waitMinutes} minute(s) before resending another invite`);
      }
    }
    const token = this.generateInviteToken();
    await this.prisma.inviteToken.create({
      data: {
        token,
        userId: membership.userId,
        campgroundId,
        expiresAt: this.inviteExpiresAt()
      }
    });
    const baseUrl = process.env.FRONTEND_URL || "https://app.campreserv.com";
    const inviteUrl = `${baseUrl}/invite?token=${token}`;
    this.emailService.sendEmail({
      to: membership.user.email,
      subject: "Your Campreserv invite",
      html: `
        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 540px; margin: 0 auto; padding: 20px;">
          <h2 style="color: #0f172a; margin-bottom: 12px;">You're invited</h2>
          <p style="color: #475569; line-height: 1.5;">Use the button below to set your password and access the campground.</p>
          <div style="margin: 24px 0;">
            <a href="${inviteUrl}" style="display: inline-block; padding: 12px 18px; background: #0ea5e9; color: white; border-radius: 10px; text-decoration: none; font-weight: 600;">
              Accept invite
            </a>
          </div>
        </div>
      `
    }).catch(() => {
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "member.invite_resent",
      entity: "campground_membership",
      entityId: membershipId,
      after: { userId: membership.userId }
    });
    return { ok: true };
  }
  async updateMemberRole(campgroundId, membershipId, role, actorId) {
    const membership = await this.prisma.campgroundMembership.findFirst({
      where: { id: membershipId, campgroundId }
    });
    if (!membership) {
      throw new import_common11.NotFoundException("Membership not found");
    }
    if (actorId && membership.userId === actorId && membership.role === import_client2.UserRole.owner && role !== import_client2.UserRole.owner) {
      throw new import_common11.ConflictException("You cannot demote yourself as the last owner");
    }
    if (membership.role === import_client2.UserRole.owner && role !== import_client2.UserRole.owner) {
      await this.assertAnotherOwner(campgroundId, membershipId);
    }
    const updated = await this.prisma.campgroundMembership.update({
      where: { id: membershipId },
      data: { role }
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "member.role_changed",
      entity: "campground_membership",
      entityId: membershipId,
      before: { role: membership.role },
      after: { role }
    });
    return updated;
  }
  async removeMember(campgroundId, membershipId, actorId) {
    const membership = await this.prisma.campgroundMembership.findFirst({
      where: { id: membershipId, campgroundId }
    });
    if (!membership) {
      throw new import_common11.NotFoundException("Membership not found");
    }
    if (actorId && membership.userId === actorId && membership.role === import_client2.UserRole.owner) {
      throw new import_common11.ConflictException("You cannot remove yourself as the last owner");
    }
    if (membership.role === import_client2.UserRole.owner) {
      await this.assertAnotherOwner(campgroundId, membershipId);
    }
    const deleted = await this.prisma.campgroundMembership.delete({ where: { id: membershipId } });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "member.removed",
      entity: "campground_membership",
      entityId: membershipId,
      before: { role: membership.role, userId: membership.userId }
    });
    return deleted;
  }
};
CampgroundsService = __decorateClass([
  (0, import_common11.Injectable)()
], CampgroundsService);

// src/campgrounds/campgrounds.controller.ts
var import_common12 = require("@nestjs/common");
var import_client3 = require("@prisma/client");
var import_shared = require("@campreserv/shared");
var CampgroundsController = class {
  constructor(campgrounds) {
    this.campgrounds = campgrounds;
  }
  listPublic() {
    return this.campgrounds.listPublic();
  }
  async getPublicBySlug(slug) {
    const campground = await this.campgrounds.findBySlug(slug);
    if (!campground) throw new import_common12.NotFoundException("Campground not found");
    if (!campground.isPublished && !campground.isExternal) throw new import_common12.NotFoundException("Campground not found");
    return campground;
  }
  listAll(req) {
    const org = req.organizationId || null;
    return this.campgrounds.listAll(org || void 0);
  }
  getOne(id, req) {
    const org = req.organizationId || null;
    const cg = this.campgrounds.findOne(id, org || void 0);
    if (!cg) throw new import_common12.NotFoundException("Campground not found");
    return cg;
  }
  updateStoreHours(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateStoreHours(id, body.storeOpenHour, body.storeCloseHour, org || void 0);
  }
  updateOrderWebhook(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateOrderWebhook(id, body.orderWebhookUrl, org || void 0);
  }
  updateSla(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateSlaMinutes(id, body.slaMinutes, org || void 0);
  }
  updateOpsSettings(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateOpsSettings(id, body, org || void 0);
  }
  verifySenderDomain(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.verifySenderDomain(id, body.domain, org || void 0);
  }
  updateAnalytics(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateAnalytics(id, body, org || void 0);
  }
  updateNpsSettings(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateNpsSettings(id, body, org || void 0);
  }
  updateBranding(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updateBranding(id, body, org || void 0);
  }
  updatePhotos(id, body, req) {
    const org = req.organizationId || null;
    const actorId = req?.user?.id || null;
    return this.campgrounds.updatePhotos(id, body, org || void 0, actorId || void 0);
  }
  updatePolicies(id, body, req) {
    const org = req.organizationId || null;
    return this.campgrounds.updatePolicies(id, body, org || void 0);
  }
  listByOrganization(organizationId) {
    return this.campgrounds.listByOrganization(organizationId);
  }
  create(organizationId, body) {
    return this.campgrounds.create({ organizationId, ...body });
  }
  remove(id) {
    return this.campgrounds.remove(id);
  }
  upsertExternal(body) {
    return this.campgrounds.upsertExternalCampground(body);
  }
  ingestOsm(body) {
    return this.campgrounds.ingestFromOsm(body);
  }
  async updateDepositRule(id, body) {
    const allowed = ["none", "full", "half", "first_night", "first_night_fees", "percentage", "percentage_50"];
    const incomingRule = body.depositRule;
    const incomingPct = body.depositPercentage ?? null;
    let parsedConfig = null;
    let normalizedRule = incomingRule || "none";
    let normalizedPct = incomingPct;
    if (body.depositConfig) {
      try {
        parsedConfig = import_shared.DepositConfigSchema.parse(body.depositConfig);
      } catch (err) {
        throw new import_common12.BadRequestException("Invalid deposit config");
      }
      const summary = this.ruleSummaryFromConfig(parsedConfig.defaultRule);
      normalizedRule = incomingRule || summary.rule;
      normalizedPct = incomingPct ?? summary.percentage;
    }
    if (!allowed.includes(normalizedRule)) {
      throw new import_common12.ForbiddenException("Invalid deposit rule");
    }
    if (normalizedRule === "percentage" && (normalizedPct ?? 0) < 0) {
      throw new import_common12.BadRequestException("Deposit percentage must be provided for percentage rules");
    }
    return this.campgrounds.updateDepositRule(id, normalizedRule, normalizedPct, parsedConfig);
  }
  getMembers(id) {
    return this.campgrounds.getMembers(id);
  }
  addMember(id, body, req) {
    const actorId = req?.user?.id;
    return this.campgrounds.addMember(
      id,
      {
        email: body.email,
        firstName: body.firstName,
        lastName: body.lastName,
        role: body.role
      },
      actorId
    );
  }
  updateMember(campgroundId, membershipId, body, req) {
    const actorId = req?.user?.id;
    return this.campgrounds.updateMemberRole(campgroundId, membershipId, body.role, actorId);
  }
  removeMember(campgroundId, membershipId, req) {
    const actorId = req?.user?.id;
    return this.campgrounds.removeMember(campgroundId, membershipId, actorId);
  }
  resendInvite(campgroundId, membershipId, req) {
    const actorId = req?.user?.id;
    return this.campgrounds.resendInvite(campgroundId, membershipId, actorId);
  }
  ruleSummaryFromConfig(rule) {
    if (rule.type === "percent_total") {
      return { rule: "percentage", percentage: rule.percent ?? null };
    }
    if (rule.type === "fixed_amount") return { rule: "none", percentage: null };
    if (rule.type === "full") return { rule: "full", percentage: null };
    if (rule.type === "half") return { rule: "half", percentage: null };
    if (rule.type === "first_night") return { rule: "first_night", percentage: null };
    if (rule.type === "first_night_fees") return { rule: "first_night_fees", percentage: null };
    return { rule: "none", percentage: null };
  }
};
__decorateClass([
  (0, import_common12.Get)("public/campgrounds")
], CampgroundsController.prototype, "listPublic", 1);
__decorateClass([
  (0, import_common12.Get)("public/campgrounds/:slug"),
  __decorateParam(0, (0, import_common12.Param)("slug"))
], CampgroundsController.prototype, "getPublicBySlug", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Get)("campgrounds"),
  __decorateParam(0, (0, import_common12.Req)())
], CampgroundsController.prototype, "listAll", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Get)("campgrounds/:id"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Req)())
], CampgroundsController.prototype, "getOne", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/store-hours"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateStoreHours", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/order-webhook"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateOrderWebhook", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:id/sla"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateSla", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:id/ops"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateOpsSettings", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:id/sender-domain"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "verifySenderDomain", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/analytics"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateAnalytics", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:id/nps"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateNpsSettings", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/branding"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateBranding", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:id/photos"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updatePhotos", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/policies"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "updatePolicies", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Get)("organizations/:organizationId/campgrounds"),
  __decorateParam(0, (0, import_common12.Param)("organizationId"))
], CampgroundsController.prototype, "listByOrganization", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Post)("organizations/:organizationId/campgrounds"),
  __decorateParam(0, (0, import_common12.Param)("organizationId")),
  __decorateParam(1, (0, import_common12.Body)())
], CampgroundsController.prototype, "create", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Delete)("campgrounds/:id"),
  __decorateParam(0, (0, import_common12.Param)("id"))
], CampgroundsController.prototype, "remove", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Post)("campgrounds/external/upsert"),
  __decorateParam(0, (0, import_common12.Body)())
], CampgroundsController.prototype, "upsertExternal", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Post)("campgrounds/external/ingest/osm"),
  __decorateParam(0, (0, import_common12.Body)())
], CampgroundsController.prototype, "ingestOsm", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Patch)("campgrounds/:id/deposit"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)())
], CampgroundsController.prototype, "updateDepositRule", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard),
  (0, import_common12.Get)("campgrounds/:id/members"),
  __decorateParam(0, (0, import_common12.Param)("id"))
], CampgroundsController.prototype, "getMembers", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Post)("campgrounds/:id/members"),
  __decorateParam(0, (0, import_common12.Param)("id")),
  __decorateParam(1, (0, import_common12.Body)()),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "addMember", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Patch)("campgrounds/:campgroundId/members/:membershipId"),
  __decorateParam(0, (0, import_common12.Param)("campgroundId")),
  __decorateParam(1, (0, import_common12.Param)("membershipId")),
  __decorateParam(2, (0, import_common12.Body)()),
  __decorateParam(3, (0, import_common12.Req)())
], CampgroundsController.prototype, "updateMember", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Delete)("campgrounds/:campgroundId/members/:membershipId"),
  __decorateParam(0, (0, import_common12.Param)("campgroundId")),
  __decorateParam(1, (0, import_common12.Param)("membershipId")),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "removeMember", 1);
__decorateClass([
  (0, import_common12.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client3.UserRole.owner, import_client3.UserRole.manager),
  (0, import_common12.Post)("campgrounds/:campgroundId/members/:membershipId/resend-invite"),
  __decorateParam(0, (0, import_common12.Param)("campgroundId")),
  __decorateParam(1, (0, import_common12.Param)("membershipId")),
  __decorateParam(2, (0, import_common12.Req)())
], CampgroundsController.prototype, "resendInvite", 1);
CampgroundsController = __decorateClass([
  (0, import_common12.Controller)()
], CampgroundsController);

// src/email/email.module.ts
var import_common14 = require("@nestjs/common");

// src/email/email.service.ts
var import_common13 = require("@nestjs/common");
var import_nodemailer = __toESM(require("nodemailer"));
var import_node_fetch = __toESM(require("node-fetch"));
var EmailService = class {
  constructor() {
    this.logger = new import_common13.Logger(EmailService.name);
    this.transporter = null;
    this.postmarkToken = null;
    const host = process.env.SMTP_HOST;
    const port = process.env.SMTP_PORT ? Number(process.env.SMTP_PORT) : void 0;
    const user = process.env.SMTP_USER;
    const pass = process.env.SMTP_PASS;
    const secure = process.env.SMTP_SECURE === "true";
    this.postmarkToken = process.env.POSTMARK_SERVER_TOKEN || null;
    if (host && port && user && pass) {
      this.transporter = import_nodemailer.default.createTransport({
        host,
        port,
        secure,
        auth: { user, pass }
      });
      this.logger.log(`EmailService using SMTP: ${host}:${port} secure=${secure}`);
    } else if (!this.postmarkToken) {
      this.logger.warn("SMTP and Postmark not configured; falling back to console logging emails.");
    }
  }
  async sendEmail(options) {
    const fromEmail = process.env.SMTP_FROM || "no-reply@campreserv.com";
    const tryPostmark = async () => {
      const res = await (0, import_node_fetch.default)("https://api.postmarkapp.com/email", {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          "X-Postmark-Server-Token": this.postmarkToken
        },
        body: JSON.stringify({
          From: fromEmail,
          To: options.to,
          Subject: options.subject,
          HtmlBody: options.html
        })
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(`Postmark send failed: ${res.status} ${JSON.stringify(data)}`);
      }
      this.logger.log(`Email sent via Postmark to ${options.to} (${options.subject})`);
      return { providerMessageId: data.MessageID, provider: "postmark" };
    };
    if (this.postmarkToken) {
      try {
        return await tryPostmark();
      } catch (err) {
        this.logger.warn(`Postmark send attempt 1 failed, retrying: ${err}`);
        try {
          await new Promise((resolve) => setTimeout(resolve, 250));
          return await tryPostmark();
        } catch (err2) {
          this.logger.warn(`Postmark retry failed, falling back to SMTP/console: ${err2}`);
        }
      }
    }
    if (this.transporter) {
      await this.transporter.sendMail({
        from: fromEmail,
        to: options.to,
        subject: options.subject,
        html: options.html
      });
      this.logger.log(`Email sent via SMTP to ${options.to} (${options.subject})`);
      return { provider: "smtp" };
    }
    this.logger.log(`
================================================================================
SENDING EMAIL (LOG ONLY - configure SMTP or POSTMARK to send)
To: ${options.to}
Subject: ${options.subject}
--------------------------------------------------------------------------------
${options.html}
================================================================================
        `);
    return { provider: "log", fallback: "log_only" };
  }
  /**
   * Send a payment receipt email to the guest
   */
  async sendPaymentReceipt(options) {
    const sign = options.kind === "refund" ? -1 : 1;
    const amountDisplayCents = (options.totalCents ?? options.amountCents) * sign;
    const formattedAmount = `$${(amountDisplayCents / 100).toFixed(2)}`;
    const transactionDate = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
    const lineItems = options.lineItems ?? [];
    const hasLines = lineItems.length > 0 || options.taxCents !== void 0 || options.feeCents !== void 0;
    const totalCents = options.totalCents ?? (lineItems.length ? lineItems.reduce((sum, i) => sum + i.amountCents, 0) + (options.taxCents ?? 0) + (options.feeCents ?? 0) : options.amountCents);
    const linesTable = hasLines ? `
            <table style="width: 100%; border-collapse: collapse; margin-top: 12px;">
                <thead>
                    <tr>
                        <th style="text-align: left; padding: 6px 0; color: #64748b; border-bottom: 1px solid #e2e8f0;">Item</th>
                        <th style="text-align: right; padding: 6px 0; color: #64748b; border-bottom: 1px solid #e2e8f0;">Amount</th>
                    </tr>
                </thead>
                <tbody>
                    ${lineItems.map((li) => `
                        <tr>
                            <td style="padding: 6px 0; color: #0f172a;">${li.label}</td>
                            <td style="padding: 6px 0; color: #0f172a; text-align: right;">$${(li.amountCents * sign / 100).toFixed(2)}</td>
                        </tr>
                    `).join("")}
                    ${options.taxCents !== void 0 ? `
                        <tr>
                            <td style="padding: 6px 0; color: #0f172a;">Tax</td>
                            <td style="padding: 6px 0; color: #0f172a; text-align: right;">$${(options.taxCents * sign / 100).toFixed(2)}</td>
                        </tr>
                    ` : ""}
                    ${options.feeCents !== void 0 ? `
                        <tr>
                            <td style="padding: 6px 0; color: #0f172a;">Fees</td>
                            <td style="padding: 6px 0; color: #0f172a; text-align: right;">$${(options.feeCents * sign / 100).toFixed(2)}</td>
                        </tr>
                    ` : ""}
                    <tr>
                        <td style="padding: 8px 0; color: #0f172a; font-weight: 600; border-top: 1px solid #e2e8f0;">Total</td>
                        <td style="padding: 8px 0; color: #0f172a; text-align: right; font-weight: 600; border-top: 1px solid #e2e8f0;">$${(totalCents * sign / 100).toFixed(2)}</td>
                    </tr>
                </tbody>
            </table>
        ` : "";
    let stayDetails = "";
    if (options.siteNumber || options.arrivalDate) {
      stayDetails = `
                <div style="background: #f8fafc; border-radius: 8px; padding: 16px; margin: 20px 0;">
                    <h3 style="margin: 0 0 12px 0; color: #334155; font-size: 14px;">Stay Details</h3>
                    ${options.siteNumber ? `<p style="margin: 4px 0; color: #64748b;">Site: <strong style="color: #0f172a;">${options.siteNumber}</strong></p>` : ""}
                    ${options.arrivalDate ? `<p style="margin: 4px 0; color: #64748b;">Check-in: <strong style="color: #0f172a;">${options.arrivalDate.toLocaleDateString()}</strong></p>` : ""}
                    ${options.departureDate ? `<p style="margin: 4px 0; color: #64748b;">Check-out: <strong style="color: #0f172a;">${options.departureDate.toLocaleDateString()}</strong></p>` : ""}
                </div>
            `;
    }
    const html = `
            <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="color: ${options.kind === "refund" ? "#f59e0b" : "#10b981"}; margin: 0;">${options.kind === "refund" ? "Refund Issued" : "Payment Received"}</h1>
                    <p style="color: #64748b; margin-top: 8px;">${options.kind === "refund" ? "We have processed your refund." : "Thank you for your payment!"}</p>
                </div>
                
                <div style="background: linear-gradient(135deg, ${options.kind === "refund" ? "#fbbf24 0%, #f59e0b 100%" : "#10b981 0%, #059669 100%"}); border-radius: 12px; padding: 24px; text-align: center; margin-bottom: 24px;">
                    <p style="color: rgba(255,255,255,0.8); margin: 0 0 8px 0; font-size: 14px;">${options.kind === "refund" ? "Amount Refunded" : "Amount Paid"}</p>
                    <p style="color: white; margin: 0; font-size: 36px; font-weight: bold;">${formattedAmount}</p>
                </div>

                <div style="background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 20px;">
                    <h2 style="margin: 0 0 16px 0; color: #0f172a; font-size: 16px;">Receipt Details</h2>
                    
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td style="padding: 8px 0; color: #64748b; border-bottom: 1px solid #f1f5f9;">Campground</td>
                            <td style="padding: 8px 0; color: #0f172a; text-align: right; border-bottom: 1px solid #f1f5f9; font-weight: 500;">${options.campgroundName}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px 0; color: #64748b; border-bottom: 1px solid #f1f5f9;">Date</td>
                            <td style="padding: 8px 0; color: #0f172a; text-align: right; border-bottom: 1px solid #f1f5f9;">${transactionDate}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px 0; color: #64748b; border-bottom: 1px solid #f1f5f9;">Payment Method</td>
                            <td style="padding: 8px 0; color: #0f172a; text-align: right; border-bottom: 1px solid #f1f5f9;">${options.paymentMethod || "Card"}</td>
                        </tr>
                        ${options.transactionId ? `
                        <tr>
                            <td style="padding: 8px 0; color: #64748b; border-bottom: 1px solid #f1f5f9;">Transaction ID</td>
                            <td style="padding: 8px 0; color: #0f172a; text-align: right; border-bottom: 1px solid #f1f5f9; font-family: monospace; font-size: 12px;">${options.transactionId}</td>
                        </tr>
                        ` : ""}
                        ${options.reservationId ? `
                        <tr>
                            <td style="padding: 8px 0; color: #64748b;">Reservation ID</td>
                            <td style="padding: 8px 0; color: #0f172a; text-align: right; font-family: monospace; font-size: 12px;">${options.reservationId}</td>
                        </tr>
                        ` : ""}
                    </table>
                </div>

                ${linesTable}

                ${stayDetails}

                <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                    <p style="color: #64748b; font-size: 12px; margin: 0;">
                        This is an automated receipt. Please keep this for your records.
                    </p>
                    <p style="color: #94a3b8; font-size: 11px; margin-top: 8px;">
                        Questions? Contact ${options.campgroundName}
                    </p>
                </div>
            </div>
        `;
    await this.sendEmail({
      to: options.guestEmail,
      subject: `Payment Receipt - ${formattedAmount} - ${options.campgroundName}`,
      html
    });
  }
};
EmailService = __decorateClass([
  (0, import_common13.Injectable)()
], EmailService);

// src/email/email.module.ts
var EmailModule = class {
};
EmailModule = __decorateClass([
  (0, import_common14.Global)(),
  (0, import_common14.Module)({
    providers: [EmailService],
    exports: [EmailService]
  })
], EmailModule);

// src/audit/audit.module.ts
var import_common24 = require("@nestjs/common");

// src/audit/audit.service.ts
var import_common15 = require("@nestjs/common");
var import_crypto3 = require("crypto");
var AuditService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async list(params, ip, userAgent) {
    const privacy = await this.getPrivacy(params.campgroundId);
    const rows = await this.prisma.auditLog.findMany({
      where: {
        campgroundId: params.campgroundId,
        action: params.action || void 0,
        actorId: params.actorId || void 0,
        createdAt: params.start || params.end ? {
          ...params.start ? { gte: params.start } : {},
          ...params.end ? { lte: params.end } : {}
        } : void 0
      },
      include: {
        actor: { select: { id: true, email: true, firstName: true, lastName: true } }
      },
      orderBy: { createdAt: "desc" },
      take: params.limit || 200
    });
    if (!privacy.redactPII) return rows;
    return rows.map((row) => this.redactRow(row));
  }
  async quickAudit(params) {
    const limit = Math.min(Math.max(params.limit ?? 5, 1), 25);
    const privacy = await this.getPrivacy(params.campgroundId);
    const [piiTagCount, piiTags, auditEventsRaw] = await Promise.all([
      this.prisma.piiFieldTag.count(),
      this.prisma.piiFieldTag.findMany({
        orderBy: [{ resource: "asc" }, { field: "asc" }],
        take: 8
      }),
      this.prisma.auditLog.findMany({
        where: { campgroundId: params.campgroundId },
        include: {
          actor: { select: { id: true, email: true, firstName: true, lastName: true } }
        },
        orderBy: { createdAt: "desc" },
        take: limit
      })
    ]);
    const auditEvents = privacy.redactPII ? auditEventsRaw.map((row) => this.redactRow(row)) : auditEventsRaw;
    return {
      privacyDefaults: {
        redactPII: privacy.redactPII,
        consentRequired: privacy.consentRequired,
        backupRetentionDays: privacy.backupRetentionDays,
        keyRotationDays: privacy.keyRotationDays
      },
      piiTagCount,
      piiTagsPreview: piiTags,
      auditEvents
    };
  }
  async exportCsv(params, res) {
    const rows = await this.list(params);
    const headers = ["id", "campgroundId", "actorId", "action", "entity", "entityId", "createdAt", "ip", "userAgent", "chainHash", "prevHash", "before", "after"];
    const csv = [headers.join(",")].concat(
      rows.map(
        (r) => [
          r.id,
          r.campgroundId,
          r.actorId ?? "",
          r.action,
          r.entity,
          r.entityId,
          new Date(r.createdAt).toISOString(),
          r.ip ?? "",
          (r.userAgent ?? "").replace(/,/g, ";"),
          r.chainHash,
          r.prevHash ?? "",
          r.before ? JSON.stringify(r.before).replace(/"/g, '""') : "",
          r.after ? JSON.stringify(r.after).replace(/"/g, '""') : ""
        ].join(",")
      )
    ).join("\n");
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", "attachment; filename=audit.csv");
    return res.send(csv);
  }
  async exportJson(params) {
    return this.list(params);
  }
  async record(event) {
    const now = /* @__PURE__ */ new Date();
    const prev = await this.prisma.auditLog.findFirst({
      where: { campgroundId: event.campgroundId },
      orderBy: { createdAt: "desc" },
      select: { chainHash: true }
    });
    const prevHash = prev?.chainHash ?? null;
    const payload = {
      campgroundId: event.campgroundId,
      actorId: event.actorId,
      action: event.action,
      entity: event.entity,
      entityId: event.entityId,
      before: event.before ?? null,
      after: event.after ?? null,
      ip: event.ip ?? null,
      userAgent: event.userAgent ?? null,
      createdAt: now.toISOString(),
      prevHash
    };
    const chainHash = (0, import_crypto3.createHash)("sha256").update(JSON.stringify(payload)).digest("hex");
    const retentionAt = event.retentionDays ? new Date(now.getTime() + event.retentionDays * 24 * 60 * 60 * 1e3) : null;
    return this.prisma.auditLog.create({
      data: {
        ...payload,
        createdAt: now,
        prevHash,
        chainHash,
        retentionAt
      }
    });
  }
  async recordExport(params) {
    return this.prisma.auditExport.create({
      data: {
        campgroundId: params.campgroundId,
        requestedById: params.requestedById,
        format: params.format,
        filters: params.filters ?? null,
        recordCount: params.recordCount
      }
    });
  }
  async listExports(campgroundId) {
    return this.prisma.auditExport.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" },
      take: 50
    });
  }
  async getPrivacy(campgroundId) {
    const existing = await this.prisma.privacySetting.findUnique({ where: { campgroundId } });
    if (existing) return existing;
    return this.prisma.privacySetting.create({
      data: {
        campgroundId,
        redactPII: true,
        consentRequired: true,
        backupRetentionDays: 30,
        keyRotationDays: 90
      }
    });
  }
  redactRow(row) {
    const mask = (val) => {
      if (typeof val !== "string") return val;
      const emailMasked = val.replace(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi, "***@redacted");
      const phoneMasked = emailMasked.replace(/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "***-***-****");
      return phoneMasked;
    };
    const scrubJson = (obj) => {
      if (!obj) return obj;
      const json = JSON.stringify(obj, (_, v) => mask(v));
      try {
        return JSON.parse(json);
      } catch {
        return obj;
      }
    };
    return {
      ...row,
      actor: row.actor ? {
        ...row.actor,
        email: mask(row.actor.email),
        firstName: mask(row.actor.firstName),
        lastName: mask(row.actor.lastName)
      } : row.actor,
      before: scrubJson(row.before),
      after: scrubJson(row.after),
      ip: row.ip ? "***.***.***.***" : row.ip,
      userAgent: row.userAgent ? "redacted" : row.userAgent
    };
  }
};
AuditService = __decorateClass([
  (0, import_common15.Injectable)()
], AuditService);

// src/audit/audit.controller.ts
var import_common18 = require("@nestjs/common");
var import_client4 = require("@prisma/client");

// src/permissions/permission.guard.ts
var import_common17 = require("@nestjs/common");

// src/permissions/permission.decorator.ts
var import_common16 = require("@nestjs/common");
var PERMISSION_KEY = "requiredPermission";
var RequirePermission = (descriptor) => (0, import_common16.SetMetadata)(PERMISSION_KEY, descriptor);

// src/permissions/permission.guard.ts
var PermissionGuard = class {
  constructor(reflector, permissions) {
    this.reflector = reflector;
    this.permissions = permissions;
  }
  async canActivate(context) {
    const descriptor = this.reflector.getAllAndOverride(PERMISSION_KEY, [
      context.getHandler(),
      context.getClass()
    ]);
    if (!descriptor) return true;
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const campgroundId = request.params?.campgroundId || request.headers?.["x-campground-id"] || null;
    const result = await this.permissions.checkAccess({
      user,
      campgroundId,
      resource: descriptor.resource,
      action: descriptor.action
    });
    if (!result.allowed) {
      request.permissionDenied = result;
    }
    return result.allowed;
  }
};
PermissionGuard = __decorateClass([
  (0, import_common17.Injectable)()
], PermissionGuard);

// src/audit/audit.controller.ts
var AuditController = class {
  constructor(audit) {
    this.audit = audit;
  }
  async list(campgroundId, action, actorId, start, end, limit, format, req, res) {
    const params = {
      campgroundId,
      action: action || void 0,
      actorId: actorId || void 0,
      start: start ? new Date(start) : void 0,
      end: end ? new Date(end) : void 0,
      limit: limit ? Math.min(Number(limit) || 100, 500) : 200
    };
    if (format === "csv" && res) {
      const rows2 = await this.audit.list(params, req?.ip, req?.headers?.["user-agent"]);
      await this.audit.recordExport({
        campgroundId,
        requestedById: req?.user?.id,
        format: "csv",
        filters: params,
        recordCount: rows2.length
      });
      return this.audit.exportCsv(params, res);
    }
    const rows = await this.audit.exportJson(params);
    await this.audit.recordExport({
      campgroundId,
      requestedById: req?.user?.id,
      format: "json",
      filters: params,
      recordCount: rows.length
    });
    return rows;
  }
  quickAudit(campgroundId) {
    return this.audit.quickAudit({ campgroundId, limit: 5 });
  }
  listExports(campgroundId) {
    return this.audit.listExports(campgroundId);
  }
};
__decorateClass([
  Roles(import_client4.UserRole.owner, import_client4.UserRole.manager),
  RequirePermission({ resource: "audit", action: "read" }),
  (0, import_common18.Get)(),
  __decorateParam(0, (0, import_common18.Param)("campgroundId")),
  __decorateParam(1, (0, import_common18.Query)("action")),
  __decorateParam(2, (0, import_common18.Query)("actorId")),
  __decorateParam(3, (0, import_common18.Query)("start")),
  __decorateParam(4, (0, import_common18.Query)("end")),
  __decorateParam(5, (0, import_common18.Query)("limit")),
  __decorateParam(6, (0, import_common18.Query)("format")),
  __decorateParam(7, (0, import_common18.Req)()),
  __decorateParam(8, (0, import_common18.Res)())
], AuditController.prototype, "list", 1);
__decorateClass([
  Roles(import_client4.UserRole.owner, import_client4.UserRole.manager),
  RequirePermission({ resource: "audit", action: "read" }),
  (0, import_common18.Get)("quick"),
  __decorateParam(0, (0, import_common18.Param)("campgroundId"))
], AuditController.prototype, "quickAudit", 1);
__decorateClass([
  Roles(import_client4.UserRole.owner, import_client4.UserRole.manager),
  RequirePermission({ resource: "audit", action: "export" }),
  (0, import_common18.Get)("exports"),
  __decorateParam(0, (0, import_common18.Param)("campgroundId"))
], AuditController.prototype, "listExports", 1);
AuditController = __decorateClass([
  (0, import_common18.UseGuards)(JwtAuthGuard, RolesGuard, PermissionGuard),
  (0, import_common18.Controller)("campgrounds/:campgroundId/audit")
], AuditController);

// src/permissions/permissions.module.ts
var import_common23 = require("@nestjs/common");

// src/permissions/permissions.controller.ts
var import_common21 = require("@nestjs/common");
var import_client5 = require("@prisma/client");

// src/permissions/scope.guard.ts
var import_common20 = require("@nestjs/common");

// src/permissions/scope.decorator.ts
var import_common19 = require("@nestjs/common");
var SCOPE_KEY = "requiredScope";
var RequireScope = (descriptor) => (0, import_common19.SetMetadata)(SCOPE_KEY, descriptor);

// src/permissions/scope.guard.ts
var ScopeGuard = class {
  constructor(reflector, permissions) {
    this.reflector = reflector;
    this.permissions = permissions;
  }
  async canActivate(context) {
    const descriptor = this.reflector.getAllAndOverride(SCOPE_KEY, [
      context.getHandler(),
      context.getClass()
    ]);
    if (!descriptor) return true;
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const campgroundId = this.extractCampgroundId(request);
    const region = this.extractRegion(request);
    const isPlatform = this.permissions.isPlatformStaff(user);
    const inRegionScope = isPlatform ? true : region ? !user?.region || user.region === region : true;
    const inCampgroundScope = campgroundId ? isPlatform || Array.isArray(user?.memberships) && user.memberships.some((m) => m.campgroundId === campgroundId) : true;
    if (!user || !inRegionScope || !inCampgroundScope) {
      return false;
    }
    const result = await this.permissions.checkAccess({
      user,
      campgroundId,
      region,
      resource: descriptor.resource,
      action: descriptor.action
    });
    if (!result.allowed) {
      request.permissionDenied = result;
    }
    return result.allowed;
  }
  extractRegion(request) {
    return request.query?.region || request.body?.region || request.params?.region || request.headers?.["x-region-id"] || null;
  }
  extractCampgroundId(request) {
    return request.params?.campgroundId || request.query?.campgroundId || request.body?.campgroundId || request.headers?.["x-campground-id"] || null;
  }
};
ScopeGuard = __decorateClass([
  (0, import_common20.Injectable)()
], ScopeGuard);

// src/permissions/permissions.controller.ts
var PermissionsController = class {
  constructor(permissions) {
    this.permissions = permissions;
  }
  async whoami(req) {
    const user = req.user ?? {};
    const memberships = (user.memberships ?? []).map((m) => ({
      campgroundId: m.campgroundId,
      role: m.role,
      campground: m.campground ? { id: m.campground.id, name: m.campground.name, slug: m.campground.slug } : void 0
    })) ?? [];
    const [supportRead, supportAssign, supportAnalytics, operationsAccess] = await Promise.all([
      this.permissions.checkAccess({ user, campgroundId: null, resource: "support", action: "read" }),
      this.permissions.checkAccess({ user, campgroundId: null, resource: "support", action: "assign" }),
      this.permissions.checkAccess({ user, campgroundId: null, resource: "support", action: "analytics" }),
      this.permissions.checkAccess({ user, campgroundId: null, resource: "operations", action: "write" })
    ]);
    return {
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        region: user.region ?? null,
        platformRole: user.platformRole ?? null,
        platformRegion: user.platformRegion ?? null,
        platformActive: user.platformActive ?? true,
        ownershipRoles: user.ownershipRoles ?? [],
        memberships
      },
      allowed: {
        supportRead: supportRead.allowed,
        supportAssign: supportAssign.allowed,
        supportAnalytics: supportAnalytics.allowed,
        operationsWrite: operationsAccess.allowed
      }
    };
  }
  async getPolicies(campgroundId, region) {
    const rules = await this.permissions.listRules(campgroundId, region);
    return {
      rules
    };
  }
  async upsertRule(body) {
    return this.permissions.upsertRule({
      campgroundId: body.campgroundId ?? null,
      role: body.role,
      resource: body.resource,
      action: body.action,
      fields: body.fields ?? [],
      regions: body.regions ?? [],
      effect: body.effect ?? "allow",
      createdById: body.createdById ?? null
    });
  }
  async deleteRule(campgroundId, role, resource, action) {
    return this.permissions.deleteRule({
      campgroundId: campgroundId ?? null,
      role,
      resource,
      action
    });
  }
  async submitApproval(body) {
    return this.permissions.requestApproval({
      action: body.action,
      campgroundId: body.campgroundId ?? null,
      requestedBy: body.requestedBy
    });
  }
  async decide(id, body) {
    return this.permissions.decideApproval(id, body.actorId, body.approve);
  }
  async listApprovals(campgroundId) {
    return this.permissions.listApprovals(campgroundId ?? null);
  }
};
__decorateClass([
  (0, import_common21.UseGuards)(JwtAuthGuard),
  (0, import_common21.Get)("whoami"),
  __decorateParam(0, (0, import_common21.Req)())
], PermissionsController.prototype, "whoami", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  RequireScope({ resource: "permissions", action: "read" }),
  (0, import_common21.Get)("policies"),
  __decorateParam(0, (0, import_common21.Query)("campgroundId")),
  __decorateParam(1, (0, import_common21.Query)("region"))
], PermissionsController.prototype, "getPolicies", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  RequireScope({ resource: "permissions", action: "write" }),
  (0, import_common21.Post)("rules"),
  __decorateParam(0, (0, import_common21.Body)())
], PermissionsController.prototype, "upsertRule", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  RequireScope({ resource: "permissions", action: "write" }),
  (0, import_common21.Delete)("rules"),
  __decorateParam(0, (0, import_common21.Query)("campgroundId")),
  __decorateParam(1, (0, import_common21.Query)("role")),
  __decorateParam(2, (0, import_common21.Query)("resource")),
  __decorateParam(3, (0, import_common21.Query)("action"))
], PermissionsController.prototype, "deleteRule", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  (0, import_common21.Post)("approvals"),
  __decorateParam(0, (0, import_common21.Body)())
], PermissionsController.prototype, "submitApproval", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  (0, import_common21.Post)("approvals/:id/decision"),
  __decorateParam(0, (0, import_common21.Param)("id")),
  __decorateParam(1, (0, import_common21.Body)())
], PermissionsController.prototype, "decide", 1);
__decorateClass([
  Roles(import_client5.UserRole.owner, import_client5.UserRole.manager),
  (0, import_common21.Get)("approvals"),
  __decorateParam(0, (0, import_common21.Query)("campgroundId"))
], PermissionsController.prototype, "listApprovals", 1);
PermissionsController = __decorateClass([
  (0, import_common21.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  (0, import_common21.Controller)("permissions")
], PermissionsController);

// src/permissions/permissions.service.ts
var import_common22 = require("@nestjs/common");
var import_client6 = require("@prisma/client");
var PLATFORM_RULES = {
  support_agent: [
    { resource: "support", action: "read" },
    { resource: "support", action: "write" }
  ],
  support_lead: [
    { resource: "support", action: "read" },
    { resource: "support", action: "write" },
    { resource: "support", action: "assign" },
    { resource: "support", action: "analytics" }
  ],
  regional_support: [
    { resource: "support", action: "read" },
    { resource: "support", action: "write" },
    { resource: "support", action: "assign" }
  ],
  ops_engineer: [
    { resource: "operations", action: "read" },
    { resource: "operations", action: "write" }
  ],
  platform_admin: [
    { resource: "*", action: "*" }
  ]
};
var PermissionsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  isPlatformStaff(user) {
    return !!this.getPlatformRole(user) && this.isPlatformActive(user);
  }
  getPlatformRole(user) {
    const role = user?.platformRole;
    return role ?? null;
  }
  isPlatformActive(user) {
    if (!user) return false;
    if (user.platformActive === false) return false;
    return true;
  }
  inPlatformRegion(user, region) {
    if (!region) return true;
    const platformRegion = user?.platformRegion;
    const userRegion = user?.region;
    if (platformRegion) return platformRegion === region;
    if (userRegion) return userRegion === region;
    return true;
  }
  getRole(user, campgroundId) {
    if (!user) return null;
    if (user.role) return user.role;
    if (Array.isArray(user.ownershipRoles) && user.ownershipRoles.includes("owner")) return import_client6.UserRole.owner;
    const membership = campgroundId ? user.memberships?.find((m) => m.campgroundId === campgroundId) : null;
    if (membership?.role) return membership.role;
    if (Array.isArray(user.memberships) && user.memberships.length > 0) {
      const roles = user.memberships.map((m) => m.role).filter(Boolean);
      if (roles.length > 0) {
        return this.prioritizeRole(roles);
      }
    }
    return null;
  }
  prioritizeRole(roles) {
    const order = [
      import_client6.UserRole.owner,
      import_client6.UserRole.manager,
      import_client6.UserRole.finance,
      import_client6.UserRole.front_desk,
      import_client6.UserRole.maintenance,
      import_client6.UserRole.marketing,
      import_client6.UserRole.readonly
    ];
    return order.find((r) => roles.includes(r)) ?? roles[0];
  }
  splitRegionsFromFields(fields = []) {
    const regions = [];
    const cleanFields = [];
    for (const f of fields) {
      if (typeof f === "string" && f.startsWith("__region:")) {
        regions.push(f.replace("__region:", ""));
      } else {
        cleanFields.push(f);
      }
    }
    return { regions, cleanFields };
  }
  buildFieldsWithRegions(fields = [], regions = []) {
    const deduped = new Set(fields.filter(Boolean));
    for (const r of regions.filter(Boolean)) {
      deduped.add(`__region:${r}`);
    }
    return Array.from(deduped);
  }
  async listRules(campgroundId, region) {
    const rules = await this.prisma.permissionRule.findMany({
      where: {
        AND: [
          campgroundId ? { campgroundId } : {},
          region ? { OR: [{ campground: { region } }, { campgroundId: null }] } : {}
        ]
      },
      orderBy: [{ campgroundId: "asc" }, { role: "asc" }, { resource: "asc" }, { action: "asc" }]
    });
    return rules.map((r) => {
      const { regions, cleanFields } = this.splitRegionsFromFields(r.fields ?? []);
      return { ...r, fields: cleanFields, regions };
    });
  }
  async upsertRule(params) {
    const fields = this.buildFieldsWithRegions(params.fields ?? [], params.regions ?? []);
    return this.prisma.permissionRule.upsert({
      where: {
        campgroundId_role_resource_action: {
          campgroundId: params.campgroundId ?? null,
          role: params.role,
          resource: params.resource,
          action: params.action
        }
      },
      create: {
        campgroundId: params.campgroundId ?? null,
        role: params.role,
        resource: params.resource,
        action: params.action,
        fields,
        effect: params.effect ?? import_client6.PermissionEffect.allow,
        createdById: params.createdById ?? null
      },
      update: {
        fields,
        effect: params.effect ?? import_client6.PermissionEffect.allow
      }
    });
  }
  async deleteRule(params) {
    return this.prisma.permissionRule.delete({
      where: {
        campgroundId_role_resource_action: {
          campgroundId: params.campgroundId ?? null,
          role: params.role,
          resource: params.resource,
          action: params.action
        }
      }
    });
  }
  isRegionScoped(user, region) {
    if (!region) return true;
    if (!user?.region) return true;
    return user.region === region;
  }
  isCampgroundScoped(user, campgroundId) {
    if (!campgroundId) return true;
    const memberships = user?.memberships ?? [];
    return memberships.some((m) => m.campgroundId === campgroundId);
  }
  async checkAccess(input) {
    const platformRole = this.getPlatformRole(input.user);
    if (platformRole && this.isPlatformActive(input.user)) {
      const platformResult = this.checkPlatformRules({
        user: input.user,
        role: platformRole,
        resource: input.resource,
        action: input.action,
        region: input.region
      });
      if (platformResult.allowed) {
        return platformResult;
      }
    }
    if (input.resource === "support") {
      return { allowed: false };
    }
    const role = this.getRole(input.user, input.campgroundId);
    if (!role) return { allowed: false };
    if (!this.isRegionScoped(input.user, input.region)) return { allowed: false };
    if (!this.isCampgroundScoped(input.user, input.campgroundId) && role !== import_client6.UserRole.owner && role !== import_client6.UserRole.manager) {
      return { allowed: false };
    }
    if (role === import_client6.UserRole.owner || role === import_client6.UserRole.manager) return { allowed: true };
    const rules = await this.prisma.permissionRule.findMany({
      where: {
        role,
        resource: input.resource,
        action: input.action,
        OR: [
          { campgroundId: input.campgroundId ?? null },
          { campgroundId: null }
        ]
      }
    });
    if (!rules.length) return { allowed: false };
    const scopedFirst = [...rules].sort((a, b) => {
      const aScoped = a.campgroundId ? 1 : 0;
      const bScoped = b.campgroundId ? 1 : 0;
      return bScoped - aScoped;
    });
    for (const rule of scopedFirst) {
      const { regions, cleanFields } = this.splitRegionsFromFields(rule.fields ?? []);
      if (regions.length && input.region && !regions.includes(input.region)) {
        continue;
      }
      const fieldTargeted = cleanFields.length > 0;
      const fieldMatch = !input.field || !fieldTargeted || cleanFields.includes(input.field);
      if (!fieldMatch) continue;
      if (rule.effect === import_client6.PermissionEffect.deny) {
        return { allowed: false, deniedFields: cleanFields.length ? cleanFields : void 0 };
      }
      return { allowed: true };
    }
    return { allowed: false };
  }
  checkPlatformRules(args) {
    if (!this.inPlatformRegion(args.user, args.region)) return { allowed: false };
    if (args.role === "platform_admin") return { allowed: true };
    const rules = PLATFORM_RULES[args.role] ?? [];
    const match = rules.some((r) => {
      const resourceMatch = r.resource === "*" || r.resource === args.resource;
      const actionMatch = r.action === "*" || r.action === args.action;
      return resourceMatch && actionMatch;
    });
    return { allowed: match };
  }
  async requestApproval(params) {
    const autoApprove = import_client6.ApprovalStatus.approved;
    return this.prisma.approvalRequest.create({
      data: {
        campgroundId: params.campgroundId ?? null,
        action: params.action,
        requestedBy: params.requestedBy,
        status: autoApprove,
        decidedBy: params.requestedBy,
        decidedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async decideApproval(id, actorId, approve) {
    const req = await this.prisma.approvalRequest.findUnique({ where: { id } });
    if (!req) throw new import_common22.ForbiddenException("Approval request not found");
    if (req.status !== import_client6.ApprovalStatus.pending) return req;
    return this.prisma.approvalRequest.update({
      where: { id },
      data: {
        status: approve ? import_client6.ApprovalStatus.approved : import_client6.ApprovalStatus.rejected,
        decidedBy: actorId,
        decidedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async listApprovals(campgroundId) {
    return this.prisma.approvalRequest.findMany({
      where: { campgroundId: campgroundId ?? void 0 },
      orderBy: { createdAt: "desc" },
      take: 200
    });
  }
};
PermissionsService = __decorateClass([
  (0, import_common22.Injectable)()
], PermissionsService);

// src/permissions/permissions.module.ts
var import_core = require("@nestjs/core");
var PermissionsModule = class {
};
PermissionsModule = __decorateClass([
  (0, import_common23.Module)({
    controllers: [PermissionsController],
    providers: [PrismaService, PermissionsService, PermissionGuard, ScopeGuard, import_core.Reflector],
    exports: [PermissionsService, PermissionGuard, ScopeGuard]
  })
], PermissionsModule);

// src/audit/audit.module.ts
var AuditModule = class {
};
AuditModule = __decorateClass([
  (0, import_common24.Module)({
    imports: [PermissionsModule],
    providers: [AuditService, PrismaService],
    controllers: [AuditController],
    exports: [AuditService]
  })
], AuditModule);

// src/campgrounds/campgrounds.scheduler.ts
var import_common25 = require("@nestjs/common");
var import_schedule = require("@nestjs/schedule");
var CampgroundsIngestScheduler = class {
  constructor(campgrounds) {
    this.campgrounds = campgrounds;
    this.logger = new import_common25.Logger(CampgroundsIngestScheduler.name);
  }
  async handleOsmIngest() {
    if (process.env.OSM_INGEST_CRON_ENABLED !== "true") return;
    const limit = process.env.OSM_INGEST_LIMIT ? Number(process.env.OSM_INGEST_LIMIT) : void 0;
    const bbox = process.env.OSM_INGEST_BBOX;
    try {
      const { upserted, processed } = await this.campgrounds.ingestFromOsm({
        bbox,
        limit
      });
      this.logger.log(`OSM ingest completed: processed=${processed}, upserted=${upserted}`);
    } catch (err) {
      this.logger.error(`OSM ingest failed: ${err?.message || err}`);
    }
  }
};
__decorateClass([
  (0, import_schedule.Cron)(import_schedule.CronExpression.EVERY_DAY_AT_2AM, { name: "osm-ingest" })
], CampgroundsIngestScheduler.prototype, "handleOsmIngest", 1);
CampgroundsIngestScheduler = __decorateClass([
  (0, import_common25.Injectable)()
], CampgroundsIngestScheduler);

// src/campgrounds/campground-assets.service.ts
var import_common26 = require("@nestjs/common");
var CampgroundAssetsService = class {
  constructor() {
    this.logger = new import_common26.Logger(CampgroundAssetsService.name);
  }
  async mirrorPhotos(urls) {
    if (!urls || urls.length === 0) return { photos: [], meta: [] };
    const bucket = process.env.PHOTO_MIRROR_S3_BUCKET;
    if (!bucket) {
      return { photos: urls, meta: urls.map((url) => ({ url, mirrored: false, reason: "s3_not_configured" })) };
    }
    this.logger.warn("PHOTO_MIRROR_S3_BUCKET is set, but mirroring is not yet implemented; returning originals.");
    return {
      photos: urls,
      meta: urls.map((url) => ({ url, mirrored: false, reason: "stub_not_implemented" }))
    };
  }
};
CampgroundAssetsService = __decorateClass([
  (0, import_common26.Injectable)()
], CampgroundAssetsService);

// src/campgrounds/campground-review-connectors.service.ts
var import_common27 = require("@nestjs/common");
var CampgroundReviewConnectors = class {
  constructor() {
    this.logger = new import_common27.Logger(CampgroundReviewConnectors.name);
  }
  async fetchWithTimeout(url, timeoutMs = 8e3) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { signal: controller.signal });
    } finally {
      clearTimeout(id);
    }
  }
  async fetchGoogleReviews(placeId) {
    const apiKey = process.env.GOOGLE_PLACES_API_KEY;
    if (!apiKey || !placeId) return null;
    const fields = [
      "rating",
      "user_ratings_total",
      "reviews",
      "url"
    ].join(",");
    const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${encodeURIComponent(
      placeId
    )}&fields=${fields}&reviews_sort=newest&language=en&key=${apiKey}`;
    try {
      const res = await this.fetchWithTimeout(url);
      if (!res.ok) {
        this.logger.warn(`Google Places fetch failed status=${res.status}`);
        return { source: "google_places", rating: null, count: null, reviews: [] };
      }
      const json = await res.json();
      if (json?.status && json.status !== "OK") {
        this.logger.warn(`Google Places response status=${json.status}`);
      }
      const result = json?.result ?? {};
      const rating = result.rating ?? null;
      const count = result.user_ratings_total ?? null;
      const reviews = Array.isArray(result.reviews) ? result.reviews.slice(0, 10).map((r) => ({
        author: r.author_name,
        rating: r.rating,
        text: r.text,
        time: r.time,
        relativeTime: r.relative_time_description,
        profilePhotoUrl: r.profile_photo_url
      })) : [];
      return { source: "google_places", rating, count, reviews };
    } catch (err) {
      this.logger.error(`Google Places fetch error: ${err?.message || err}`);
      return { source: "google_places", rating: null, count: null, reviews: [] };
    }
  }
  async fetchRvLifeReviews(parkId) {
    if (!parkId) return null;
    this.logger.warn(`RV Life connector stubbed; no fetch performed for parkId=${parkId}`);
    return { source: "rv_life", rating: null, count: null, reviews: [] };
  }
  async collectExternalReviews(opts) {
    const results = [];
    const google = await this.fetchGoogleReviews(opts.googlePlaceId);
    if (google) results.push(google);
    const rvLife = await this.fetchRvLifeReviews(opts.rvLifeId);
    if (rvLife) results.push(rvLife);
    return results;
  }
};
CampgroundReviewConnectors = __decorateClass([
  (0, import_common27.Injectable)()
], CampgroundReviewConnectors);

// src/campgrounds/campgrounds.module.ts
var CampgroundsModule = class {
};
CampgroundsModule = __decorateClass([
  (0, import_common28.Module)({
    imports: [EmailModule, AuditModule],
    controllers: [CampgroundsController],
    providers: [
      CampgroundsService,
      PrismaService,
      CampgroundsIngestScheduler,
      CampgroundAssetsService,
      CampgroundReviewConnectors
    ],
    exports: [CampgroundsService]
  })
], CampgroundsModule);

// src/sites/sites.module.ts
var import_common31 = require("@nestjs/common");

// src/sites/sites.service.ts
var import_common29 = require("@nestjs/common");
var SitesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  findOne(id) {
    return this.prisma.site.findUnique({
      where: { id },
      include: {
        siteClass: true,
        campground: true
      }
    });
  }
  listByCampground(campgroundId) {
    return this.prisma.site.findMany({
      where: { campgroundId },
      include: { siteClass: true }
    });
  }
  create(data) {
    return this.prisma.site.create({ data: { ...data, siteType: data.siteType } });
  }
  update(id, data) {
    const { campgroundId, siteType, ...rest } = data;
    return this.prisma.site.update({
      where: { id },
      data: {
        ...rest,
        ...siteType ? { siteType } : {},
        ...rest.siteClassId === null ? { siteClassId: null } : {}
      }
    });
  }
  remove(id) {
    return this.prisma.site.delete({ where: { id } });
  }
};
SitesService = __decorateClass([
  (0, import_common29.Injectable)()
], SitesService);

// src/sites/sites.controller.ts
var import_common30 = require("@nestjs/common");
var SitesController = class {
  constructor(sites) {
    this.sites = sites;
  }
  list(campgroundId) {
    return this.sites.listByCampground(campgroundId);
  }
  getById(id) {
    return this.sites.findOne(id);
  }
  create(campgroundId, body) {
    return this.sites.create({ campgroundId, ...body });
  }
  update(id, body) {
    return this.sites.update(id, body);
  }
  remove(id) {
    return this.sites.remove(id);
  }
};
__decorateClass([
  (0, import_common30.Get)("campgrounds/:campgroundId/sites"),
  __decorateParam(0, (0, import_common30.Param)("campgroundId"))
], SitesController.prototype, "list", 1);
__decorateClass([
  (0, import_common30.Get)("sites/:id"),
  __decorateParam(0, (0, import_common30.Param)("id"))
], SitesController.prototype, "getById", 1);
__decorateClass([
  (0, import_common30.Post)("campgrounds/:campgroundId/sites"),
  __decorateParam(0, (0, import_common30.Param)("campgroundId")),
  __decorateParam(1, (0, import_common30.Body)())
], SitesController.prototype, "create", 1);
__decorateClass([
  (0, import_common30.Patch)("sites/:id"),
  __decorateParam(0, (0, import_common30.Param)("id")),
  __decorateParam(1, (0, import_common30.Body)())
], SitesController.prototype, "update", 1);
__decorateClass([
  (0, import_common30.Delete)("sites/:id"),
  __decorateParam(0, (0, import_common30.Param)("id"))
], SitesController.prototype, "remove", 1);
SitesController = __decorateClass([
  (0, import_common30.UseGuards)(JwtAuthGuard),
  (0, import_common30.Controller)()
], SitesController);

// src/sites/sites.module.ts
var SitesModule = class {
};
SitesModule = __decorateClass([
  (0, import_common31.Module)({
    controllers: [SitesController],
    providers: [SitesService, PrismaService],
    exports: [SitesService]
  })
], SitesModule);

// src/guests/guests.module.ts
var import_common34 = require("@nestjs/common");

// src/guests/guests.service.ts
var import_common32 = require("@nestjs/common");
var GuestsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  findOne(id) {
    return this.prisma.guest.findUnique({
      where: { id },
      include: {
        loyaltyProfile: true,
        reservations: {
          orderBy: { arrivalDate: "desc" },
          include: {
            site: { include: { siteClass: true } }
          }
        }
      }
    });
  }
  findAll() {
    return this.prisma.guest.findMany({
      orderBy: { primaryLastName: "asc" },
      include: {
        loyaltyProfile: true,
        reservations: {
          orderBy: { departureDate: "desc" },
          take: 1,
          select: {
            departureDate: true,
            site: {
              select: { id: true, name: true, siteNumber: true, siteClassId: true }
            }
          }
        }
      }
    });
  }
  async create(data) {
    const { rigLength, repeatStays, ...rest } = data;
    const emailNormalized = rest.email ? rest.email.trim().toLowerCase() : null;
    const phoneNormalized = rest.phone ? rest.phone.replace(/\D/g, "").slice(-10) : null;
    const existing = await this.prisma.guest.findFirst({
      where: {
        OR: [
          ...emailNormalized ? [{ emailNormalized }] : [],
          ...phoneNormalized ? [{ phoneNormalized }] : []
        ]
      }
    });
    if (existing) return existing;
    return this.prisma.guest.create({
      data: {
        ...rest,
        emailNormalized,
        phoneNormalized,
        rigLength: rigLength !== void 0 ? Number(rigLength) : null,
        repeatStays: repeatStays !== void 0 ? Number(repeatStays) : void 0
      }
    });
  }
  update(id, data) {
    const { rigLength, repeatStays, ...rest } = data;
    const emailNormalized = rest.email ? rest.email.trim().toLowerCase() : void 0;
    const phoneNormalized = rest.phone ? rest.phone.replace(/\D/g, "").slice(-10) : void 0;
    return this.prisma.guest.update({
      where: { id },
      data: {
        ...rest,
        ...emailNormalized !== void 0 ? { emailNormalized } : {},
        ...phoneNormalized !== void 0 ? { phoneNormalized } : {},
        ...rigLength !== void 0 ? { rigLength: rigLength === null ? null : Number(rigLength) } : {},
        ...repeatStays !== void 0 ? { repeatStays: repeatStays === null ? null : Number(repeatStays) } : {}
      }
    });
  }
  remove(id) {
    return this.prisma.guest.delete({ where: { id } });
  }
};
GuestsService = __decorateClass([
  (0, import_common32.Injectable)()
], GuestsService);

// src/guests/guests.controller.ts
var import_common33 = require("@nestjs/common");
var GuestsController = class {
  constructor(guests) {
    this.guests = guests;
  }
  findAll() {
    return this.guests.findAll();
  }
  findOne(id) {
    return this.guests.findOne(id);
  }
  create(body) {
    return this.guests.create(body);
  }
  update(id, body) {
    return this.guests.update(id, body);
  }
  remove(id) {
    return this.guests.remove(id);
  }
};
__decorateClass([
  (0, import_common33.Get)()
], GuestsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common33.Get)(":id"),
  __decorateParam(0, (0, import_common33.Param)("id"))
], GuestsController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common33.Post)(),
  __decorateParam(0, (0, import_common33.Body)())
], GuestsController.prototype, "create", 1);
__decorateClass([
  (0, import_common33.Patch)(":id"),
  __decorateParam(0, (0, import_common33.Param)("id")),
  __decorateParam(1, (0, import_common33.Body)())
], GuestsController.prototype, "update", 1);
__decorateClass([
  (0, import_common33.Delete)(":id"),
  __decorateParam(0, (0, import_common33.Param)("id"))
], GuestsController.prototype, "remove", 1);
GuestsController = __decorateClass([
  (0, import_common33.UseGuards)(JwtAuthGuard),
  (0, import_common33.Controller)("guests")
], GuestsController);

// src/guests/guests.module.ts
var GuestsModule = class {
};
GuestsModule = __decorateClass([
  (0, import_common34.Module)({
    controllers: [GuestsController],
    providers: [GuestsService, PrismaService],
    exports: [GuestsService]
  })
], GuestsModule);

// src/reservations/reservations.module.ts
var import_common86 = require("@nestjs/common");

// src/reservations/reservations.service.ts
var import_common35 = require("@nestjs/common");
var import_client7 = require("@prisma/client");

// src/ledger/ledger-posting.util.ts
var DEFAULT_GL = "UNASSIGNED";
async function assertPeriodsOpen(prisma, entries) {
  const byCampground = {};
  for (const entry of entries) {
    const occurredAt = entry.occurredAt ?? /* @__PURE__ */ new Date();
    const existing = byCampground[entry.campgroundId];
    if (!existing) {
      byCampground[entry.campgroundId] = { min: occurredAt, max: occurredAt };
    } else {
      if (occurredAt < existing.min) existing.min = occurredAt;
      if (occurredAt > existing.max) existing.max = occurredAt;
    }
  }
  for (const [campgroundId, range] of Object.entries(byCampground)) {
    const blocked = await prisma.glPeriod?.findFirst?.({
      where: {
        campgroundId,
        status: { in: ["closed", "locked"] },
        startDate: { lte: range.max },
        endDate: { gte: range.min }
      },
      select: { id: true, status: true, startDate: true, endDate: true }
    });
    if (blocked) {
      const rangeLabel = `${blocked.startDate?.toISOString?.() ?? "start"} \u2192 ${blocked.endDate?.toISOString?.() ?? "end"}`;
      throw new Error(`Ledger period is ${blocked.status} for campground ${campgroundId} (${rangeLabel}); posting blocked.`);
    }
  }
}
function normalizeEntries(entries, opts) {
  const requireGlCode = opts?.requireGlCode !== false;
  const defaultGl = opts?.defaultGlCode ?? DEFAULT_GL;
  return entries.map((entry, idx) => {
    const occurredAt = entry.occurredAt ?? /* @__PURE__ */ new Date();
    const glCode = (entry.glCode ?? defaultGl).trim();
    if (requireGlCode && !glCode) {
      throw new Error("GL code is required for all ledger entries");
    }
    const dedupeKey = entry.dedupeKey ?? (entry.externalRef ? `${entry.externalRef}:${entry.direction}:${entry.amountCents}` : null) ?? (opts?.batchDedupeKey ? `${opts.batchDedupeKey}:${idx}` : null);
    return {
      campgroundId: entry.campgroundId,
      reservationId: entry.reservationId ?? null,
      glCode,
      account: entry.account ?? null,
      description: entry.description ?? null,
      amountCents: entry.amountCents,
      direction: entry.direction,
      occurredAt,
      externalRef: entry.externalRef ?? null,
      dedupeKey
    };
  });
}
async function postBalancedLedgerEntries(prisma, entries, opts) {
  if (!entries.length) {
    throw new Error("No ledger entries to post");
  }
  const normalized = normalizeEntries(entries, opts);
  if (!opts?.allowUnbalanced) {
    const net = normalized.reduce(
      (sum, e) => sum + (e.direction === "credit" ? e.amountCents : -e.amountCents),
      0
    );
    if (net !== 0) {
      throw new Error(`Ledger batch must balance; net=${net}\xA2`);
    }
  }
  await assertPeriodsOpen(prisma, normalized);
  const dedupeKeys = normalized.map((e) => e.dedupeKey).filter(Boolean);
  const externalRefs = normalized.map((e) => e.externalRef).filter(Boolean);
  const dedupeWhere = [];
  if (dedupeKeys.length) dedupeWhere.push({ dedupeKey: { in: dedupeKeys } });
  if (externalRefs.length) dedupeWhere.push({ externalRef: { in: externalRefs } });
  if (dedupeWhere.length) {
    const existing = await prisma.ledgerEntry.findMany({
      where: { OR: dedupeWhere }
    });
    if (existing.length) {
      return existing;
    }
  }
  return prisma.$transaction(
    normalized.map(
      (entry) => prisma.ledgerEntry.create({
        data: entry
      })
    )
  );
}

// src/reservations/reservations.service.ts
var import_schedule2 = require("@nestjs/schedule");
var ReservationsService = class {
  constructor(prisma, pricingService, locks, promotionsService, emailService, waitlistService, loyaltyService, seasonalRatesService, taxRulesService, matchScoreService, gamification, pricingV2Service, depositPoliciesService, accessControl, signaturesService, audit, approvals) {
    this.prisma = prisma;
    this.pricingService = pricingService;
    this.locks = locks;
    this.promotionsService = promotionsService;
    this.emailService = emailService;
    this.waitlistService = waitlistService;
    this.loyaltyService = loyaltyService;
    this.seasonalRatesService = seasonalRatesService;
    this.taxRulesService = taxRulesService;
    this.matchScoreService = matchScoreService;
    this.gamification = gamification;
    this.pricingV2Service = pricingV2Service;
    this.depositPoliciesService = depositPoliciesService;
    this.accessControl = accessControl;
    this.signaturesService = signaturesService;
    this.audit = audit;
    this.approvals = approvals;
  }
  async getMatchedSites(campgroundId, guestId) {
    const guest = await this.prisma.guest.findUnique({
      where: { id: guestId },
      include: { reservations: { include: { site: true } } }
    });
    if (!guest) throw new import_common35.NotFoundException("Guest not found");
    const sites = await this.prisma.site.findMany({
      where: { campgroundId, isActive: true },
      include: { siteClass: true }
    });
    const matches = sites.map((site) => {
      const { score, reasons } = this.matchScoreService.calculateMatchScore(guest, site);
      return {
        site,
        score,
        reasons
      };
    });
    return matches.sort((a, b) => b.score - a.score);
  }
  computeNights(arrival, departure) {
    const ms = departure.getTime() - arrival.getTime();
    if (!Number.isFinite(ms) || ms <= 0) return 1;
    return Math.max(1, Math.round(ms / (1e3 * 60 * 60 * 24)));
  }
  computeDepositRequired(rule, totalCents, nights, depositPercentage) {
    const normalized = (rule || "none").toLowerCase();
    if (normalized === "full") return totalCents;
    if (normalized === "half" || normalized === "percentage_50") return Math.ceil(totalCents / 2);
    if (normalized === "first_night" || normalized === "first_night_fees") return Math.ceil(totalCents / nights);
    if (normalized === "percentage") {
      const pct = depositPercentage ?? 0;
      if (pct <= 0) return 0;
      return Math.ceil(totalCents * (pct / 100));
    }
    return 0;
  }
  async attachWaiverArtifacts(reservationId, guestId, evidence) {
    const ops = [];
    if (evidence.request && (!evidence.request.reservationId || !evidence.request.guestId)) {
      ops.push(
        this.prisma.signatureRequest?.update?.({
          where: { id: evidence.request.id },
          data: {
            reservationId: evidence.request.reservationId ?? reservationId,
            guestId: evidence.request.guestId ?? guestId
          }
        })
      );
    }
    if (evidence.artifact && (!evidence.artifact.reservationId || !evidence.artifact.guestId)) {
      ops.push(
        this.prisma.signatureArtifact?.update?.({
          where: { id: evidence.artifact.id },
          data: {
            reservationId: evidence.artifact.reservationId ?? reservationId,
            guestId: evidence.artifact.guestId ?? guestId
          }
        })
      );
    }
    if (evidence.digital && (!evidence.digital.reservationId || !evidence.digital.guestId)) {
      ops.push(
        this.prisma.digitalWaiver?.update?.({
          where: { id: evidence.digital.id },
          data: {
            reservationId: evidence.digital.reservationId ?? reservationId,
            guestId: evidence.digital.guestId ?? guestId
          }
        })
      );
    }
    if (ops.length) {
      try {
        await Promise.all(ops);
      } catch (err) {
        console.warn("Failed to attach waiver artifacts to reservation", err);
      }
    }
  }
  async hasSignedWaiver(reservationId, guestId) {
    const [signedRequest, digitalWaiver] = await Promise.all([
      this.prisma.signatureRequest.findFirst?.({
        where: {
          documentType: "waiver",
          status: "signed",
          OR: [{ reservationId }, { reservationId: null, guestId }]
        },
        include: { artifact: true },
        orderBy: { signedAt: "desc" }
      }),
      this.prisma.digitalWaiver.findFirst?.({
        where: {
          OR: [{ reservationId }, { reservationId: null, guestId }],
          status: "signed"
        },
        orderBy: { signedAt: "desc" }
      })
    ]);
    const signedArtifact = signedRequest?.artifact ?? await this.prisma.signatureArtifact?.findFirst?.({
      where: {
        pdfUrl: { not: null },
        OR: [{ reservationId }, { reservationId: null, guestId }]
      }
    });
    const hasEvidence = Boolean(signedRequest || signedArtifact || digitalWaiver);
    if (hasEvidence) {
      await this.attachWaiverArtifacts(reservationId, guestId, {
        request: signedRequest ?? void 0,
        artifact: signedArtifact ?? void 0,
        digital: digitalWaiver ?? void 0
      });
    }
    return hasEvidence;
  }
  async attachIdVerification(reservationId, guestId, match) {
    if (!match || match.reservationId && match.guestId) return;
    try {
      await this.prisma.idVerification?.update?.({
        where: { id: match.id },
        data: {
          reservationId: match.reservationId ?? reservationId,
          guestId: match.guestId ?? guestId
        }
      });
    } catch (err) {
      console.warn("Failed to attach ID verification to reservation", err);
    }
  }
  async hasVerifiedId(reservationId, guestId) {
    const now = /* @__PURE__ */ new Date();
    const match = await this.prisma.idVerification.findFirst?.({
      where: {
        status: "verified",
        OR: [
          { reservationId },
          {
            guestId,
            OR: [{ expiresAt: null }, { expiresAt: { gt: now } }]
          }
        ]
      },
      orderBy: { verifiedAt: "desc" }
    });
    if (match) {
      await this.attachIdVerification(reservationId, guestId, match);
      return true;
    }
    return false;
  }
  async checkCompliance(reservation) {
    const reasons = [];
    let signingUrl;
    if (reservation.paymentRequired && reservation.paymentStatus !== "paid") {
      reasons.push("payment_required");
    }
    if (reservation.idVerificationRequired) {
      const verified = await this.hasVerifiedId(reservation.id, reservation.guestId);
      if (!verified) reasons.push("id_verification_required");
    }
    if (reservation.waiverRequired) {
      const signed = await this.hasSignedWaiver(reservation.id, reservation.guestId);
      if (!signed) {
        reasons.push("waiver_required");
        try {
          const signatureResult = await this.signaturesService.autoSendForReservation(reservation);
          signingUrl = signatureResult?.signingUrl;
        } catch (err) {
          signingUrl = void 0;
        }
      }
    }
    return { ok: reasons.length === 0, reason: reasons[0], reasons, signingUrl };
  }
  /**
   * Compute pricing using V2 rules if any exist, otherwise fallback to legacy.
   * Returns unified result with pricingRuleVersion for snapshot.
   */
  async computePriceV2(campgroundId, siteId, arrival, departure, options) {
    const site = await this.prisma.site.findUnique({
      where: { id: siteId },
      include: { siteClass: true }
    });
    if (!site) throw new import_common35.NotFoundException("Site not found");
    const nights = this.computeNights(arrival, departure);
    const defaultRate = site.siteClass?.defaultRate ?? 0;
    const v2RuleCount = await this.prisma.pricingRuleV2.count({
      where: { campgroundId, active: true }
    });
    let result;
    if (v2RuleCount > 0) {
      const breakdown = await this.pricingV2Service.evaluate(
        campgroundId,
        site.siteClassId,
        defaultRate,
        arrival,
        departure,
        options?.occupancyPct
      );
      result = {
        nights: breakdown.nights,
        baseSubtotalCents: breakdown.baseSubtotalCents,
        totalCents: breakdown.totalBeforeTaxCents,
        rulesDeltaCents: breakdown.adjustmentsCents + breakdown.demandAdjustmentCents,
        pricingRuleVersion: breakdown.pricingRuleVersion,
        appliedRules: breakdown.appliedRules
      };
    } else {
      const legacy = await this.computePrice(campgroundId, siteId, arrival, departure, options);
      result = {
        nights: legacy.nights,
        baseSubtotalCents: legacy.baseSubtotalCents,
        totalCents: legacy.totalCents,
        rulesDeltaCents: legacy.rulesDeltaCents,
        pricingRuleVersion: "v1:legacy",
        seasonalRate: legacy.seasonalRate,
        taxExemption: legacy.taxExemption
      };
    }
    if (v2RuleCount > 0) {
      const taxExemption = await this.taxRulesService.evaluateExemption(
        campgroundId,
        nights,
        options?.taxWaiverSigned ?? false
      );
      result.taxExemption = {
        eligible: taxExemption.eligible,
        applied: taxExemption.applied,
        requiresWaiver: taxExemption.rule?.requiresWaiver ?? false,
        waiverText: taxExemption.rule?.waiverText ?? null,
        reason: taxExemption.reason ?? null
      };
    }
    return result;
  }
  /**
   * Assert deposit using V2 DepositPolicy if available, otherwise legacy.
   * Returns deposit calculation with version string.
   */
  async assertDepositV2(campgroundId, siteClassId, totalAmount, lodgingOnlyCents, paidAmount, arrivalDate, departureDate) {
    const nights = this.computeNights(arrivalDate, departureDate);
    const v2Calc = await this.depositPoliciesService.calculateDeposit(
      campgroundId,
      siteClassId,
      totalAmount,
      lodgingOnlyCents,
      nights
    );
    if (v2Calc) {
      if (paidAmount < v2Calc.depositAmountCents) {
        throw new import_common35.BadRequestException(
          `Deposit of at least $${(v2Calc.depositAmountCents / 100).toFixed(2)} required (${v2Calc.policy.name}: ${v2Calc.policy.strategy})`
        );
      }
      return {
        depositAmount: v2Calc.depositAmountCents,
        depositPolicyVersion: v2Calc.depositPolicyVersion
      };
    }
    const campground = await this.prisma.campground.findUnique({ where: { id: campgroundId } });
    if (!campground) throw new import_common35.NotFoundException("Campground not found");
    const required = this.computeDepositRequired(
      campground.depositRule,
      totalAmount,
      nights,
      campground.depositPercentage
    );
    if (paidAmount < required) {
      throw new import_common35.BadRequestException(
        `Deposit of at least $${(required / 100).toFixed(2)} required by campground rule (${campground.depositRule || "none"})`
      );
    }
    return {
      depositAmount: required,
      depositPolicyVersion: "v1:legacy"
    };
  }
  computePaymentStatus(total, paid) {
    if (!total || total <= 0) return "unpaid";
    if (paid >= total) return "paid";
    if (paid > 0) return "partial";
    return "unpaid";
  }
  async enqueuePlaybooksForReservation(type, reservationId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: { id: true, campgroundId: true, arrivalDate: true, guestId: true, totalAmount: true, paidAmount: true }
    });
    if (!reservation) return;
    const playbooks = await this.prisma.communicationPlaybook.findMany({
      where: { campgroundId: reservation.campgroundId, type, enabled: true, templateId: { not: null } }
    });
    for (const pb of playbooks) {
      const template = await this.prisma.communicationTemplate.findFirst({
        where: { id: pb.templateId, status: "approved" }
      });
      if (!template) continue;
      const scheduledAt = new Date(type === "arrival" ? reservation.arrivalDate : /* @__PURE__ */ new Date());
      if (pb.offsetMinutes && Number.isFinite(pb.offsetMinutes)) {
        scheduledAt.setMinutes(scheduledAt.getMinutes() + pb.offsetMinutes);
      }
      await this.prisma.communicationPlaybookJob.create({
        data: {
          playbookId: pb.id,
          campgroundId: reservation.campgroundId,
          reservationId: reservation.id,
          guestId: reservation.guestId,
          status: "pending",
          scheduledAt
        }
      });
    }
  }
  // every 12 hours
  async enqueueUnpaidSweep() {
    const reservations = await this.prisma.reservation.findMany({
      where: {
        status: { not: import_client7.ReservationStatus.cancelled },
        totalAmount: { gt: 0 }
      },
      select: { id: true, campgroundId: true, guestId: true, totalAmount: true, paidAmount: true }
    });
    const due = reservations.filter((r) => Number(r.paidAmount || 0) < Number(r.totalAmount || 0));
    if (!due.length) return;
    const playbooks = await this.prisma.communicationPlaybook.findMany({
      where: {
        type: "unpaid",
        enabled: true,
        templateId: { not: null }
      }
    });
    for (const pb of playbooks) {
      const tpl = await this.prisma.communicationTemplate.findFirst({ where: { id: pb.templateId, status: "approved" } });
      if (!tpl) continue;
      for (const r of due.filter((d) => d.campgroundId === pb.campgroundId)) {
        const scheduledAt = /* @__PURE__ */ new Date();
        if (pb.offsetMinutes && Number.isFinite(pb.offsetMinutes)) {
          scheduledAt.setMinutes(scheduledAt.getMinutes() + pb.offsetMinutes);
        }
        await this.prisma.communicationPlaybookJob.create({
          data: {
            playbookId: pb.id,
            campgroundId: r.campgroundId,
            reservationId: r.id,
            guestId: r.guestId,
            status: "pending",
            scheduledAt
          }
        });
      }
    }
  }
  isOverlapError(err) {
    return err instanceof import_client7.Prisma.PrismaClientKnownRequestError && err.message.includes("Reservation_no_overlap");
  }
  /**
   * Find an available site in a given site class for the specified date range.
   */
  async findAvailableSiteInClass(campgroundId, siteClassId, arrival, departure, options) {
    const sites = await this.prisma.site.findMany({
      where: {
        campgroundId,
        siteClassId,
        isActive: true
      },
      include: {
        siteClass: true
      }
    });
    if (!sites || sites.length === 0) {
      return null;
    }
    const guest = options?.guestId ? await this.prisma.guest.findUnique({
      where: { id: options.guestId },
      include: { reservations: { include: { site: true } } }
    }) : null;
    const candidates = [];
    for (const site of sites) {
      try {
        await this.assertSiteAvailable(site.id, arrival, departure, void 0, options?.holdId ?? void 0);
        this.validateAssignmentConstraints(
          {
            siteType: site.siteType,
            rigMaxLength: site.rigMaxLength,
            siteClassRigMaxLength: site.siteClass?.rigMaxLength ?? null,
            accessible: site.accessible,
            amenityTags: site.amenityTags,
            maxOccupancy: site.maxOccupancy
          },
          {
            rigType: options?.rigType,
            rigLength: options?.rigLength ?? null,
            requiresAccessible: options?.requiresAccessible ?? null,
            requiredAmenities: options?.requiredAmenities ?? null,
            adults: options?.adults ?? null,
            children: options?.children ?? null
          }
        );
        const match = guest ? this.matchScoreService.calculateMatchScore(guest, site) : { score: 0 };
        candidates.push({ site, score: match.score });
      } catch {
        continue;
      }
    }
    if (!candidates.length) {
      return null;
    }
    candidates.sort((a, b) => b.score - a.score);
    return candidates[0].site.id;
  }
  /**
   * Fast overlap check using Postgres range operators to avoid Prisma-generated slow queries.
   */
  async assertSiteAvailable(siteId, arrival, departure, ignoreReservationId, ignoreHoldId) {
    const range = import_client7.Prisma.sql`tstzrange(${arrival}, ${departure}, '[)'::text)`;
    const ignore = ignoreReservationId ? import_client7.Prisma.sql`AND r."id" <> ${ignoreReservationId}` : import_client7.Prisma.sql``;
    const site = await this.prisma.site.findUnique({ where: { id: siteId }, select: { campgroundId: true } });
    if (!site) {
      throw new import_common35.NotFoundException("Site not found");
    }
    const result = await this.prisma.$queryRaw`
      SELECT COUNT(*)::int as count
      FROM "Reservation" r
      WHERE r."siteId" = ${siteId}
        AND r."status" != 'cancelled'
        ${ignore}
        AND tstzrange(r."arrivalDate", r."departureDate", '[)'::text) && ${range}
    `;
    const overlapCount = result?.[0]?.count ?? 0;
    if (overlapCount > 0) {
      throw new import_common35.ConflictException("Site is not available for the selected dates.");
    }
    const now = /* @__PURE__ */ new Date();
    const holdCount = await this.prisma.siteHold.count({
      where: {
        siteId,
        status: "active",
        ...ignoreHoldId ? { id: { not: ignoreHoldId } } : {},
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }],
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival }
      }
    });
    if (holdCount > 0) {
      throw new import_common35.ConflictException("Site is currently on hold for these dates.");
    }
    const maintenanceCount = await this.prisma.maintenanceTicket.count({
      where: {
        siteId,
        status: { in: [import_client7.MaintenanceStatus.open, import_client7.MaintenanceStatus.in_progress] },
        OR: [
          { isBlocking: true },
          { outOfOrder: true },
          { outOfOrderUntil: { gt: arrival } }
        ]
      }
    });
    if (maintenanceCount > 0) {
      throw new import_common35.ConflictException("Site is unavailable due to maintenance.");
    }
    const blackoutCount = await this.prisma.blackoutDate.count({
      where: {
        campgroundId: site.campgroundId,
        OR: [
          { siteId },
          { siteId: null }
        ],
        startDate: { lt: departure },
        endDate: { gt: arrival }
      }
    });
    if (blackoutCount > 0) {
      throw new import_common35.ConflictException("Site is blacked out for maintenance or other reasons.");
    }
  }
  /**
   * Pricing calculation with seasonal rates and tax exemptions.
   * - Uses SeasonalRatesService.findApplicableRate() to get best rate based on stay length
   * - Uses TaxRulesService.evaluateExemption() to check tax waiver eligibility
   */
  async computePrice(campgroundId, siteId, arrival, departure, options) {
    const site = await this.prisma.site.findUnique({
      where: { id: siteId },
      include: { siteClass: true }
    });
    if (!site) throw new import_common35.NotFoundException("Site not found");
    const nights = this.computeNights(arrival, departure);
    const defaultRate = site.siteClass?.defaultRate ?? 0;
    const seasonalRate = await this.seasonalRatesService.findApplicableRate(
      campgroundId,
      site.siteClassId,
      nights,
      arrival
    );
    const baseRate = seasonalRate ? seasonalRate.amount : defaultRate;
    const rules = await this.prisma.pricingRule.findMany({
      where: {
        campgroundId,
        isActive: true,
        OR: [{ siteClassId: null }, { siteClassId: site.siteClassId }]
      }
    });
    let total = 0;
    let baseSubtotal = 0;
    let rulesDelta = 0;
    for (let i = 0; i < nights; i++) {
      const day = new Date(arrival);
      day.setDate(day.getDate() + i);
      const dow = day.getDay();
      let nightly = baseRate;
      let nightlyDelta = 0;
      for (const rule of rules) {
        if (rule.minNights && nights < rule.minNights) continue;
        if (rule.startDate && day < rule.startDate) continue;
        if (rule.endDate && day > rule.endDate) continue;
        if (rule.dayOfWeek !== null && rule.dayOfWeek !== void 0 && rule.dayOfWeek !== dow) continue;
        if (rule.flatAdjust) nightlyDelta += rule.flatAdjust;
        if (rule.percentAdjust) nightlyDelta += Math.round(nightly * Number(rule.percentAdjust));
      }
      nightly += nightlyDelta;
      baseSubtotal += baseRate;
      rulesDelta += nightlyDelta;
      total += nightly;
    }
    const taxExemption = await this.taxRulesService.evaluateExemption(
      campgroundId,
      nights,
      options?.taxWaiverSigned ?? false
    );
    return {
      nights,
      baseSubtotalCents: baseSubtotal,
      rulesDeltaCents: rulesDelta,
      totalCents: total,
      seasonalRate: seasonalRate ? {
        id: seasonalRate.id,
        name: seasonalRate.name,
        rateType: seasonalRate.rateType,
        amount: seasonalRate.amount
      } : null,
      taxExemption: {
        eligible: taxExemption.eligible,
        applied: taxExemption.applied,
        requiresWaiver: taxExemption.rule?.requiresWaiver ?? false,
        waiverText: taxExemption.rule?.waiverText ?? null,
        reason: taxExemption.reason ?? null
      }
    };
  }
  async assertDeposit(campgroundId, totalAmount, paidAmount, arrivalDate, departureDate) {
    const campground = await this.prisma.campground.findUnique({ where: { id: campgroundId } });
    if (!campground) throw new import_common35.NotFoundException("Campground not found");
    const nights = this.computeNights(arrivalDate, departureDate);
    const required = this.computeDepositRequired(
      campground.depositRule,
      totalAmount,
      nights,
      campground.depositPercentage
    );
    if (paidAmount < required) {
      throw new import_common35.BadRequestException(
        `Deposit of at least $${(required / 100).toFixed(2)} required by campground rule (${campground.depositRule || "none"})`
      );
    }
    return required;
  }
  async calculateDeposit(id) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: { campground: true }
    });
    if (!reservation) throw new import_common35.NotFoundException("Reservation not found");
    const nights = this.computeNights(reservation.arrivalDate, reservation.departureDate);
    const depositAmount = this.computeDepositRequired(
      reservation.campground.depositRule,
      reservation.totalAmount,
      nights,
      reservation.campground.depositPercentage
    );
    const remainingBalance = Math.max(0, reservation.totalAmount - (reservation.paidAmount || 0));
    return { depositAmount, remainingBalance };
  }
  buildPaymentFields(totalAmount, paidAmount) {
    const balanceAmount = Math.max(0, totalAmount - paidAmount);
    const paymentStatus = this.computePaymentStatus(totalAmount, paidAmount);
    return { balanceAmount, paymentStatus };
  }
  isRigCompatible(site, rigType, rigLength) {
    if (!rigType && !rigLength) return true;
    const normalizedType = (rigType || "").toLowerCase();
    if (["tent", "cabin", "car", "walkin", "walk-in"].includes(normalizedType)) {
      return true;
    }
    if (site.siteType !== "rv") return false;
    const maxLength = site.rigMaxLength ?? site.siteClassRigMaxLength ?? null;
    if (rigLength && maxLength && rigLength > maxLength) return false;
    return true;
  }
  validateAssignmentConstraints(site, opts) {
    const occupancy = (opts.adults ?? 0) + (opts.children ?? 0);
    if (site.maxOccupancy && occupancy > site.maxOccupancy) {
      throw new import_common35.BadRequestException(`Occupancy exceeds max for this site (${site.maxOccupancy}).`);
    }
    if (!this.isRigCompatible(site, opts.rigType, opts.rigLength ?? null)) {
      throw new import_common35.BadRequestException("Rig type or length is not compatible with this site.");
    }
    if (opts.requiresAccessible && !site.accessible) {
      throw new import_common35.BadRequestException("An ADA accessible site is required for this reservation.");
    }
    if (opts.requiredAmenities && opts.requiredAmenities.length > 0) {
      const siteAmenities = (site.amenityTags ?? []).map((a) => a.toLowerCase());
      const missing = opts.requiredAmenities.filter((a) => !siteAmenities.includes((a || "").toLowerCase()));
      if (missing.length > 0) {
        throw new import_common35.BadRequestException(`Site is missing required amenities: ${missing.join(", ")}`);
      }
    }
  }
  async searchAvailability(campgroundId, arrivalDate, departureDate, rigType, rigLength) {
    if (!arrivalDate || !departureDate) {
      throw new import_common35.BadRequestException("arrivalDate and departureDate are required");
    }
    const arrival = new Date(arrivalDate);
    const departure = new Date(departureDate);
    if (!(arrival instanceof Date) || isNaN(arrival.valueOf()) || !(departure instanceof Date) || isNaN(departure.valueOf())) {
      throw new import_common35.BadRequestException("Invalid dates");
    }
    if (departure <= arrival) {
      throw new import_common35.BadRequestException("departureDate must be after arrivalDate");
    }
    const allSites = await this.prisma.site.findMany({
      where: {
        campgroundId,
        isActive: true
      },
      select: {
        id: true,
        campgroundId: true,
        name: true,
        siteNumber: true,
        siteType: true,
        siteClassId: true,
        maxOccupancy: true,
        isActive: true,
        rigMaxLength: true,
        siteClass: {
          select: {
            rigMaxLength: true,
            defaultRate: true,
            name: true,
            siteType: true
          }
        }
      },
      orderBy: {
        name: "asc"
      }
    });
    const conflictingReservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        status: { not: import_client7.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure }
      },
      select: {
        siteId: true
      }
    });
    const conflictingSiteIds = new Set(conflictingReservations.map((r) => r.siteId));
    const now = /* @__PURE__ */ new Date();
    const holds = await this.prisma.siteHold.findMany({
      where: {
        campgroundId,
        status: "active",
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }],
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival }
      },
      select: { siteId: true }
    });
    const holdSiteIds = new Set(holds.map((h) => h.siteId));
    const blackouts = await this.prisma.blackoutDate.findMany({
      where: {
        campgroundId,
        startDate: { lt: departure },
        endDate: { gt: arrival }
      },
      select: {
        siteId: true
      }
    });
    const blackedOutSiteIds = /* @__PURE__ */ new Set();
    let campgroundBlackedOut = false;
    for (const b of blackouts) {
      if (b.siteId) {
        blackedOutSiteIds.add(b.siteId);
      } else {
        campgroundBlackedOut = true;
      }
    }
    if (campgroundBlackedOut) {
      return [];
    }
    const rigLengthNum = rigLength ? Number(rigLength) : null;
    const availableSites = allSites.filter(
      (site) => !conflictingSiteIds.has(site.id) && !blackedOutSiteIds.has(site.id) && !holdSiteIds.has(site.id) && this.isRigCompatible(
        {
          siteType: site.siteType || site.siteClass?.siteType || "rv",
          rigMaxLength: site.rigMaxLength,
          siteClassRigMaxLength: site?.siteClass?.rigMaxLength ?? null
        },
        rigType,
        Number.isFinite(rigLengthNum) ? rigLengthNum : null
      )
    );
    return availableSites;
  }
  /**
   * Get all sites with their current occupancy status for a given date range.
   * Returns: available, occupied, or maintenance status for each site.
   */
  async getSitesWithStatus(campgroundId, arrivalDate, departureDate) {
    const now = /* @__PURE__ */ new Date();
    const arrival = arrivalDate ? new Date(arrivalDate) : now;
    const departure = departureDate ? new Date(departureDate) : new Date(now.getTime() + 24 * 60 * 60 * 1e3);
    const campground = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: { latitude: true, longitude: true }
    });
    const campgroundLat = campground?.latitude ? Number(campground.latitude) : null;
    const campgroundLng = campground?.longitude ? Number(campground.longitude) : null;
    const allSites = await this.prisma.site.findMany({
      where: {
        campgroundId,
        isActive: true
      },
      include: {
        siteClass: {
          select: { name: true, defaultRate: true }
        }
      },
      orderBy: { name: "asc" }
    });
    const conflictingReservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        status: { not: import_client7.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure }
      },
      select: {
        siteId: true,
        arrivalDate: true,
        departureDate: true,
        guest: {
          select: { primaryFirstName: true, primaryLastName: true }
        }
      }
    });
    const occupiedSiteMap = /* @__PURE__ */ new Map();
    for (const r of conflictingReservations) {
      occupiedSiteMap.set(r.siteId, {
        guestName: `${r.guest.primaryFirstName} ${r.guest.primaryLastName}`,
        arrivalDate: r.arrivalDate,
        departureDate: r.departureDate
      });
    }
    const maintenanceTickets = await this.prisma.maintenanceTicket.findMany({
      where: {
        campgroundId,
        status: { in: [import_client7.MaintenanceStatus.open, import_client7.MaintenanceStatus.in_progress] },
        siteId: { not: null }
      },
      select: { siteId: true, title: true }
    });
    const maintenanceSiteMap = /* @__PURE__ */ new Map();
    for (const t of maintenanceTickets) {
      if (t.siteId) maintenanceSiteMap.set(t.siteId, t.title);
    }
    const blackouts = await this.prisma.blackoutDate.findMany({
      where: {
        campgroundId,
        startDate: { lt: departure },
        endDate: { gt: arrival }
      },
      select: { siteId: true, reason: true }
    });
    const blackoutSiteMap = /* @__PURE__ */ new Map();
    let campgroundBlackedOut = false;
    for (const b of blackouts) {
      if (b.siteId) {
        blackoutSiteMap.set(b.siteId, b.reason || "Blacked out");
      } else {
        campgroundBlackedOut = true;
      }
    }
    return allSites.map((site, idx) => {
      let status = "available";
      let statusDetail = null;
      if (campgroundBlackedOut || blackoutSiteMap.has(site.id)) {
        status = "maintenance";
        statusDetail = blackoutSiteMap.get(site.id) || "Campground closed";
      } else if (maintenanceSiteMap.has(site.id)) {
        status = "maintenance";
        statusDetail = maintenanceSiteMap.get(site.id) || "Under maintenance";
      } else if (occupiedSiteMap.has(site.id)) {
        status = "occupied";
        const occ = occupiedSiteMap.get(site.id);
        statusDetail = occ.guestName;
      }
      const derivedLat = site.latitude !== null && site.latitude !== void 0 ? Number(site.latitude) : campgroundLat !== null ? campgroundLat + 5e-4 * Math.sin(idx) : null;
      const derivedLng = site.longitude !== null && site.longitude !== void 0 ? Number(site.longitude) : campgroundLng !== null ? campgroundLng + 5e-4 * Math.cos(idx) : null;
      return {
        id: site.id,
        campgroundId: site.campgroundId,
        name: site.name,
        siteNumber: site.siteNumber,
        siteType: site.siteType,
        siteClassId: site.siteClassId,
        siteClassName: site.siteClass?.name || null,
        maxOccupancy: site.maxOccupancy,
        latitude: derivedLat,
        longitude: derivedLng,
        defaultRate: site.siteClass?.defaultRate ?? null,
        status,
        statusDetail
      };
    });
  }
  listByCampground(campgroundId) {
    return this.prisma.reservation.findMany({
      where: { campgroundId },
      include: { guest: true, site: true }
    });
  }
  async findOne(id) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        guest: true,
        site: { include: { siteClass: true } },
        campground: true,
        payments: true
      }
    });
    if (!reservation) throw new import_common35.NotFoundException("Reservation not found");
    const paymentStatus = this.computePaymentStatus(reservation.totalAmount, reservation.paidAmount ?? 0);
    const balanceAmount = Math.max(0, reservation.totalAmount - (reservation.paidAmount ?? 0));
    return {
      ...reservation,
      paymentStatus,
      balanceAmount
    };
  }
  async create(data) {
    const arrival = new Date(data.arrivalDate);
    const departure = new Date(data.departureDate);
    let siteId = data.siteId;
    if (!siteId && data.siteClassId) {
      siteId = await this.findAvailableSiteInClass(data.campgroundId, data.siteClassId, arrival, departure, {
        guestId: data.guestId,
        rigType: data.rigType ?? data.rvType ?? null,
        rigLength: data.rigLength ?? null,
        requiresAccessible: data.requiresAccessible ?? null,
        requiredAmenities: data.requiredAmenities ?? null,
        adults: data.adults,
        children: data.children ?? 0,
        holdId: data.holdId ?? null
      });
      if (!siteId) {
        throw new import_common35.ConflictException("No available sites found in the selected class for the given dates.");
      }
    }
    if (!siteId) {
      throw new import_common35.BadRequestException("Either siteId or siteClassId must be provided.");
    }
    try {
      return await this.locks.withLocks([siteId], async () => {
        let hold = null;
        if (data.holdId) {
          hold = await this.prisma.siteHold.findUnique({ where: { id: data.holdId } });
          const now = /* @__PURE__ */ new Date();
          if (!hold) {
            throw new import_common35.NotFoundException("Hold not found");
          }
          if (hold.status !== "active" || hold.expiresAt && hold.expiresAt <= now) {
            throw new import_common35.ConflictException("Hold is not active");
          }
          if (hold.siteId !== siteId || hold.campgroundId !== data.campgroundId) {
            throw new import_common35.ConflictException("Hold does not match site/campground");
          }
          if (!(hold.arrivalDate <= arrival && hold.departureDate >= departure)) {
            throw new import_common35.ConflictException("Hold does not cover requested dates");
          }
        }
        await this.assertSiteAvailable(siteId, arrival, departure, void 0, data.holdId);
        const siteInfo = await this.prisma.site.findUnique({
          where: { id: siteId },
          include: {
            siteClass: {
              select: { rigMaxLength: true, siteType: true, name: true }
            }
          },
          select: {
            siteClassId: true,
            siteType: true,
            rigMaxLength: true,
            accessible: true,
            amenityTags: true,
            maxOccupancy: true
          }
        });
        if (!siteInfo) {
          throw new import_common35.NotFoundException("Site not found");
        }
        this.validateAssignmentConstraints(
          {
            siteType: siteInfo.siteType,
            rigMaxLength: siteInfo.rigMaxLength,
            siteClassRigMaxLength: siteInfo.siteClass?.rigMaxLength ?? null,
            accessible: siteInfo.accessible,
            amenityTags: siteInfo.amenityTags,
            maxOccupancy: siteInfo.maxOccupancy
          },
          {
            rigType: data.rigType ?? data.rvType ?? null,
            rigLength: data.rigLength ?? null,
            requiresAccessible: data.requiresAccessible ?? null,
            requiredAmenities: data.requiredAmenities ?? null,
            adults: data.adults,
            children: data.children ?? 0
          }
        );
        const baselinePrice = await this.computePriceV2(data.campgroundId, siteId, arrival, departure);
        const manualPriceProvided = data.totalAmount !== void 0 && data.totalAmount !== null && data.totalAmount > 0;
        const price = manualPriceProvided ? {
          totalCents: data.totalAmount,
          baseSubtotalCents: baselinePrice.baseSubtotalCents,
          rulesDeltaCents: baselinePrice.rulesDeltaCents,
          nights: this.computeNights(arrival, departure),
          pricingRuleVersion: "manual"
        } : baselinePrice;
        const manualDiscountProvided = (data.discountsAmount ?? 0) > 0;
        const manualOverrideDelta = manualPriceProvided ? data.totalAmount - baselinePrice.totalCents : 0;
        const overrideReason = data.overrideReason;
        const overrideApprovedBy = data.overrideApprovedBy;
        const needsOverrideApproval = manualPriceProvided && manualOverrideDelta !== 0 || manualDiscountProvided;
        if (needsOverrideApproval && (!overrideReason || !overrideApprovedBy)) {
          throw new import_common35.BadRequestException("Manual pricing overrides require overrideReason and overrideApprovedBy.");
        }
        let subtotal = price.totalCents;
        let discountCents = 0;
        let promoCode = data.promoCode || null;
        let promotionId = null;
        let referralProgram = null;
        let referralDiscountCents = 0;
        let referralIncentiveType = null;
        let referralIncentiveValue = 0;
        let referralSource = data.referralSource ?? data.source ?? null;
        let referralChannel = data.referralChannel ?? null;
        if (promoCode) {
          try {
            const validation = await this.promotionsService.validate({
              campgroundId: data.campgroundId,
              code: promoCode,
              subtotal
            });
            discountCents = validation.discountCents;
            promotionId = validation.promotionId;
          } catch (err) {
            throw err;
          }
        }
        if (data.referralProgramId || data.referralCode) {
          referralProgram = await this.prisma.referralProgram.findFirst({
            where: {
              campgroundId: data.campgroundId,
              isActive: true,
              OR: [
                data.referralProgramId ? { id: data.referralProgramId } : void 0,
                data.referralCode ? { code: data.referralCode } : void 0,
                data.referralCode ? { linkSlug: data.referralCode } : void 0
              ].filter(Boolean)
            }
          });
          if (!referralProgram) {
            throw new import_common35.BadRequestException("Invalid or inactive referral code");
          }
          const basis = Math.max(0, subtotal - discountCents);
          referralIncentiveType = referralProgram.incentiveType;
          referralIncentiveValue = referralProgram.incentiveValue ?? 0;
          referralSource = referralProgram.source ?? referralSource;
          referralChannel = referralProgram.channel ?? referralChannel;
          if (referralIncentiveType === import_client7.ReferralIncentiveType.percent_discount) {
            referralDiscountCents = Math.min(basis, Math.floor(basis * (referralIncentiveValue / 100)));
          } else {
            referralDiscountCents = Math.min(basis, Math.max(0, referralIncentiveValue));
          }
        }
        const totalBeforeReferral = Math.max(0, subtotal - discountCents);
        const totalAmount = Math.max(0, totalBeforeReferral - referralDiscountCents);
        const paidAmount = data.paidAmount ?? 0;
        const depositCalc = await this.assertDepositV2(
          data.campgroundId,
          siteInfo?.siteClassId ?? null,
          totalAmount,
          price.baseSubtotalCents,
          // lodging only
          paidAmount,
          arrival,
          departure
        );
        const paymentFields = this.buildPaymentFields(totalAmount, paidAmount);
        const {
          paymentMethod,
          transactionId,
          paymentNotes,
          siteClassId,
          rvType,
          pets,
          overrideReason: _overrideReason,
          overrideApprovedBy: _overrideApprovedBy,
          ...reservationData
        } = data;
        const reservation = await this.prisma.reservation.create({
          data: {
            ...reservationData,
            rigType: data.rigType || rvType,
            siteId,
            // Use the determined siteId (either from data or found from siteClassId)
            children: data.children ?? 0,
            status: data.status ?? import_client7.ReservationStatus.pending,
            arrivalDate: arrival,
            departureDate: departure,
            paidAmount,
            totalAmount,
            baseSubtotal: data.baseSubtotal ?? price.baseSubtotalCents,
            feesAmount: data.feesAmount ?? 0,
            taxesAmount: data.taxesAmount ?? 0,
            discountsAmount: (discountCents > 0 ? discountCents : data.discountsAmount ?? (price.rulesDeltaCents < 0 ? -price.rulesDeltaCents : 0)) + referralDiscountCents,
            promoCode,
            referralProgramId: referralProgram?.id ?? data.referralProgramId ?? null,
            referralCode: referralProgram?.code ?? data.referralCode ?? null,
            referralSource: referralSource ?? null,
            referralChannel: referralChannel ?? null,
            referralIncentiveType,
            referralIncentiveValue: referralDiscountCents || referralIncentiveValue || null,
            stayReasonPreset: data.stayReasonPreset ?? null,
            stayReasonOther: data.stayReasonOther ?? null,
            depositAmount: depositCalc.depositAmount,
            depositDueDate: /* @__PURE__ */ new Date(),
            // Due immediately upon booking
            pricingRuleVersion: price.pricingRuleVersion,
            depositPolicyVersion: depositCalc.depositPolicyVersion,
            ...paymentFields,
            checkInAt: data.checkInAt ? new Date(data.checkInAt) : null,
            checkOutAt: data.checkOutAt ? new Date(data.checkOutAt) : null,
            notes: data.notes ?? null
          },
          include: {
            site: {
              include: {
                siteClass: true
              }
            },
            guest: true
          }
        });
        await this.enqueuePlaybooksForReservation("arrival", reservation.id);
        if (hold?.id) {
          await this.prisma.siteHold.update({
            where: { id: hold.id },
            data: { status: "released", expiresAt: hold.expiresAt ?? /* @__PURE__ */ new Date() }
          });
        }
        if (paidAmount > 0) {
          await this.prisma.payment.create({
            data: {
              campgroundId: data.campgroundId,
              reservationId: reservation.id,
              amountCents: paidAmount,
              method: paymentMethod || "card",
              // Default to card if not specified
              direction: "charge",
              note: paymentNotes || (transactionId ? `Transaction ID: ${transactionId}` : "Initial payment")
            }
          });
          const revenueGl = reservation.site?.siteClass?.glCode ?? "REVENUE_UNMAPPED";
          const revenueAccount = reservation.site?.siteClass?.clientAccount ?? "Revenue";
          await postBalancedLedgerEntries(this.prisma, [
            {
              campgroundId: data.campgroundId,
              reservationId: reservation.id,
              glCode: "CASH",
              account: "Cash",
              description: paymentNotes || "Initial reservation payment",
              amountCents: paidAmount,
              direction: "debit",
              externalRef: transactionId ?? void 0,
              dedupeKey: transactionId ? `res:${reservation.id}:init:${transactionId}:debit` : `res:${reservation.id}:init:debit`
            },
            {
              campgroundId: data.campgroundId,
              reservationId: reservation.id,
              glCode: revenueGl,
              account: revenueAccount,
              description: paymentNotes || "Initial reservation payment",
              amountCents: paidAmount,
              direction: "credit",
              externalRef: transactionId ?? void 0,
              dedupeKey: transactionId ? `res:${reservation.id}:init:${transactionId}:credit` : `res:${reservation.id}:init:credit`
            }
          ]);
        }
        if (promotionId) {
          await this.promotionsService.incrementUsage(promotionId);
        }
        if (needsOverrideApproval) {
          await this.audit.record({
            campgroundId: data.campgroundId,
            actorId: overrideApprovedBy ?? data.updatedBy ?? data.createdBy ?? null,
            action: "reservation_override",
            entity: "reservation",
            entityId: reservation.id,
            before: null,
            after: {
              totalAmount,
              baselineTotalCents: baselinePrice.totalCents,
              deltaCents: manualOverrideDelta,
              discountsAmount: reservation.discountsAmount ?? 0
            }
          });
          await this.approvals.create({
            type: "config_change",
            amount: Math.abs(manualOverrideDelta) / 100,
            currency: "USD",
            reason: overrideReason || "Manual pricing override",
            requester: overrideApprovedBy || data.updatedBy || data.createdBy || "unknown",
            metadata: {
              reservationId: reservation.id,
              guestId: reservation.guestId,
              siteId: reservation.siteId,
              baselineTotalCents: baselinePrice.totalCents
            }
          });
        }
        try {
          await this.signaturesService.autoSendForReservation(reservation);
        } catch (err) {
          console.warn(`[Signatures] Auto-send failed for reservation ${reservation.id}:`, err);
        }
        return reservation;
      });
    } catch (err) {
      if (this.isOverlapError(err)) {
        throw new import_common35.ConflictException("Site is not available for the selected dates.");
      }
      throw err;
    }
  }
  async update(id, data) {
    const existing = await this.prisma.reservation.findUnique({
      where: { id },
      include: { guest: true, campground: true, site: true }
    });
    if (!existing) throw new import_common35.NotFoundException("Reservation not found");
    const arrival = data.arrivalDate ? new Date(data.arrivalDate) : existing.arrivalDate;
    const departure = data.departureDate ? new Date(data.departureDate) : existing.departureDate;
    const targetSiteId = data.siteId ?? existing.siteId;
    const lockIds = Array.from(new Set([existing.siteId, targetSiteId].filter(Boolean)));
    try {
      return await this.locks.withLocks(lockIds, async () => {
        await this.assertSiteAvailable(targetSiteId, arrival, departure, id);
        const siteInfo = await this.prisma.site.findUnique({
          where: { id: targetSiteId },
          select: {
            siteClassId: true,
            siteType: true,
            rigMaxLength: true,
            accessible: true,
            amenityTags: true,
            maxOccupancy: true,
            siteClass: { select: { rigMaxLength: true, siteType: true, name: true } }
          }
        });
        if (!siteInfo) {
          throw new import_common35.NotFoundException("Site not found");
        }
        this.validateAssignmentConstraints(
          {
            siteType: siteInfo.siteType,
            rigMaxLength: siteInfo.rigMaxLength,
            siteClassRigMaxLength: siteInfo.siteClass?.rigMaxLength ?? null,
            accessible: siteInfo.accessible,
            amenityTags: siteInfo.amenityTags,
            maxOccupancy: siteInfo.maxOccupancy
          },
          {
            rigType: data.rigType ?? existing.rigType ?? existing.rvType ?? null,
            rigLength: data.rigLength ?? existing.rigLength ?? null,
            requiresAccessible: data?.requiresAccessible ?? null,
            requiredAmenities: data?.requiredAmenities ?? null,
            adults: data.adults ?? existing.adults ?? 0,
            children: data.children ?? existing.children ?? 0
          }
        );
        const baselinePrice = await this.computePriceV2(existing.campgroundId, targetSiteId, arrival, departure);
        const shouldReprice = data.totalAmount === void 0 || data.totalAmount === null;
        const price = shouldReprice ? baselinePrice : null;
        const totalAmount = shouldReprice ? baselinePrice.totalCents : data.totalAmount ?? existing.totalAmount;
        const paidAmount = data.paidAmount ?? existing.paidAmount ?? 0;
        const manualDiscountProvided = data.discountsAmount !== void 0 && data.discountsAmount !== null;
        const manualOverrideDelta = shouldReprice ? 0 : totalAmount - baselinePrice.totalCents;
        const overrideReason = data.overrideReason;
        const overrideApprovedBy = data.overrideApprovedBy;
        const needsOverrideApproval = !shouldReprice && (manualOverrideDelta !== 0 || manualDiscountProvided);
        if (needsOverrideApproval && (!overrideReason || !overrideApprovedBy)) {
          throw new import_common35.BadRequestException("Manual pricing overrides require overrideReason and overrideApprovedBy.");
        }
        const depositCalc = await this.assertDepositV2(
          existing.campgroundId,
          siteInfo?.siteClassId ?? null,
          totalAmount,
          price?.baseSubtotalCents ?? data.baseSubtotal ?? existing.baseSubtotal ?? baselinePrice.baseSubtotalCents,
          paidAmount,
          arrival,
          departure
        );
        const paymentFields = this.buildPaymentFields(totalAmount, paidAmount);
        const {
          paymentMethod,
          transactionId,
          paymentNotes,
          overrideReason: _overrideReason,
          overrideApprovedBy: _overrideApprovedBy,
          ...reservationData
        } = data;
        if (reservationData.status === import_client7.ReservationStatus.checked_in) {
          const pendingForms = await this.prisma.formSubmission?.count?.({
            where: { reservationId: id, status: "pending" }
          }) ?? 0;
          if (pendingForms > 0) {
            throw new import_common35.ConflictException("Forms must be completed before check-in");
          }
          const mergedForCompliance = {
            ...existing,
            paymentStatus: reservationData.paymentStatus ?? existing.paymentStatus,
            paymentRequired: reservationData.paymentRequired ?? existing.paymentRequired,
            waiverRequired: reservationData.waiverRequired ?? existing.waiverRequired,
            idVerificationRequired: reservationData.idVerificationRequired ?? existing.idVerificationRequired
          };
          const compliance = await this.checkCompliance(mergedForCompliance);
          if (!compliance.ok) {
            throw new import_common35.ConflictException({
              reason: compliance.reason,
              signingUrl: compliance.signingUrl
            });
          }
        }
        const updatedReservation = await this.prisma.reservation.update({
          where: { id },
          data: {
            ...reservationData,
            arrivalDate: data.arrivalDate ? arrival : void 0,
            departureDate: data.departureDate ? departure : void 0,
            totalAmount,
            paidAmount,
            baseSubtotal: data.baseSubtotal ?? (price ? price.baseSubtotalCents : baselinePrice.baseSubtotalCents ?? existing.baseSubtotal),
            feesAmount: data.feesAmount ?? existing.feesAmount,
            taxesAmount: data.taxesAmount ?? existing.taxesAmount,
            discountsAmount: data.discountsAmount !== void 0 ? data.discountsAmount : price ? price.rulesDeltaCents < 0 ? -price.rulesDeltaCents : 0 : existing.discountsAmount,
            depositAmount: depositCalc.depositAmount,
            pricingRuleVersion: price?.pricingRuleVersion ?? existing.pricingRuleVersion,
            depositPolicyVersion: depositCalc.depositPolicyVersion,
            ...paymentFields,
            checkInAt: data.checkInAt ? new Date(data.checkInAt) : void 0,
            checkOutAt: data.checkOutAt ? new Date(data.checkOutAt) : void 0,
            notes: data.notes ?? void 0,
            siteId: data.siteId ?? void 0
          }
        });
        if (needsOverrideApproval) {
          await this.audit.record({
            campgroundId: existing.campgroundId,
            actorId: overrideApprovedBy ?? data.updatedBy ?? existing.updatedBy ?? null,
            action: "reservation_override",
            entity: "reservation",
            entityId: id,
            before: {
              totalAmount: existing.totalAmount,
              discountsAmount: existing.discountsAmount,
              baselineTotalCents: baselinePrice.totalCents
            },
            after: {
              totalAmount: updatedReservation.totalAmount,
              discountsAmount: updatedReservation.discountsAmount,
              baselineTotalCents: baselinePrice.totalCents,
              deltaCents: manualOverrideDelta
            }
          });
          await this.approvals.create({
            type: "config_change",
            amount: Math.abs(manualOverrideDelta) / 100,
            currency: "USD",
            reason: overrideReason || "Manual pricing override",
            requester: overrideApprovedBy || data.updatedBy || "unknown",
            metadata: {
              reservationId: id,
              guestId: updatedReservation.guestId,
              siteId: updatedReservation.siteId,
              baselineTotalCents: baselinePrice.totalCents
            }
          });
        }
        if (data.status === "cancelled" && existing.status !== "cancelled") {
          await this.emailService.sendEmail({
            to: existing.guest.email,
            subject: `Reservation Cancelled: ${existing.campground.name}`,
            html: `
                  <h1>Reservation Cancelled</h1>
                  <p>Dear ${existing.guest.primaryFirstName},</p>
                  <p>Your reservation at ${existing.campground.name} has been cancelled.</p>
                  <p><strong>Site:</strong> ${existing.site.siteNumber}</p>
                  <p>If you did not request this cancellation, please contact us immediately.</p>
                `
          });
          await this.waitlistService.checkWaitlist(
            existing.campgroundId,
            existing.arrivalDate,
            existing.departureDate,
            existing.siteId,
            existing.site.siteClassId ?? void 0
          );
          await this.accessControl.blockAccessForReservation(id, "reservation_cancelled");
          await this.accessControl.revokeAllForReservation(id, "reservation_cancelled");
        }
        if (data.status === import_client7.ReservationStatus.checked_out && existing.status !== import_client7.ReservationStatus.checked_out) {
          const points = Math.floor(updatedReservation.totalAmount / 100);
          if (points > 0) {
            await this.loyaltyService.awardPoints(
              existing.guestId,
              points,
              `Reservation #${existing.id}`
            );
          }
          try {
            await this.prisma.task.create({
              data: {
                tenantId: existing.campgroundId,
                type: "turnover",
                state: "pending",
                siteId: existing.siteId,
                reservationId: existing.id,
                slaStatus: "on_track",
                slaDueAt: new Date(Date.now() + 4 * 60 * 60 * 1e3),
                // 4 hours from now
                source: "auto_turnover",
                createdBy: "system"
              }
            });
          } catch (taskErr) {
            console.error("Failed to create turnover task:", taskErr);
          }
          await this.accessControl.blockAccessForReservation(id, "checked_out");
          await this.accessControl.revokeAllForReservation(id, "checked_out");
        }
        if (data.status === import_client7.ReservationStatus.confirmed && existing.status !== import_client7.ReservationStatus.confirmed) {
          await this.enqueuePlaybooksForReservation("arrival", updatedReservation.id);
        }
        if (data.status === import_client7.ReservationStatus.checked_in && existing.status !== import_client7.ReservationStatus.checked_in) {
          await this.enqueuePlaybooksForReservation("upsell", updatedReservation.id);
          await this.accessControl.autoGrantForReservation(id);
        }
        if (data.status === import_client7.ReservationStatus.checked_in && existing.status !== import_client7.ReservationStatus.checked_in && existing.createdBy) {
          const membership = await this.prisma.campgroundMembership.findFirst({
            where: { userId: existing.createdBy, campgroundId: existing.campgroundId }
          });
          await this.gamification.recordEvent({
            campgroundId: existing.campgroundId,
            userId: existing.createdBy,
            membershipId: membership?.id,
            category: import_client7.GamificationEventCategory.check_in,
            reason: "Smooth check-in",
            sourceType: "reservation",
            sourceId: existing.id,
            eventKey: `reservation:${existing.id}:checkin`
          });
        }
        return updatedReservation;
      });
    } catch (err) {
      if (this.isOverlapError(err)) {
        throw new import_common35.ConflictException("Site is not available for the selected dates.");
      }
      throw err;
    }
  }
  async updateGroupAssignment(id, payload) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      select: { campgroundId: true, groupId: true }
    });
    if (!reservation) throw new import_common35.NotFoundException("Reservation not found");
    const targetGroupId = payload.groupId ?? null;
    const targetRole = targetGroupId ? payload.role ?? "member" : null;
    if (targetGroupId) {
      const group = await this.prisma.group.findUnique({
        where: { id: targetGroupId },
        select: { tenantId: true }
      });
      if (!group) throw new import_common35.NotFoundException("Group not found");
      if (group.tenantId !== reservation.campgroundId) {
        throw new import_common35.BadRequestException("Group belongs to a different campground");
      }
    }
    await this.prisma.$transaction(async (tx) => {
      if (!targetGroupId || targetRole !== "primary") {
        await tx.group.updateMany({
          where: { primaryReservationId: id },
          data: { primaryReservationId: null }
        });
      }
      if (targetGroupId && targetRole === "primary") {
        await tx.reservation.updateMany({
          where: { groupId: targetGroupId, id: { not: id }, groupRole: "primary" },
          data: { groupRole: "member" }
        });
        await tx.group.update({
          where: { id: targetGroupId },
          data: { primaryReservationId: id }
        });
      }
      await tx.reservation.update({
        where: { id },
        data: { groupId: targetGroupId, groupRole: targetRole }
      });
    });
    return this.findOne(id);
  }
  remove(id) {
    return this.prisma.reservation.delete({ where: { id } });
  }
  async recordPayment(id, amountCents, options) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        site: { include: { siteClass: true } },
        guest: true,
        campground: { select: { name: true } }
      }
    });
    if (!reservation) throw new import_common35.NotFoundException("Reservation not found");
    const tenderList = options?.tenders && options.tenders.length > 0 ? options.tenders : amountCents ? [{ method: options?.paymentMethod || "card", amountCents, note: options?.receiptKind ? `${options.receiptKind} payment` : void 0 }] : [];
    const totalTenderCents = tenderList.reduce((sum, t) => sum + (t.amountCents || 0), 0);
    if (totalTenderCents <= 0) throw new import_common35.BadRequestException("Payment amount must be positive");
    const newPaid = (reservation.paidAmount ?? 0) + totalTenderCents;
    const paymentFields = this.buildPaymentFields(reservation.totalAmount, newPaid);
    const updated = await this.prisma.reservation.update({
      where: { id },
      data: {
        paidAmount: newPaid,
        ...paymentFields
      }
    });
    const revenueGl = reservation.site?.siteClass?.glCode ?? "REVENUE_UNMAPPED";
    const revenueAccount = reservation.site?.siteClass?.clientAccount ?? "Revenue";
    const externalRef = options?.stripeBalanceTransactionId ?? options?.stripeChargeId ?? options?.stripePaymentIntentId ?? options?.transactionId ?? null;
    for (const tender of tenderList) {
      await this.prisma.payment.create({
        data: {
          campgroundId: reservation.campgroundId,
          reservationId: reservation.id,
          amountCents: tender.amountCents,
          method: tender.method || options?.paymentMethod || "card",
          direction: "charge",
          note: tender.note ?? "Reservation payment",
          stripePaymentIntentId: options?.stripePaymentIntentId,
          stripeChargeId: options?.stripeChargeId,
          stripeBalanceTransactionId: options?.stripeBalanceTransactionId,
          stripePayoutId: options?.stripePayoutId,
          applicationFeeCents: options?.applicationFeeCents,
          stripeFeeCents: options?.stripeFeeCents,
          methodType: options?.methodType,
          capturedAt: options?.capturedAt
        }
      });
      await postBalancedLedgerEntries(this.prisma, [
        {
          campgroundId: reservation.campgroundId,
          reservationId: reservation.id,
          glCode: "CASH",
          account: "Cash",
          description: options?.transactionId ? `Payment ${options.transactionId}` : `Reservation payment (${tender.method})`,
          amountCents: tender.amountCents,
          direction: "debit",
          externalRef,
          dedupeKey: externalRef ? `res:${reservation.id}:payment:${externalRef}:${tender.method}:debit` : `res:${reservation.id}:payment:${tender.method}:debit`
        },
        {
          campgroundId: reservation.campgroundId,
          reservationId: reservation.id,
          glCode: revenueGl,
          account: revenueAccount,
          description: `Reservation payment (${tender.method})`,
          amountCents: tender.amountCents,
          direction: "credit",
          externalRef,
          dedupeKey: externalRef ? `res:${reservation.id}:payment:${externalRef}:${tender.method}:credit` : `res:${reservation.id}:payment:${tender.method}:credit`
        }
      ]);
    }
    try {
      await this.emailService.sendPaymentReceipt({
        guestEmail: reservation.guest.email,
        guestName: `${reservation.guest.primaryFirstName} ${reservation.guest.primaryLastName}`,
        campgroundName: reservation.campground.name,
        amountCents: totalTenderCents,
        paymentMethod: options?.paymentMethod || (tenderList.length === 1 ? tenderList[0].method : "Mixed"),
        transactionId: options?.transactionId,
        reservationId: reservation.id,
        siteNumber: reservation.site?.siteNumber,
        arrivalDate: reservation.arrivalDate,
        departureDate: reservation.departureDate,
        source: options?.source || reservation.source || "admin",
        lineItems: options?.lineItems,
        taxCents: options?.taxCents,
        feeCents: options?.feeCents,
        totalCents: options?.totalCents ?? totalTenderCents,
        kind: options?.receiptKind ?? "payment"
      });
    } catch (emailError) {
      console.error("Failed to send payment receipt email:", emailError);
    }
    return updated;
  }
  async refundPayment(id, amountCents) {
    if (amountCents <= 0) throw new import_common35.BadRequestException("Refund amount must be positive");
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        site: { include: { siteClass: true } },
        guest: true,
        campground: { select: { name: true } }
      }
    });
    if (!reservation) throw new import_common35.NotFoundException("Reservation not found");
    if ((reservation.paidAmount ?? 0) < amountCents) {
      throw new import_common35.BadRequestException("Refund exceeds paid amount");
    }
    const newPaid = (reservation.paidAmount ?? 0) - amountCents;
    const paymentFields = this.buildPaymentFields(reservation.totalAmount, newPaid);
    const updated = await this.prisma.reservation.update({
      where: { id },
      data: {
        paidAmount: newPaid,
        ...paymentFields
      }
    });
    await this.prisma.payment.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        amountCents,
        method: "card",
        direction: "refund",
        note: "Reservation refund"
      }
    });
    const revenueGl = reservation.site?.siteClass?.glCode ?? "REVENUE_UNMAPPED";
    const revenueAccount = reservation.site?.siteClass?.clientAccount ?? "Revenue";
    await postBalancedLedgerEntries(this.prisma, [
      {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        glCode: "CASH",
        account: "Cash",
        description: "Reservation refund",
        amountCents,
        direction: "credit",
        dedupeKey: `res:${reservation.id}:refund:${amountCents}:credit`
      },
      {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        glCode: revenueGl,
        account: revenueAccount,
        description: "Reservation refund",
        amountCents,
        direction: "debit",
        dedupeKey: `res:${reservation.id}:refund:${amountCents}:debit`
      }
    ]);
    try {
      await this.emailService.sendPaymentReceipt({
        guestEmail: reservation?.guest?.email ?? "",
        guestName: reservation ? `${reservation?.guest?.primaryFirstName ?? ""} ${reservation?.guest?.primaryLastName ?? ""}`.trim() : "",
        campgroundName: reservation?.campground?.name ?? "Campground",
        amountCents,
        paymentMethod: "Card",
        transactionId: void 0,
        reservationId: reservation.id,
        siteNumber: reservation?.site?.siteNumber,
        arrivalDate: reservation?.arrivalDate,
        departureDate: reservation?.departureDate,
        source: reservation?.source ?? "admin",
        kind: "refund",
        totalCents: amountCents
      });
    } catch (err) {
      console.warn("Failed to send refund receipt email", err);
    }
    return updated;
  }
  /**
   * Record a refund that was already processed by Stripe.
   * This is called from webhooks or API endpoints after Stripe confirms the refund.
   * Unlike refundPayment(), this doesn't validate amounts since Stripe already processed it.
   */
  async recordRefund(id, amountCents, stripeRefundId, options) {
    if (amountCents <= 0) return;
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        site: { include: { siteClass: true } },
        guest: true,
        campground: { select: { name: true } }
      }
    });
    if (!reservation) {
      console.error(`[Stripe Refund] Reservation ${id} not found for refund recording`);
      return;
    }
    const newPaid = Math.max(0, (reservation.paidAmount ?? 0) - amountCents);
    const paymentFields = this.buildPaymentFields(reservation.totalAmount, newPaid);
    const updated = await this.prisma.reservation.update({
      where: { id },
      data: {
        paidAmount: newPaid,
        ...paymentFields
      }
    });
    await this.prisma.payment.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        amountCents,
        method: "card",
        direction: "refund",
        note: stripeRefundId ? `Stripe refund: ${stripeRefundId}` : "Stripe refund"
      }
    });
    const revenueGl = reservation.site?.siteClass?.glCode ?? "REVENUE_UNMAPPED";
    const revenueAccount = reservation.site?.siteClass?.clientAccount ?? "Revenue";
    const dedupeKeyBase = stripeRefundId ? `res:${reservation.id}:refund:${stripeRefundId}` : `res:${reservation.id}:refund:${amountCents}`;
    await postBalancedLedgerEntries(this.prisma, [
      {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        glCode: "CASH",
        account: "Cash",
        description: stripeRefundId ? `Stripe refund: ${stripeRefundId}` : "Stripe refund",
        amountCents,
        direction: "credit",
        externalRef: stripeRefundId ?? null,
        dedupeKey: `${dedupeKeyBase}:credit`
      },
      {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        glCode: revenueGl,
        account: revenueAccount,
        description: stripeRefundId ? `Stripe refund: ${stripeRefundId}` : "Stripe refund",
        amountCents,
        direction: "debit",
        externalRef: stripeRefundId ?? null,
        dedupeKey: `${dedupeKeyBase}:debit`
      }
    ]);
    try {
      await this.emailService.sendPaymentReceipt({
        guestEmail: reservation?.guest?.email ?? "",
        guestName: reservation ? `${reservation?.guest?.primaryFirstName ?? ""} ${reservation?.guest?.primaryLastName ?? ""}`.trim() : "",
        campgroundName: reservation?.campground?.name ?? "Campground",
        amountCents,
        paymentMethod: options?.paymentMethod ?? "Card",
        transactionId: stripeRefundId,
        reservationId: reservation.id,
        siteNumber: reservation?.site?.siteNumber,
        arrivalDate: reservation?.arrivalDate,
        departureDate: reservation?.departureDate,
        source: options?.source ?? "admin",
        kind: options?.receiptKind ?? "refund",
        lineItems: options?.lineItems,
        taxCents: options?.taxCents,
        feeCents: options?.feeCents,
        totalCents: options?.totalCents ?? amountCents
      });
    } catch (err) {
      console.warn("Failed to send refund receipt email", err);
    }
    return updated;
  }
  async quote(campgroundId, siteId, arrival, departure) {
    return this.computePrice(campgroundId, siteId, new Date(arrival), new Date(departure));
  }
  async agingBuckets(campgroundId) {
    const now = /* @__PURE__ */ new Date();
    const reservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        balanceAmount: { gt: 0 },
        NOT: { status: import_client7.ReservationStatus.cancelled }
      },
      select: { id: true, departureDate: true, balanceAmount: true }
    });
    const buckets = {
      current: 0,
      "31_60": 0,
      "61_90": 0,
      "90_plus": 0
    };
    for (const r of reservations) {
      const daysPast = Math.floor((now.getTime() - r.departureDate.getTime()) / (1e3 * 60 * 60 * 24));
      if (daysPast <= 30) buckets.current += r.balanceAmount;
      else if (daysPast <= 60) buckets["31_60"] += r.balanceAmount;
      else if (daysPast <= 90) buckets["61_90"] += r.balanceAmount;
      else buckets["90_plus"] += r.balanceAmount;
    }
    return buckets;
  }
  async listOverlaps(campgroundId) {
    return this.prisma.$queryRaw`
      SELECT
        a."siteId" as "siteId",
        a."id" as "reservationA",
        b."id" as "reservationB",
        a."arrivalDate" as "arrivalA",
        a."departureDate" as "departureA",
        b."arrivalDate" as "arrivalB",
        b."departureDate" as "departureB"
      FROM "Reservation" a
      JOIN "Reservation" b
        ON a."siteId" = b."siteId"
        AND a."id" < b."id"
        AND a."status" != 'cancelled'
        AND b."status" != 'cancelled'
        AND a."campgroundId" = ${campgroundId}
        AND b."campgroundId" = ${campgroundId}
        AND tstzrange(a."arrivalDate", a."departureDate", '[]'::text) && tstzrange(b."arrivalDate", b."departureDate", '[]'::text)
      ORDER BY a."siteId", a."arrivalDate"
    `;
  }
  async overlapCheck(campgroundId, siteId, arrivalDate, departureDate, ignoreId) {
    if (!siteId || !arrivalDate || !departureDate) {
      throw new import_common35.BadRequestException("siteId, arrivalDate, and departureDate are required");
    }
    const site = await this.prisma.site.findUnique({ where: { id: siteId }, select: { campgroundId: true } });
    if (!site) throw new import_common35.NotFoundException("Site not found");
    const arrival = new Date(arrivalDate);
    const departure = new Date(departureDate);
    if (!(arrival instanceof Date) || isNaN(arrival.valueOf()) || !(departure instanceof Date) || isNaN(departure.valueOf())) {
      throw new import_common35.BadRequestException("Invalid dates");
    }
    if (departure <= arrival) throw new import_common35.BadRequestException("departureDate must be after arrivalDate");
    const reasons = [];
    const conflictCount = await this.prisma.reservation.count({
      where: {
        campgroundId,
        siteId,
        status: { not: import_client7.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure },
        ...ignoreId ? { id: { not: ignoreId } } : {}
      }
    });
    if (conflictCount > 0) reasons.push("reservation");
    const now = /* @__PURE__ */ new Date();
    const holdCount = await this.prisma.siteHold.count({
      where: {
        siteId,
        status: "active",
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }],
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival }
      }
    });
    if (holdCount > 0) reasons.push("hold");
    const maintenanceCount = await this.prisma.maintenanceTicket.count({
      where: {
        siteId,
        status: { in: [import_client7.MaintenanceStatus.open, import_client7.MaintenanceStatus.in_progress] },
        OR: [
          { isBlocking: true },
          { outOfOrder: true },
          { outOfOrderUntil: { gt: arrival } }
        ]
      }
    });
    if (maintenanceCount > 0) reasons.push("maintenance");
    const blackoutCount = await this.prisma.blackoutDate.count({
      where: {
        campgroundId: site.campgroundId,
        OR: [{ siteId }, { siteId: null }],
        startDate: { lt: departure },
        endDate: { gt: arrival }
      }
    });
    if (blackoutCount > 0) reasons.push("blackout");
    return { conflict: reasons.length > 0, reasons };
  }
  async kioskCheckIn(id, upsellTotalCents, options) {
    console.log(`[Kiosk] Check-in request for ${id}, upsell: ${upsellTotalCents}`);
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        guest: true,
        campground: true,
        site: true
      }
    });
    if (!reservation) {
      console.error(`[Kiosk] Reservation ${id} not found`);
      throw new import_common35.NotFoundException("Reservation not found");
    }
    console.log(`[Kiosk] Found reservation: ${reservation.status}, Total: ${reservation.totalAmount}, Paid: ${reservation.paidAmount}`);
    if (reservation.status === import_client7.ReservationStatus.checked_in) {
      console.warn(`[Kiosk] Reservation ${id} already checked in`);
      throw new import_common35.ConflictException("Reservation is already checked in");
    }
    const pendingForms = await this.prisma.formSubmission?.count?.({
      where: { reservationId: id, status: "pending" }
    }) ?? 0;
    if (pendingForms > 0) {
      throw new import_common35.ConflictException("Forms must be completed before check-in");
    }
    const compliance = await this.checkCompliance(reservation);
    const isOverride = Boolean(options?.override);
    if (!compliance.ok && !isOverride) {
      const checkInStatus = compliance.reason === "waiver_required" ? import_client7.CheckInStatus.pending_waiver : compliance.reason === "id_verification_required" ? import_client7.CheckInStatus.pending_id : compliance.reason === "payment_required" ? import_client7.CheckInStatus.pending_payment : import_client7.CheckInStatus.failed;
      await this.prisma.reservation.update({
        where: { id },
        data: { checkInStatus }
      });
      throw new import_common35.ConflictException({
        reason: compliance.reason,
        signingUrl: compliance.signingUrl
      });
    }
    if (isOverride && !compliance.ok) {
      try {
        await this.audit.record({
          campgroundId: reservation.campgroundId,
          actorId: options?.actorId ?? null,
          action: "checkin.override",
          entity: "Reservation",
          entityId: id,
          before: { unmet: compliance.reasons ?? [] },
          after: { override: true, reason: options?.overrideReason ?? null }
        });
      } catch (err) {
        console.error("[Kiosk] Failed to audit check-in override", err);
      }
    }
    const newTotal = reservation.totalAmount + upsellTotalCents;
    const balanceDue = newTotal - (reservation.paidAmount || 0);
    console.log(`[Kiosk] New Total: ${newTotal}, Balance Due: ${balanceDue}`);
    try {
      const now = /* @__PURE__ */ new Date();
      const overrideNote = isOverride ? `[Override ${now.toISOString()}] ${options?.overrideReason ?? "No reason provided"}` : null;
      const kioskNote = `[Kiosk] Checked in${isOverride ? " (override)" : ""}. Upsell: $${(upsellTotalCents / 100).toFixed(2)}. Charged card on file.`;
      const notes = [reservation.notes, overrideNote, kioskNote].filter(Boolean).join("\n");
      const updated = await this.prisma.reservation.update({
        where: { id },
        data: {
          status: import_client7.ReservationStatus.checked_in,
          checkInStatus: import_client7.CheckInStatus.completed,
          checkInAt: now,
          feesAmount: { increment: upsellTotalCents },
          totalAmount: newTotal,
          paidAmount: newTotal,
          // Assume full payment successful
          // Add a note about the upsell/kiosk check-in
          notes
        }
      });
      console.log(`[Kiosk] Check-in successful for ${id}`);
      try {
        await this.accessControl.autoGrantForReservation(id, options?.actorId ?? null);
      } catch (err) {
        console.error(`[Kiosk] Access grant failed for ${id}:`, err);
      }
      if (reservation.createdBy) {
        const membership = await this.prisma.campgroundMembership.findFirst({
          where: { userId: reservation.createdBy, campgroundId: reservation.campgroundId }
        });
        await this.gamification.recordEvent({
          campgroundId: reservation.campgroundId,
          userId: reservation.createdBy,
          membershipId: membership?.id,
          category: import_client7.GamificationEventCategory.check_in,
          reason: "Smooth check-in (kiosk)",
          sourceType: "reservation",
          sourceId: reservation.id,
          eventKey: `reservation:${reservation.id}:checkin`
        });
      }
      return updated;
    } catch (e) {
      console.error(`[Kiosk] Update failed for ${id}:`, e);
      throw e;
    }
  }
};
__decorateClass([
  (0, import_schedule2.Cron)("0 */12 * * *")
], ReservationsService.prototype, "enqueueUnpaidSweep", 1);
ReservationsService = __decorateClass([
  (0, import_common35.Injectable)()
], ReservationsService);

// src/reservations/reservations.controller.ts
var import_common36 = require("@nestjs/common");
var ReservationsController = class {
  constructor(reservations, importExport) {
    this.reservations = reservations;
    this.importExport = importExport;
  }
  list(campgroundId) {
    return this.reservations.listByCampground(campgroundId);
  }
  importSchema() {
    return this.importExport.importSchema();
  }
  async importReservations(campgroundId, body, req) {
    const format = body.format ?? "json";
    return this.importExport.startImport({
      campgroundId,
      format,
      payload: body.payload,
      dryRun: body.dryRun ?? false,
      idempotencyKey: body.idempotencyKey ?? req?.headers?.["idempotency-key"],
      filename: body.filename,
      requestedById: req?.user?.id ?? null
    });
  }
  importStatus(campgroundId, jobId) {
    return this.importExport.getImportStatus(campgroundId, jobId);
  }
  async exportReservations(campgroundId, format, pageSize, paginationToken, includePII, status, source) {
    const filters = {};
    if (status) filters.status = status;
    if (source) filters.source = source;
    return this.importExport.exportReservations({
      campgroundId,
      format: format ?? "json",
      pageSize: pageSize ? Number(pageSize) : void 0,
      paginationToken: paginationToken ?? void 0,
      includePII: includePII === "true",
      filters
    });
  }
  listReservationExports(campgroundId, limit) {
    return this.importExport.listExports(campgroundId, limit ? Number(limit) : 10);
  }
  queueReservationExport(campgroundId, body, req) {
    return this.importExport.queueExport(campgroundId, body.filters, body.format ?? "json", req?.user?.id ?? null);
  }
  availability(campgroundId, arrivalDate, departureDate, rigType, rigLength) {
    return this.reservations.searchAvailability(campgroundId, arrivalDate, departureDate, rigType, rigLength);
  }
  sitesWithStatus(campgroundId, arrivalDate, departureDate) {
    return this.reservations.getSitesWithStatus(campgroundId, arrivalDate, departureDate);
  }
  overlaps(campgroundId) {
    return this.reservations.listOverlaps(campgroundId);
  }
  overlapCheck(campgroundId, siteId, arrivalDate, departureDate, ignoreId) {
    return this.reservations.overlapCheck(campgroundId, siteId, arrivalDate, departureDate, ignoreId);
  }
  getById(id) {
    return this.reservations.findOne(id);
  }
  calculateDeposit(id) {
    return this.reservations.calculateDeposit(id);
  }
  create(body) {
    return this.reservations.create(body);
  }
  update(id, body) {
    return this.reservations.update(id, body);
  }
  updateGroup(id, body) {
    return this.reservations.updateGroupAssignment(id, body);
  }
  quote(campgroundId, body) {
    return this.reservations.quote(campgroundId, body.siteId, body.arrivalDate, body.departureDate);
  }
  aging(campgroundId) {
    return this.reservations.agingBuckets(campgroundId);
  }
  pay(id, body) {
    return this.reservations.recordPayment(id, body.amountCents, { tenders: body.tenders });
  }
  refund(id, body) {
    return this.reservations.refundPayment(id, body.amountCents);
  }
  remove(id) {
    return this.reservations.remove(id);
  }
  kioskCheckIn(id, body) {
    return this.reservations.kioskCheckIn(id, body.upsellTotalCents || 0, {
      override: body.override,
      overrideReason: body.overrideReason,
      actorId: body.actorId ?? null
    });
  }
  getMatches(campgroundId, guestId) {
    return this.reservations.getMatchedSites(campgroundId, guestId);
  }
};
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId"))
], ReservationsController.prototype, "list", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/import/schema")
], ReservationsController.prototype, "importSchema", 1);
__decorateClass([
  (0, import_common36.Post)("campgrounds/:campgroundId/reservations/import"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Body)()),
  __decorateParam(2, (0, import_common36.Req)())
], ReservationsController.prototype, "importReservations", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/import/:jobId"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Param)("jobId"))
], ReservationsController.prototype, "importStatus", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/export"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("format")),
  __decorateParam(2, (0, import_common36.Query)("pageSize")),
  __decorateParam(3, (0, import_common36.Query)("paginationToken")),
  __decorateParam(4, (0, import_common36.Query)("includePII")),
  __decorateParam(5, (0, import_common36.Query)("status")),
  __decorateParam(6, (0, import_common36.Query)("source"))
], ReservationsController.prototype, "exportReservations", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/export/jobs"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("limit"))
], ReservationsController.prototype, "listReservationExports", 1);
__decorateClass([
  (0, import_common36.Post)("campgrounds/:campgroundId/reservations/export/jobs"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Body)()),
  __decorateParam(2, (0, import_common36.Req)())
], ReservationsController.prototype, "queueReservationExport", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/availability"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("arrivalDate")),
  __decorateParam(2, (0, import_common36.Query)("departureDate")),
  __decorateParam(3, (0, import_common36.Query)("rigType")),
  __decorateParam(4, (0, import_common36.Query)("rigLength"))
], ReservationsController.prototype, "availability", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/sites/status"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("arrivalDate")),
  __decorateParam(2, (0, import_common36.Query)("departureDate"))
], ReservationsController.prototype, "sitesWithStatus", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/overlaps"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId"))
], ReservationsController.prototype, "overlaps", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/reservations/overlap-check"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("siteId")),
  __decorateParam(2, (0, import_common36.Query)("arrivalDate")),
  __decorateParam(3, (0, import_common36.Query)("departureDate")),
  __decorateParam(4, (0, import_common36.Query)("ignoreId"))
], ReservationsController.prototype, "overlapCheck", 1);
__decorateClass([
  (0, import_common36.Get)("reservations/:id"),
  __decorateParam(0, (0, import_common36.Param)("id"))
], ReservationsController.prototype, "getById", 1);
__decorateClass([
  (0, import_common36.Get)("reservations/:id/calculate-deposit"),
  __decorateParam(0, (0, import_common36.Param)("id"))
], ReservationsController.prototype, "calculateDeposit", 1);
__decorateClass([
  (0, import_common36.Post)("reservations"),
  __decorateParam(0, (0, import_common36.Body)())
], ReservationsController.prototype, "create", 1);
__decorateClass([
  (0, import_common36.Patch)("reservations/:id"),
  __decorateParam(0, (0, import_common36.Param)("id")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "update", 1);
__decorateClass([
  (0, import_common36.Patch)("reservations/:id/group"),
  __decorateParam(0, (0, import_common36.Param)("id")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "updateGroup", 1);
__decorateClass([
  (0, import_common36.Post)("campgrounds/:campgroundId/quote"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "quote", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/aging"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId"))
], ReservationsController.prototype, "aging", 1);
__decorateClass([
  (0, import_common36.Post)("reservations/:id/payments"),
  __decorateParam(0, (0, import_common36.Param)("id")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "pay", 1);
__decorateClass([
  (0, import_common36.Post)("reservations/:id/refunds"),
  __decorateParam(0, (0, import_common36.Param)("id")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "refund", 1);
__decorateClass([
  (0, import_common36.Delete)("reservations/:id"),
  __decorateParam(0, (0, import_common36.Param)("id"))
], ReservationsController.prototype, "remove", 1);
__decorateClass([
  (0, import_common36.Post)("reservations/:id/kiosk-checkin"),
  __decorateParam(0, (0, import_common36.Param)("id")),
  __decorateParam(1, (0, import_common36.Body)())
], ReservationsController.prototype, "kioskCheckIn", 1);
__decorateClass([
  (0, import_common36.Get)("campgrounds/:campgroundId/matches"),
  __decorateParam(0, (0, import_common36.Param)("campgroundId")),
  __decorateParam(1, (0, import_common36.Query)("guestId"))
], ReservationsController.prototype, "getMatches", 1);
ReservationsController = __decorateClass([
  (0, import_common36.UseGuards)(JwtAuthGuard),
  (0, import_common36.Controller)()
], ReservationsController);

// src/pricing/pricing.service.ts
var import_common37 = require("@nestjs/common");
var import_crypto4 = require("crypto");
var PricingService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  listByCampground(campgroundId) {
    return this.prisma.pricingRule.findMany({
      where: { campgroundId },
      orderBy: [{ isActive: "desc" }, { startDate: "asc" }, { createdAt: "desc" }]
    });
  }
  async create(campgroundId, dto) {
    const rule = await this.prisma.pricingRule.create({
      data: {
        ...dto,
        campgroundId,
        siteClassId: dto.siteClassId || null,
        startDate: dto.startDate ? new Date(dto.startDate) : null,
        endDate: dto.endDate ? new Date(dto.endDate) : null
      }
    });
    await this.prisma.analyticsEvent.create({
      data: {
        sessionId: (0, import_crypto4.randomUUID)(),
        eventName: "admin_pricing_change",
        campground: { connect: { id: campgroundId } },
        metadata: { action: "create", ruleId: rule.id, label: dto.label, ruleType: dto.ruleType, percentAdjust: dto.percentAdjust, flatAdjust: dto.flatAdjust }
      }
    });
    return rule;
  }
  async update(id, dto) {
    const exists = await this.prisma.pricingRule.findUnique({ where: { id } });
    if (!exists) throw new import_common37.NotFoundException("Pricing rule not found");
    const rule = await this.prisma.pricingRule.update({
      where: { id },
      data: {
        ...dto,
        siteClassId: dto.siteClassId === void 0 ? void 0 : dto.siteClassId || null,
        startDate: dto.startDate === void 0 ? void 0 : dto.startDate ? new Date(dto.startDate) : null,
        endDate: dto.endDate === void 0 ? void 0 : dto.endDate ? new Date(dto.endDate) : null
      }
    });
    await this.prisma.analyticsEvent.create({
      data: {
        sessionId: (0, import_crypto4.randomUUID)(),
        eventName: "admin_pricing_change",
        campground: exists.campgroundId ? { connect: { id: exists.campgroundId } } : void 0,
        metadata: { action: "update", ruleId: rule.id }
      }
    });
    return rule;
  }
  remove(id) {
    return this.prisma.$transaction(async (tx) => {
      const existing = await tx.pricingRule.findUnique({ where: { id } });
      const res = await tx.pricingRule.delete({ where: { id } });
      if (existing?.campgroundId) {
        await tx.analyticsEvent.create({
          data: {
            sessionId: (0, import_crypto4.randomUUID)(),
            eventName: "admin_pricing_change",
            campground: { connect: { id: existing.campgroundId } },
            metadata: { action: "delete", ruleId: id }
          }
        });
      }
      return res;
    });
  }
};
PricingService = __decorateClass([
  (0, import_common37.Injectable)()
], PricingService);

// src/redis/redis.service.ts
var import_common38 = require("@nestjs/common");
var import_ioredis = __toESM(require("ioredis"));
var RedisService = class {
  constructor() {
    this.logger = new import_common38.Logger(RedisService.name);
    const url = process.env.PLATFORM_REDIS_URL;
    this.client = url ? new import_ioredis.default(url) : null;
    if (this.client) {
      this.client.on("connect", () => this.logger.log("Redis connected"));
      this.client.on("error", (err) => this.logger.error("Redis error", err));
    } else {
      this.logger.warn("Redis is not configured (PLATFORM_REDIS_URL not set)");
    }
  }
  get isEnabled() {
    return !!this.client;
  }
  /**
   * Expose the underlying client for helper services (locks, queues).
   * Returns null when Redis is not configured so callers can noop gracefully.
   */
  getClient() {
    return this.client;
  }
  async ping() {
    if (!this.client) return null;
    return this.client.ping();
  }
  /**
   * Get a value from cache
   */
  async get(key) {
    if (!this.client) return null;
    const value = await this.client.get(key);
    if (!value) return null;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  /**
   * Set a value in cache with optional TTL (in seconds)
   */
  async set(key, value, ttl) {
    if (!this.client) return;
    const serialized = typeof value === "string" ? value : JSON.stringify(value);
    if (ttl) {
      await this.client.setex(key, ttl, serialized);
    } else {
      await this.client.set(key, serialized);
    }
  }
  /**
   * Delete a key from cache
   */
  async del(key) {
    if (!this.client) return;
    await this.client.del(key);
  }
  /**
   * Delete multiple keys matching a pattern
   */
  async delPattern(pattern) {
    if (!this.client) return;
    const keys = await this.client.keys(pattern);
    if (keys.length > 0) {
      await this.client.del(...keys);
    }
  }
  /**
   * Check if a key exists
   */
  async exists(key) {
    if (!this.client) return false;
    const result = await this.client.exists(key);
    return result === 1;
  }
  /**
   * Set expiration time on a key (in seconds)
   */
  async expire(key, ttl) {
    if (!this.client) return;
    await this.client.expire(key, ttl);
  }
  /**
   * Increment a counter
   */
  async incr(key) {
    if (!this.client) return null;
    return this.client.incr(key);
  }
  /**
   * Decrement a counter
   */
  async decr(key) {
    if (!this.client) return null;
    return this.client.decr(key);
  }
  async onModuleDestroy() {
    if (this.client) {
      await this.client.quit();
      this.logger.log("Redis connection closed");
    }
  }
};
RedisService = __decorateClass([
  (0, import_common38.Injectable)()
], RedisService);

// src/redis/lock.service.ts
var import_common39 = require("@nestjs/common");
var import_crypto5 = require("crypto");
var LockService = class {
  // 5 minutes
  constructor(redis) {
    this.redis = redis;
    this.ttlMs = 5 * 60 * 1e3;
  }
  async release(client, locks) {
    if (!client || !locks.length) return;
    const lua = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    await Promise.all(
      locks.map(
        (lock) => client.eval(lua, 1, lock.key, lock.token).catch(() => null)
      )
    );
  }
  async withLocks(keys, fn) {
    const client = this.redis.getClient();
    const uniqueKeys = Array.from(new Set(keys.filter(Boolean))).sort();
    if (!client || uniqueKeys.length === 0) {
      return fn();
    }
    const heldLocks = [];
    try {
      for (const key of uniqueKeys) {
        const lockKey = `lock:site:${key}`;
        const token = (0, import_crypto5.randomUUID)();
        const acquired = await client.set(lockKey, token, "PX", this.ttlMs, "NX");
        if (!acquired) {
          throw new import_common39.ConflictException("Site is locked by another booking. Try again in a moment.");
        }
        heldLocks.push({ key: lockKey, token });
      }
      return await fn();
    } finally {
      await this.release(client, heldLocks);
    }
  }
};
LockService = __decorateClass([
  (0, import_common39.Injectable)()
], LockService);

// src/promotions/promotions.service.ts
var import_common40 = require("@nestjs/common");
var PromotionsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(data) {
    const normalizedCode = data.code.toUpperCase().trim();
    return this.prisma.promotion.create({
      data: {
        campgroundId: data.campgroundId,
        code: normalizedCode,
        type: data.type || "percentage",
        value: data.value,
        validFrom: data.validFrom ? new Date(data.validFrom) : null,
        validTo: data.validTo ? new Date(data.validTo) : null,
        usageLimit: data.usageLimit || null,
        isActive: data.isActive ?? true,
        description: data.description || null
      }
    });
  }
  async findAll(campgroundId) {
    return this.prisma.promotion.findMany({
      where: { campgroundId },
      orderBy: [{ isActive: "desc" }, { createdAt: "desc" }]
    });
  }
  async findOne(id) {
    const promotion = await this.prisma.promotion.findUnique({
      where: { id }
    });
    if (!promotion) throw new import_common40.NotFoundException("Promotion not found");
    return promotion;
  }
  async update(id, data) {
    await this.findOne(id);
    return this.prisma.promotion.update({
      where: { id },
      data: {
        code: data.code ? data.code.toUpperCase().trim() : void 0,
        type: data.type,
        value: data.value,
        validFrom: data.validFrom !== void 0 ? data.validFrom ? new Date(data.validFrom) : null : void 0,
        validTo: data.validTo !== void 0 ? data.validTo ? new Date(data.validTo) : null : void 0,
        usageLimit: data.usageLimit,
        isActive: data.isActive,
        description: data.description
      }
    });
  }
  async remove(id) {
    await this.findOne(id);
    return this.prisma.promotion.delete({ where: { id } });
  }
  /**
   * Validate a promo code and calculate the discount amount.
   * Returns the discount in cents.
   */
  async validate(data) {
    const normalizedCode = data.code.toUpperCase().trim();
    const now = /* @__PURE__ */ new Date();
    const promotion = await this.prisma.promotion.findUnique({
      where: {
        campgroundId_code: {
          campgroundId: data.campgroundId,
          code: normalizedCode
        }
      }
    });
    if (!promotion) {
      throw new import_common40.BadRequestException("Invalid promo code");
    }
    if (!promotion.isActive) {
      throw new import_common40.BadRequestException("This promo code is no longer active");
    }
    if (promotion.validFrom && now < promotion.validFrom) {
      throw new import_common40.BadRequestException("This promo code is not yet valid");
    }
    if (promotion.validTo && now > promotion.validTo) {
      throw new import_common40.BadRequestException("This promo code has expired");
    }
    if (promotion.usageLimit && promotion.usageCount >= promotion.usageLimit) {
      throw new import_common40.BadRequestException("This promo code has reached its usage limit");
    }
    let discountCents = 0;
    if (promotion.type === "percentage") {
      discountCents = Math.round(data.subtotal * (promotion.value / 100));
    } else {
      discountCents = Math.min(promotion.value, data.subtotal);
    }
    return {
      valid: true,
      discountCents,
      promotionId: promotion.id,
      code: promotion.code,
      type: promotion.type,
      value: promotion.value
    };
  }
  /**
   * Increment the usage count for a promotion (called when a reservation is created with a promo code)
   */
  async incrementUsage(promotionId) {
    return this.prisma.promotion.update({
      where: { id: promotionId },
      data: {
        usageCount: { increment: 1 }
      }
    });
  }
};
PromotionsService = __decorateClass([
  (0, import_common40.Injectable)()
], PromotionsService);

// src/access-control/access-control.module.ts
var import_common46 = require("@nestjs/common");

// src/payments/idempotency.service.ts
var import_common41 = require("@nestjs/common");
var import_client8 = require("@prisma/client");
var crypto = __toESM(require("crypto"));
var IdempotencyService = class {
  constructor(prisma, redis) {
    this.prisma = prisma;
    this.redis = redis;
    this.defaultTtlSeconds = Number(process.env.IDEMPOTENCY_TTL_SECONDS ?? 72 * 60 * 60);
    this.rateLimitDefault = Number(process.env.IDEMPOTENCY_RATE_LIMIT ?? 60);
    this.rateWindowSeconds = Number(process.env.IDEMPOTENCY_RATE_WINDOW_SEC ?? 60);
    this.scopeCache = /* @__PURE__ */ new Map();
    this.memoryCounters = /* @__PURE__ */ new Map();
  }
  stableStringify(value) {
    if (value === null || value === void 0) return "null";
    if (typeof value !== "object") return JSON.stringify(value);
    if (Array.isArray(value)) {
      return `[${value.map((v) => this.stableStringify(v)).join(",")}]`;
    }
    const keys = Object.keys(value).sort();
    return `{${keys.map((k) => `${JSON.stringify(k)}:${this.stableStringify(value[k])}`).join(",")}}`;
  }
  hashRequest(body) {
    const normalized = typeof body === "string" ? body : this.stableStringify(body ?? {});
    return crypto.createHash("sha256").update(normalized).digest("hex");
  }
  scopeKey(tenantId, campgroundId) {
    return tenantId ?? campgroundId ?? "global";
  }
  computeExpiry(ttlSeconds) {
    const ttl = ttlSeconds ?? this.defaultTtlSeconds;
    return ttl > 0 ? new Date(Date.now() + ttl * 1e3) : null;
  }
  isExpired(expiresAt) {
    return Boolean(expiresAt && expiresAt.getTime() < Date.now());
  }
  normalizeSequence(sequence) {
    if (sequence === void 0 || sequence === null) return null;
    return String(sequence);
  }
  cacheScope(key, scope) {
    this.scopeCache.set(key, scope);
    if (this.scopeCache.size > 5e3) {
      const firstKey = this.scopeCache.keys().next().value;
      if (firstKey) this.scopeCache.delete(firstKey);
    }
  }
  rateLimitError() {
    if (typeof import_common41.TooManyRequestsException === "function") {
      return new import_common41.TooManyRequestsException("Idempotency rate limit exceeded");
    }
    return new import_common41.ConflictException("Idempotency rate limit exceeded");
  }
  async touchRecord(id) {
    await this.prisma.idempotencyRecord.update({
      where: { id },
      data: { lastSeenAt: /* @__PURE__ */ new Date() }
    }).catch(() => null);
  }
  ensureHashConsistency(existing, requestHash, checksum) {
    if (existing.requestHash && existing.requestHash !== requestHash) {
      throw new import_common41.ConflictException("Idempotency key reused with different payload");
    }
    if (checksum && existing.checksum && existing.checksum !== checksum) {
      throw new import_common41.ConflictException("Idempotency checksum mismatch");
    }
  }
  async enforceRateLimit(scope, action) {
    const windowSeconds = this.rateWindowSeconds > 0 ? this.rateWindowSeconds : 60;
    const max = this.rateLimitDefault > 0 ? this.rateLimitDefault : 60;
    const windowBucket = Math.floor(Date.now() / (windowSeconds * 1e3));
    const key = `idemp:${scope}:${action}:${windowBucket}`;
    if (this.redis?.isEnabled) {
      const client = this.redis.getClient();
      if (client) {
        const count = await client.incr(key);
        if (count === 1) {
          await client.expire(key, windowSeconds);
        }
        if (count > max) {
          throw this.rateLimitError();
        }
        return;
      }
    }
    const now = Date.now();
    const cached = this.memoryCounters.get(key);
    if (!cached || cached.expiresAt < now) {
      this.memoryCounters.set(key, { count: 1, expiresAt: now + windowSeconds * 1e3 });
      return;
    }
    cached.count += 1;
    if (cached.count > max) {
      throw this.rateLimitError();
    }
  }
  /**
   * Start or reuse an idempotency record. Applies per-scope rate limiting.
   */
  async start(key, body, campgroundId, options) {
    const opts = options ?? {};
    const scope = this.scopeKey(opts.tenantId ?? null, opts.campgroundId ?? campgroundId ?? null);
    await this.enforceRateLimit(scope, opts.rateAction ?? "lookup");
    const requestHash = this.hashRequest(body ?? opts.requestBody ?? {});
    const checksum = opts.checksum ?? requestHash;
    const normalizedSequence = this.normalizeSequence(opts.sequence);
    const endpoint = opts.endpoint ?? "unknown";
    if (normalizedSequence) {
      const seqExisting = await this.prisma.idempotencyRecord.findFirst({
        where: { scope, endpoint, sequence: normalizedSequence }
      }).catch(() => null);
      if (seqExisting && !this.isExpired(seqExisting.expiresAt)) {
        this.ensureHashConsistency(seqExisting, requestHash, opts.checksum);
        this.cacheScope(key, seqExisting.scope);
        if (seqExisting.status === import_client8.IdempotencyStatus.succeeded && seqExisting.responseJson) {
          return seqExisting;
        }
        if (seqExisting.status === import_client8.IdempotencyStatus.inflight) {
          throw new import_common41.ConflictException("Request already in progress");
        }
      }
    }
    let existing = await this.prisma.idempotencyRecord.findUnique({
      where: { scope_idempotencyKey: { scope, idempotencyKey: key } }
    }).catch(() => null);
    if (existing) {
      this.ensureHashConsistency(existing, requestHash, opts.checksum);
      if (this.isExpired(existing.expiresAt)) {
        existing = await this.prisma.idempotencyRecord.update({
          where: { id: existing.id },
          data: {
            requestHash,
            checksum,
            requestBody: opts.requestBody ?? body ?? existing.requestBody,
            status: import_client8.IdempotencyStatus.inflight,
            expiresAt: this.computeExpiry(opts.ttlSeconds),
            lastSeenAt: /* @__PURE__ */ new Date()
          }
        });
      } else {
        await this.touchRecord(existing.id);
      }
      this.cacheScope(key, scope);
      return existing;
    }
    const created = await this.prisma.idempotencyRecord.create({
      data: {
        scope,
        tenantId: opts.tenantId ?? void 0,
        campgroundId: opts.campgroundId ?? campgroundId ?? void 0,
        endpoint,
        idempotencyKey: key,
        requestHash,
        checksum,
        requestBody: opts.requestBody ?? body ?? {},
        responseJson: null,
        status: import_client8.IdempotencyStatus.inflight,
        sequence: normalizedSequence,
        expiresAt: this.computeExpiry(opts.ttlSeconds),
        lastSeenAt: /* @__PURE__ */ new Date(),
        metadata: opts.metadata ?? void 0
      }
    });
    this.cacheScope(key, scope);
    return created;
  }
  /**
   * Complete an idempotent call by persisting the response snapshot.
   */
  async complete(key, response) {
    const updated = await this.updateRecord(key, {
      status: import_client8.IdempotencyStatus.succeeded,
      responseJson: response,
      lastSeenAt: /* @__PURE__ */ new Date()
    });
    if (updated) return updated;
    return this.prisma.idempotencyKey.update({
      where: { key },
      data: {
        status: import_client8.IdempotencyStatus.succeeded,
        responseJson: response,
        lastSeenAt: /* @__PURE__ */ new Date()
      }
    });
  }
  /**
   * Mark an idempotent call as failed.
   */
  async fail(key) {
    const updated = await this.updateRecord(key, {
      status: import_client8.IdempotencyStatus.failed,
      lastSeenAt: /* @__PURE__ */ new Date()
    });
    if (updated) return updated;
    return this.prisma.idempotencyKey.update({
      where: { key },
      data: {
        status: import_client8.IdempotencyStatus.failed,
        lastSeenAt: /* @__PURE__ */ new Date()
      }
    });
  }
  /**
   * Locate an existing record by sequence for replay dedupe.
   */
  async findBySequence(scope, endpoint, sequence) {
    if (sequence === void 0 || sequence === null) return null;
    await this.enforceRateLimit(scope, "lookup");
    return this.prisma.idempotencyRecord.findFirst({
      where: { scope, endpoint, sequence: String(sequence) }
    });
  }
  /**
   * Apply rate limiting without creating an idempotency record.
   */
  async throttleScope(campgroundId, tenantId, action = "lookup") {
    const scope = this.scopeKey(tenantId ?? null, campgroundId ?? null);
    await this.enforceRateLimit(scope, action);
  }
  async updateRecord(key, data) {
    const scope = this.scopeCache.get(key);
    if (scope) {
      const result = await this.prisma.idempotencyRecord.update({
        where: { scope_idempotencyKey: { scope, idempotencyKey: key } },
        data
      }).catch(() => null);
      if (result) return result;
    }
    const updated = await this.prisma.idempotencyRecord.updateMany({
      where: { idempotencyKey: key },
      data
    });
    if (updated.count > 0) {
      return this.prisma.idempotencyRecord.findFirst({ where: { idempotencyKey: key } });
    }
    return null;
  }
};
IdempotencyService = __decorateClass([
  (0, import_common41.Injectable)()
], IdempotencyService);

// src/access-control/access-control.controller.ts
var import_common42 = require("@nestjs/common");
var AccessControlController = class {
  constructor(service) {
    this.service = service;
  }
  getStatus(reservationId) {
    return this.service.getAccessStatus(reservationId);
  }
  upsertVehicle(reservationId, dto) {
    return this.service.upsertVehicle(reservationId, dto);
  }
  grant(reservationId, dto) {
    return this.service.grantAccess(reservationId, dto);
  }
  revoke(reservationId, dto) {
    return this.service.revokeAccess(reservationId, dto);
  }
  listProviders(req) {
    return this.service.listIntegrations(req.user?.campgroundId ?? req.campgroundId ?? null);
  }
  upsertProvider(provider, dto, req) {
    return this.service.upsertIntegration(req.user?.campgroundId ?? req.campgroundId ?? null, {
      ...dto,
      provider
    });
  }
  async webhook(provider, body, signature, req) {
    const rawBody = req.rawBody ? req.rawBody.toString() : JSON.stringify(body ?? {});
    const acknowledged = await this.service.verifyWebhook(
      provider,
      signature ?? body?.signature,
      rawBody,
      req.headers["x-campground-id"]
    );
    return { acknowledged, provider };
  }
};
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Get)("/reservations/:reservationId/access"),
  __decorateParam(0, (0, import_common42.Param)("reservationId"))
], AccessControlController.prototype, "getStatus", 1);
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Post)("/reservations/:reservationId/access/vehicle"),
  __decorateParam(0, (0, import_common42.Param)("reservationId")),
  __decorateParam(1, (0, import_common42.Body)())
], AccessControlController.prototype, "upsertVehicle", 1);
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Post)("/reservations/:reservationId/access/grant"),
  __decorateParam(0, (0, import_common42.Param)("reservationId")),
  __decorateParam(1, (0, import_common42.Body)())
], AccessControlController.prototype, "grant", 1);
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Post)("/reservations/:reservationId/access/revoke"),
  __decorateParam(0, (0, import_common42.Param)("reservationId")),
  __decorateParam(1, (0, import_common42.Body)())
], AccessControlController.prototype, "revoke", 1);
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Get)("/access/providers"),
  __decorateParam(0, (0, import_common42.Req)())
], AccessControlController.prototype, "listProviders", 1);
__decorateClass([
  (0, import_common42.UseGuards)(JwtAuthGuard),
  (0, import_common42.Post)("/access/providers/:provider/config"),
  __decorateParam(0, (0, import_common42.Param)("provider")),
  __decorateParam(1, (0, import_common42.Body)()),
  __decorateParam(2, (0, import_common42.Req)())
], AccessControlController.prototype, "upsertProvider", 1);
__decorateClass([
  (0, import_common42.Post)("/access/webhooks/:provider"),
  __decorateParam(0, (0, import_common42.Param)("provider")),
  __decorateParam(1, (0, import_common42.Body)()),
  __decorateParam(2, (0, import_common42.Headers)("x-signature")),
  __decorateParam(3, (0, import_common42.Req)())
], AccessControlController.prototype, "webhook", 1);
AccessControlController = __decorateClass([
  (0, import_common42.Controller)()
], AccessControlController);

// src/access-control/access-control.service.ts
var import_common43 = require("@nestjs/common");
var import_client9 = require("@prisma/client");
var crypto2 = __toESM(require("crypto"));
var AccessControlService = class {
  constructor(prisma, registry, idempotency, audit) {
    this.prisma = prisma;
    this.registry = registry;
    this.idempotency = idempotency;
    this.audit = audit;
  }
  grantsRepo() {
    return this.prisma.accessGrant;
  }
  credentialsRepo() {
    return this.prisma.accessCredential;
  }
  vehiclesRepo() {
    return this.prisma.vehicle;
  }
  integrationsRepo() {
    return this.prisma.accessIntegration;
  }
  toDate(value) {
    if (!value) return null;
    const d = new Date(value);
    return isNaN(d.getTime()) ? null : d;
  }
  async getAccessStatus(reservationId) {
    const [vehicle, grants] = await Promise.all([
      this.vehiclesRepo()?.findFirst?.({ where: { reservationId } }),
      this.grantsRepo()?.findMany?.({
        where: { reservationId },
        orderBy: { createdAt: "desc" }
      })
    ]);
    return { vehicle, grants: grants ?? [] };
  }
  async upsertVehicle(reservationId, dto) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: { id: true, campgroundId: true, guestId: true }
    });
    if (!reservation) throw new import_common43.NotFoundException("Reservation not found");
    const repo = this.vehiclesRepo();
    const existing = await repo.findFirst({ where: { reservationId } });
    const vehicle = existing ? await repo.update({
      where: { id: existing.id },
      data: {
        plate: dto.plate ?? existing.plate,
        state: dto.state ?? existing.state,
        rigType: dto.rigType ?? existing.rigType,
        rigLength: dto.rigLength ?? existing.rigLength,
        description: dto.description ?? existing.description
      }
    }) : await repo.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId,
        guestId: reservation.guestId,
        plate: dto.plate,
        state: dto.state,
        rigType: dto.rigType,
        rigLength: dto.rigLength,
        description: dto.description
      }
    });
    await this.prisma.reservation.update({
      where: { id: reservationId },
      data: {
        vehiclePlate: dto.plate ?? vehicle.plate ?? null,
        vehicleState: dto.state ?? vehicle.state ?? null,
        rigType: dto.rigType ?? vehicle.rigType ?? null,
        rigLength: dto.rigLength ?? vehicle.rigLength ?? null
      }
    });
    return vehicle;
  }
  async getIntegration(campgroundId, provider) {
    const record = await this.integrationsRepo()?.findFirst?.({
      where: { campgroundId, provider }
    });
    if (!record) {
      throw new import_common43.NotFoundException(`Access provider ${provider} not configured`);
    }
    return record;
  }
  maskSecret(value) {
    if (!value) return null;
    if (value.length <= 4) return "*".repeat(Math.max(0, value.length - 1)) + value.slice(-1);
    return `${"*".repeat(Math.max(0, value.length - 4))}${value.slice(-4)}`;
  }
  hashSecret(value) {
    if (!value) return null;
    return crypto2.createHash("sha256").update(value).digest("hex");
  }
  async ensureCredential(options) {
    const existing = await this.credentialsRepo().findFirst({
      where: {
        reservationId: options.reservationId,
        provider: options.provider
      }
    });
    if (existing) return existing;
    return this.credentialsRepo().create({
      data: {
        campgroundId: (await this.prisma.reservation.findUnique({
          where: { id: options.reservationId },
          select: { campgroundId: true }
        }))?.campgroundId,
        reservationId: options.reservationId,
        vehicleId: options.vehicleId ?? null,
        integrationId: options.integrationId ?? null,
        provider: options.provider,
        type: options.credentialType ?? import_client9.AccessCredentialType.mobile,
        maskedValue: this.maskSecret(options.credentialValue),
        secretHash: this.hashSecret(options.credentialValue),
        status: import_client9.AccessGrantStatus.pending
      }
    });
  }
  async grantAccess(reservationId, dto) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      include: { guest: true, site: true }
    });
    if (!reservation) throw new import_common43.NotFoundException("Reservation not found");
    if (["cancelled", "checked_out"].includes(reservation.status)) {
      throw new import_common43.ConflictException("Access cannot be granted for cancelled or checked out reservations");
    }
    const idempotencyKey = dto.idempotencyKey || `access-grant:${dto.provider}:${reservationId}`;
    const idemRecord = await this.idempotency.start(idempotencyKey, dto, reservation.campgroundId, {
      endpoint: "access/grant",
      requestBody: dto,
      sequence: dto.idempotencyKey ?? null
    });
    if (idemRecord?.status === import_client9.IdempotencyStatus.succeeded && idemRecord.responseJson) {
      return idemRecord.responseJson;
    }
    const adapter = this.registry.getAdapter(dto.provider);
    if (!adapter) {
      await this.idempotency.fail(idempotencyKey);
      throw new import_common43.BadRequestException("Access provider not supported");
    }
    const integration = await this.getIntegration(reservation.campgroundId, dto.provider);
    const vehicle = await this.vehiclesRepo().findFirst({ where: { reservationId } });
    const credential = await this.ensureCredential({
      reservationId,
      provider: dto.provider,
      integrationId: integration.id,
      vehicleId: vehicle?.id ?? null,
      credentialType: dto.credentialType,
      credentialValue: dto.credentialValue ?? null
    });
    const grant = await this.grantsRepo().upsert({
      where: { reservationId_provider: { reservationId, provider: dto.provider } },
      create: {
        reservationId,
        campgroundId: reservation.campgroundId,
        siteId: reservation.siteId ?? null,
        vehicleId: vehicle?.id ?? null,
        credentialId: credential?.id ?? null,
        integrationId: integration.id,
        provider: dto.provider,
        startsAt: this.toDate(dto.startsAt),
        endsAt: this.toDate(dto.endsAt),
        status: import_client9.AccessGrantStatus.pending,
        idempotencyKey
      },
      update: {
        siteId: reservation.siteId ?? void 0,
        vehicleId: vehicle?.id ?? void 0,
        credentialId: credential?.id ?? void 0,
        startsAt: this.toDate(dto.startsAt) ?? void 0,
        endsAt: this.toDate(dto.endsAt) ?? void 0,
        idempotencyKey
      }
    });
    try {
      const result = await adapter.provisionAccess(integration, {
        reservationId,
        siteId: reservation.siteId,
        guestName: reservation.guest ? `${reservation.guest.primaryFirstName} ${reservation.guest.primaryLastName}` : void 0,
        vehiclePlate: vehicle?.plate ?? reservation.vehiclePlate ?? dto.credentialValue ?? void 0,
        rigLength: reservation.rigLength ?? void 0,
        rigType: reservation.rigType ?? void 0,
        credentialType: dto.credentialType,
        credentialValue: dto.credentialValue,
        startsAt: this.toDate(dto.startsAt),
        endsAt: this.toDate(dto.endsAt),
        idempotencyKey
      });
      const updated = await this.grantsRepo().update({
        where: { id: grant.id },
        data: {
          providerAccessId: result.providerAccessId ?? grant.providerAccessId,
          status: result.status ?? import_client9.AccessGrantStatus.active,
          lastSyncAt: /* @__PURE__ */ new Date()
        }
      });
      const response = { grant: updated };
      await this.idempotency.complete(idempotencyKey, response);
      await this.audit.record({
        campgroundId: reservation.campgroundId,
        actorId: dto.actorId ?? null,
        action: "access.grant",
        entity: "Reservation",
        entityId: reservationId,
        before: { grantId: grant.id, status: grant.status },
        after: { grantId: updated.id, status: updated.status, provider: dto.provider }
      });
      return response;
    } catch (err) {
      await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async revokeAccess(reservationId, dto) {
    const reservation = await this.prisma.reservation.findUnique({ where: { id: reservationId } });
    if (!reservation) throw new import_common43.NotFoundException("Reservation not found");
    const idempotencyKey = dto.idempotencyKey || `access-revoke:${dto.provider}:${reservationId}`;
    const idemRecord = await this.idempotency.start(idempotencyKey, dto, reservation.campgroundId, {
      endpoint: "access/revoke",
      requestBody: dto,
      sequence: dto.idempotencyKey ?? null
    });
    if (idemRecord?.status === import_client9.IdempotencyStatus.succeeded && idemRecord.responseJson) {
      return idemRecord.responseJson;
    }
    const adapter = this.registry.getAdapter(dto.provider);
    if (!adapter) {
      await this.idempotency.fail(idempotencyKey);
      throw new import_common43.BadRequestException("Access provider not supported");
    }
    const integration = await this.getIntegration(reservation.campgroundId, dto.provider);
    const grant = await this.grantsRepo().findFirst({
      where: { reservationId, provider: dto.provider }
    });
    if (!grant) throw new import_common43.NotFoundException("Access grant not found");
    try {
      const result = await adapter.revokeAccess(integration, {
        reservationId,
        providerAccessId: dto.providerAccessId ?? grant.providerAccessId ?? void 0,
        reason: dto.reason
      });
      const updated = await this.grantsRepo().update({
        where: { id: grant.id },
        data: {
          status: result.status ?? import_client9.AccessGrantStatus.revoked,
          blockedReason: dto.reason ?? grant.blockedReason ?? null,
          lastSyncAt: /* @__PURE__ */ new Date()
        }
      });
      const response = { grant: updated };
      await this.idempotency.complete(idempotencyKey, response);
      await this.audit.record({
        campgroundId: reservation.campgroundId,
        actorId: dto.actorId ?? null,
        action: "access.revoke",
        entity: "Reservation",
        entityId: reservationId,
        before: { grantId: grant.id, status: grant.status },
        after: { grantId: updated.id, status: updated.status, provider: dto.provider, reason: dto.reason ?? null }
      });
      return response;
    } catch (err) {
      await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async blockAccessForReservation(reservationId, reason, actorId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: { id: true, campgroundId: true }
    });
    const result = await this.grantsRepo().updateMany({
      where: {
        reservationId,
        status: { in: [import_client9.AccessGrantStatus.active, import_client9.AccessGrantStatus.pending] }
      },
      data: {
        status: import_client9.AccessGrantStatus.blocked,
        blockedReason: reason,
        lastSyncAt: /* @__PURE__ */ new Date()
      }
    });
    if (reservation) {
      await this.audit.record({
        campgroundId: reservation.campgroundId,
        actorId: actorId ?? null,
        action: "access.block",
        entity: "Reservation",
        entityId: reservationId,
        after: { reason, updated: result.count }
      });
    }
  }
  async listIntegrations(campgroundId) {
    if (!campgroundId) throw new import_common43.BadRequestException("campgroundId required");
    const records = await this.integrationsRepo()?.findMany?.({ where: { campgroundId } }) ?? [];
    return records.map((r) => ({
      ...r,
      webhookSecret: this.maskSecret(r.webhookSecret)
    }));
  }
  async upsertIntegration(campgroundId, dto) {
    if (!campgroundId) throw new import_common43.BadRequestException("campgroundId required");
    const record = await this.integrationsRepo().upsert({
      where: { campgroundId_provider: { campgroundId, provider: dto.provider } },
      create: {
        campgroundId,
        provider: dto.provider,
        displayName: dto.displayName,
        status: dto.status ?? "enabled",
        credentials: dto.credentials,
        webhookSecret: dto.webhookSecret ?? null
      },
      update: {
        displayName: dto.displayName ?? void 0,
        status: dto.status ?? void 0,
        credentials: dto.credentials ?? {},
        webhookSecret: dto.webhookSecret ?? void 0
      }
    });
    return {
      ...record,
      webhookSecret: this.maskSecret(record.webhookSecret)
    };
  }
  async verifyWebhook(provider, signature, rawBody, campgroundId) {
    const integration = await this.integrationsRepo()?.findFirst?.({
      where: { provider, ...campgroundId ? { campgroundId } : {} }
    });
    if (!integration) return false;
    const adapter = this.registry.getAdapter(provider);
    if (!adapter) return false;
    return adapter.verifyWebhookSignature({
      integration,
      signature,
      secret: integration.webhookSecret,
      rawBody
    });
  }
  async autoGrantForReservation(reservationId, actorId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      include: { site: true, guest: true }
    });
    if (!reservation) throw new import_common43.NotFoundException("Reservation not found");
    const integrations = await this.integrationsRepo()?.findMany?.({
      where: { campgroundId: reservation.campgroundId, status: "enabled" }
    }) ?? [];
    for (const integration of integrations) {
      try {
        await this.grantAccess(reservationId, {
          provider: integration.provider,
          startsAt: reservation.arrivalDate?.toISOString?.() ?? void 0,
          endsAt: reservation.departureDate?.toISOString?.() ?? void 0,
          idempotencyKey: `auto-grant:${integration.provider}:${reservationId}`,
          actorId
        });
      } catch (err) {
        continue;
      }
    }
  }
  async revokeAllForReservation(reservationId, reason, actorId) {
    const grants = await this.grantsRepo().findMany({
      where: { reservationId, status: { in: [import_client9.AccessGrantStatus.active, import_client9.AccessGrantStatus.pending, import_client9.AccessGrantStatus.blocked] } }
    });
    for (const grant of grants ?? []) {
      try {
        await this.revokeAccess(reservationId, {
          provider: grant.provider,
          providerAccessId: grant.providerAccessId ?? void 0,
          idempotencyKey: `auto-revoke:${grant.provider}:${reservationId}`,
          reason,
          actorId
        });
      } catch (err) {
        continue;
      }
    }
  }
};
AccessControlService = __decorateClass([
  (0, import_common43.Injectable)()
], AccessControlService);

// src/access-control/access-provider.registry.ts
var import_common44 = require("@nestjs/common");
var AccessProviderRegistry = class {
  constructor(kisi, brivo, cloudKey) {
    this.adapters = /* @__PURE__ */ new Map([
      [kisi.provider, kisi],
      [brivo.provider, brivo],
      [cloudKey.provider, cloudKey]
    ]);
  }
  getAdapter(provider) {
    return this.adapters.get(provider) ?? null;
  }
  supported() {
    return Array.from(this.adapters.keys());
  }
};
AccessProviderRegistry = __decorateClass([
  (0, import_common44.Injectable)()
], AccessProviderRegistry);

// src/access-control/access-provider.adapters.ts
var import_common45 = require("@nestjs/common");
var crypto3 = __toESM(require("crypto"));
var AccessProviderType2 = {
  kisi: "kisi",
  brivo: "brivo",
  cloudkey: "cloudkey"
};
var AccessGrantStatus2 = {
  pending: "pending",
  active: "active",
  revoked: "revoked",
  blocked: "blocked",
  expired: "expired",
  failed: "failed"
};
var BaseAdapter = class {
  hmacValid(secret, payload, signature) {
    if (!secret || !signature) return false;
    const digest = crypto3.createHmac("sha256", secret).update(payload).digest("hex");
    return digest === signature;
  }
  async provisionAccess(_integration, request) {
    return {
      providerAccessId: `${this.provider}-${request.reservationId}`,
      status: AccessGrantStatus2.active
    };
  }
  async revokeAccess(_integration, _request) {
    return { status: AccessGrantStatus2.revoked };
  }
  verifyWebhookSignature(input) {
    return this.hmacValid(input.secret, input.rawBody, input.signature);
  }
};
var KisiAdapter = class extends BaseAdapter {
  constructor() {
    super(...arguments);
    this.provider = AccessProviderType2.kisi;
  }
};
KisiAdapter = __decorateClass([
  (0, import_common45.Injectable)()
], KisiAdapter);
var BrivoAdapter = class extends BaseAdapter {
  constructor() {
    super(...arguments);
    this.provider = AccessProviderType2.brivo;
  }
};
BrivoAdapter = __decorateClass([
  (0, import_common45.Injectable)()
], BrivoAdapter);
var CloudKeyAdapter = class extends BaseAdapter {
  constructor() {
    super(...arguments);
    this.provider = AccessProviderType2.cloudkey;
  }
};
CloudKeyAdapter = __decorateClass([
  (0, import_common45.Injectable)()
], CloudKeyAdapter);

// src/access-control/access-control.module.ts
var AccessControlModule = class {
};
AccessControlModule = __decorateClass([
  (0, import_common46.Module)({
    imports: [AuthModule, AuditModule],
    controllers: [AccessControlController],
    providers: [
      AccessControlService,
      PrismaService,
      IdempotencyService,
      AccessProviderRegistry,
      KisiAdapter,
      BrivoAdapter,
      CloudKeyAdapter
    ],
    exports: [AccessControlService, AccessProviderRegistry]
  })
], AccessControlModule);

// src/waitlist/waitlist.module.ts
var import_common61 = require("@nestjs/common");

// src/waitlist/waitlist.service.ts
var import_common47 = require("@nestjs/common");
var import_client10 = require("@prisma/client");
var WaitlistService = class {
  constructor(prisma, emailService, idempotency, observability) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.idempotency = idempotency;
    this.observability = observability;
    this.logger = new import_common47.Logger(WaitlistService.name);
  }
  /**
   * Calculate priority score for a waitlist entry
   * Higher score = higher priority
   */
  calculatePriorityScore(entry, freedArrival, freedDeparture) {
    let score = 0;
    const reasons = [];
    score += entry.priority || 50;
    reasons.push(`Base priority: ${entry.priority || 50}`);
    if (entry.guest?.reservationCount > 0) {
      const loyaltyBonus = Math.min(entry.guest.reservationCount * 5, 25);
      score += loyaltyBonus;
      reasons.push(`Loyalty bonus: +${loyaltyBonus} (${entry.guest.reservationCount} stays)`);
    }
    if (entry.arrivalDate && entry.departureDate) {
      const entryArr = new Date(entry.arrivalDate);
      const entryDep = new Date(entry.departureDate);
      const freedArr = new Date(freedArrival);
      const freedDep = new Date(freedDeparture);
      if (entryArr.getTime() === freedArr.getTime() && entryDep.getTime() === freedDep.getTime()) {
        score += 30;
        reasons.push(`Exact date match: +30`);
      } else {
        score += 10;
        reasons.push(`Date overlap: +10`);
      }
    }
    if (entry.siteId) {
      score += 15;
      reasons.push(`Specific site preference: +15`);
    }
    const waitDays = Math.floor((Date.now() - new Date(entry.createdAt).getTime()) / (1e3 * 60 * 60 * 24));
    const waitBonus = Math.min(waitDays, 30);
    score += waitBonus;
    reasons.push(`Wait time bonus: +${waitBonus} (${waitDays} days)`);
    if (entry.maxPrice && entry.maxPrice > 0) {
      score += 10;
      reasons.push(`Price flexibility: +10`);
    }
    if (entry.autoOffer) {
      score += 20;
      reasons.push(`Auto-offer enabled: +20`);
    }
    return { score, reasons };
  }
  async create(dto, idempotencyKey, sequence, actor) {
    const scope = { campgroundId: dto.campgroundId ?? actor?.campgroundId ?? null, tenantId: dto.tenantId ?? actor?.tenantId ?? null };
    const scopeKey = this.scopeKey(scope);
    if (sequence) {
      const seqExisting = await this.idempotency.findBySequence(scopeKey, "waitlist/create", sequence);
      if (seqExisting?.responseJson) {
        this.logger.warn(`Duplicate waitlist create seq ${sequence} scope ${scopeKey}`);
        return seqExisting.responseJson;
      }
      if (seqExisting) {
        this.logger.warn(`Waitlist create seq ${sequence} already processed without snapshot for scope ${scopeKey}`);
        throw new import_common47.ConflictException("Waitlist request already processed");
      }
    }
    const existing = await this.guardIdempotency(idempotencyKey, dto, scope, "waitlist/create", sequence);
    if (existing?.status === import_client10.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client10.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common47.ConflictException("Request already in progress");
    }
    const result = await this.prisma.waitlistEntry.create({
      data: {
        ...dto,
        status: import_client10.WaitlistStatus.active
      }
    });
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
    return result;
  }
  async createStaffEntry(dto, idempotencyKey, sequence, actor) {
    const scope = { campgroundId: dto.campgroundId ?? actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const scopeKey = this.scopeKey(scope);
    if (sequence) {
      const seqExisting = await this.idempotency.findBySequence(scopeKey, "waitlist/staff", sequence);
      if (seqExisting?.responseJson) {
        this.logger.warn(`Duplicate staff waitlist create seq ${sequence} scope ${scopeKey}`);
        return seqExisting.responseJson;
      }
      if (seqExisting) {
        this.logger.warn(`Staff waitlist create seq ${sequence} already processed for scope ${scopeKey}`);
        throw new import_common47.ConflictException("Waitlist request already processed");
      }
    }
    const existing = await this.guardIdempotency(idempotencyKey, dto, scope, "waitlist/staff", sequence);
    if (existing?.status === import_client10.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client10.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common47.ConflictException("Request already in progress");
    }
    const result = await this.prisma.waitlistEntry.create({
      data: {
        campgroundId: dto.campgroundId,
        type: dto.type,
        contactName: dto.contactName,
        contactEmail: dto.contactEmail || null,
        contactPhone: dto.contactPhone || null,
        notes: dto.notes || null,
        siteId: dto.siteId || null,
        siteTypeId: dto.siteTypeId || null,
        arrivalDate: dto.arrivalDate ? new Date(dto.arrivalDate) : null,
        departureDate: dto.departureDate ? new Date(dto.departureDate) : null,
        status: import_client10.WaitlistStatus.active,
        priority: dto.priority ?? 50,
        autoOffer: dto.autoOffer ?? false,
        maxPrice: dto.maxPrice ?? null,
        flexibleDates: dto.flexibleDates ?? false,
        flexibleDays: dto.flexibleDays ?? 0
      },
      include: { site: true, siteClass: true }
    });
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
    return result;
  }
  async updateEntry(id, updates) {
    return this.prisma.waitlistEntry.update({
      where: { id },
      data: {
        ...updates.contactName && { contactName: updates.contactName },
        ...updates.contactEmail !== void 0 && { contactEmail: updates.contactEmail || null },
        ...updates.contactPhone !== void 0 && { contactPhone: updates.contactPhone || null },
        ...updates.notes !== void 0 && { notes: updates.notes || null },
        ...updates.siteId !== void 0 && { siteId: updates.siteId || null },
        ...updates.siteTypeId !== void 0 && { siteTypeId: updates.siteTypeId || null },
        ...updates.arrivalDate !== void 0 && { arrivalDate: updates.arrivalDate ? new Date(updates.arrivalDate) : null },
        ...updates.departureDate !== void 0 && { departureDate: updates.departureDate ? new Date(updates.departureDate) : null },
        ...updates.priority !== void 0 && { priority: updates.priority },
        ...updates.autoOffer !== void 0 && { autoOffer: updates.autoOffer },
        ...updates.maxPrice !== void 0 && { maxPrice: updates.maxPrice },
        ...updates.flexibleDates !== void 0 && { flexibleDates: updates.flexibleDates },
        ...updates.flexibleDays !== void 0 && { flexibleDays: updates.flexibleDays }
      },
      include: { site: true, siteClass: true, guest: true }
    });
  }
  async getStats(campgroundId) {
    const [active, offered, converted, expired] = await Promise.all([
      this.prisma.waitlistEntry.count({ where: { campgroundId, status: import_client10.WaitlistStatus.active } }),
      this.prisma.waitlistEntry.count({ where: { campgroundId, status: "offered" } }),
      this.prisma.waitlistEntry.count({ where: { campgroundId, status: "converted" } }),
      this.prisma.waitlistEntry.count({ where: { campgroundId, status: "expired" } })
    ]);
    return { active, offered, converted, expired, total: active + offered + converted + expired };
  }
  async findAll(campgroundId, type) {
    return this.prisma.waitlistEntry.findMany({
      where: {
        campgroundId,
        ...type && type !== "all" ? { type } : {}
      },
      include: { guest: true, site: true, siteClass: true },
      orderBy: { createdAt: "desc" }
    });
  }
  async remove(id) {
    return this.prisma.waitlistEntry.delete({
      where: { id }
    });
  }
  async accept(id, idempotencyKey, sequence, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const scopeKey = this.scopeKey(scope);
    if (sequence) {
      const seqExisting = await this.idempotency.findBySequence(scopeKey, "waitlist/accept", sequence);
      if (seqExisting?.responseJson) {
        this.logger.warn(`Duplicate waitlist accept seq ${sequence} scope ${scopeKey}`);
        return seqExisting.responseJson;
      }
      if (seqExisting) {
        this.logger.warn(`Waitlist accept seq ${sequence} already processed for scope ${scopeKey}`);
        throw new import_common47.ConflictException("Waitlist accept already processed");
      }
    }
    const existing = await this.guardIdempotency(idempotencyKey, { entryId: id }, scope, "waitlist/accept", sequence);
    if (existing?.status === import_client10.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client10.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common47.ConflictException("Request already in progress");
    }
    const entry = await this.prisma.waitlistEntry.findUnique({ where: { id } });
    if (!entry) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw new import_common47.NotFoundException("Waitlist entry not found");
    }
    if (entry.status === import_client10.WaitlistStatus.fulfilled) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw new import_common47.ConflictException("Waitlist entry already accepted");
    }
    if (entry.status !== import_client10.WaitlistStatus.active) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw new import_common47.ConflictException("Waitlist entry not active");
    }
    const response = await this.prisma.waitlistEntry.update({
      where: { id },
      data: { status: import_client10.WaitlistStatus.fulfilled }
    });
    const snapshot = { entryId: id, status: "accepted" };
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, snapshot);
    return snapshot;
  }
  /**
   * Check waitlist for matches after a cancellation.
   * Returns prioritized matches sorted by score.
   */
  async checkWaitlist(campgroundId, arrival, departure, siteId, siteClassId) {
    this.logger.log(`Checking waitlist for campground ${campgroundId} dates ${arrival.toISOString()} - ${departure.toISOString()}`);
    const cooldownHours = Number(process.env.WAITLIST_NOTIFY_COOLDOWN_HOURS ?? 6);
    const cooldownThreshold = cooldownHours > 0 ? new Date(Date.now() - cooldownHours * 60 * 60 * 1e3) : null;
    const entries = await this.prisma.waitlistEntry.findMany({
      where: {
        campgroundId,
        status: import_client10.WaitlistStatus.active,
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival },
        OR: [
          { siteId: null, siteTypeId: null },
          // any
          { siteId },
          // specific site
          { siteTypeId: siteClassId }
          // specific class
        ],
        ...cooldownThreshold ? {
          lastNotifiedAt: {
            lt: cooldownThreshold
          }
        } : {}
      },
      include: { guest: true }
    });
    const scoredMatches = entries.map((entry) => {
      const { score, reasons } = this.calculatePriorityScore(entry, arrival, departure);
      return { entry, score, reasons };
    }).sort((a, b) => b.score - a.score);
    this.logger.log(`Found ${scoredMatches.length} waitlist matches, sorted by priority.`);
    return scoredMatches;
  }
  /**
   * Notify waitlist matches about availability
   */
  async notifyMatches(matches, siteNumber, campgroundName, arrival, departure) {
    let notified = 0;
    let autoOffered = 0;
    for (const { entry, score } of matches) {
      if (!entry.guest && !entry.contactEmail) {
        this.logger.warn(`Skipping waitlist entry ${entry.id} due to missing contact info`);
        continue;
      }
      const email = entry.guest?.email || entry.contactEmail;
      const name = entry.guest?.primaryFirstName || entry.contactName || "Guest";
      if (!email) continue;
      try {
        const isAutoOffer = entry.autoOffer === true;
        const subject = isAutoOffer ? `\u{1F389} Auto-Reserved: Site ${siteNumber} is yours!` : `Good News! Site ${siteNumber} is available!`;
        const html = isAutoOffer ? `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-radius: 12px; padding: 24px; text-align: center; color: white;">
                            <h1 style="margin: 0;">\u{1F389} You're In!</h1>
                            <p style="margin: 8px 0 0 0; opacity: 0.9;">We auto-reserved this site for you</p>
                        </div>
                        <div style="padding: 24px;">
                            <p>Dear ${name},</p>
                            <p>Great news! Based on your auto-offer preference, we've automatically reserved <strong>Site ${siteNumber}</strong> at <strong>${campgroundName}</strong> for you.</p>
                            <p><strong>Dates:</strong> ${arrival.toLocaleDateString()} - ${departure.toLocaleDateString()}</p>
                            <p style="background: #fef3c7; border-radius: 8px; padding: 16px; margin: 20px 0;">
                                \u23F0 <strong>Important:</strong> Please confirm and complete payment within 24 hours or this reservation will be released.
                            </p>
                            <a href="#" style="display: inline-block; background: #10b981; color: white; text-decoration: none; padding: 12px 24px; border-radius: 8px; font-weight: 600;">Confirm & Pay Now</a>
                        </div>
                    </div>
                ` : `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto;">
                        <h1 style="color: #10b981;">Site Available!</h1>
                        <p>Dear ${name},</p>
                        <p>Good news! <strong>Site ${siteNumber}</strong> has become available at <strong>${campgroundName}</strong> for your desired dates:</p>
                        <p><strong>${arrival.toLocaleDateString()} - ${departure.toLocaleDateString()}</strong></p>
                        <p>This is first-come, first-served, so book soon!</p>
                        <a href="#" style="display: inline-block; background: #10b981; color: white; text-decoration: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; margin-top: 16px;">Book Now</a>
                        <p style="color: #64748b; font-size: 12px; margin-top: 24px;">Your priority score: ${score}</p>
                    </div>
                `;
        await this.emailService.sendEmail({
          to: email,
          subject,
          html,
          campgroundId: entry.campgroundId
        });
        await this.prisma.waitlistEntry.update({
          where: { id: entry.id },
          data: {
            lastNotifiedAt: /* @__PURE__ */ new Date(),
            notifiedCount: (entry.notifiedCount ?? 0) + 1,
            status: isAutoOffer ? "offered" : import_client10.WaitlistStatus.active
          }
        });
        const createdAt = entry.createdAt ? new Date(entry.createdAt).getTime() : Date.now();
        const lagSeconds = Math.max(0, (Date.now() - createdAt) / 1e3);
        this.observability.recordOfferLag(lagSeconds, {
          entryId: entry.id,
          campgroundId: entry.campgroundId,
          autoOffer: isAutoOffer,
          status: isAutoOffer ? "auto_offer" : "notify"
        });
        notified++;
        if (isAutoOffer) autoOffered++;
      } catch (err) {
        this.logger.warn(`Failed to notify waitlist entry ${entry.id}: ${err}`);
      }
    }
    return { notified, autoOffered };
  }
  /**
   * Mark entry as converted (booked)
   */
  async markConverted(id, reservationId) {
    return this.prisma.waitlistEntry.update({
      where: { id },
      data: {
        status: "converted",
        convertedReservationId: reservationId,
        convertedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  /**
   * Expire old waitlist entries
   */
  async expireOldEntries(campgroundId, daysOld = 90) {
    const threshold = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1e3);
    const result = await this.prisma.waitlistEntry.updateMany({
      where: {
        campgroundId,
        status: import_client10.WaitlistStatus.active,
        createdAt: { lt: threshold }
      },
      data: {
        status: "expired"
      }
    });
    this.logger.log(`Expired ${result.count} old waitlist entries for campground ${campgroundId}`);
    return result.count;
  }
  scopeKey(scope) {
    return scope.tenantId ?? scope.campgroundId ?? "global";
  }
  async guardIdempotency(key, body, scope, endpoint, sequence) {
    if (!key) return null;
    return this.idempotency.start(key, body ?? {}, scope.campgroundId ?? null, {
      tenantId: scope.tenantId ?? null,
      endpoint,
      sequence,
      rateAction: "apply"
    });
  }
};
WaitlistService = __decorateClass([
  (0, import_common47.Injectable)()
], WaitlistService);

// src/waitlist/waitlist.controller.ts
var import_common48 = require("@nestjs/common");
var WaitlistController = class {
  constructor(waitlistService) {
    this.waitlistService = waitlistService;
  }
  create(createWaitlistDto, req) {
    const idempotencyKey = req.headers["idempotency-key"];
    const sequence = req.headers["x-client-seq"] ?? req.headers["client-seq"];
    return this.waitlistService.create(createWaitlistDto, idempotencyKey, sequence, req.user);
  }
  createStaffEntry(dto, req) {
    const idempotencyKey = req.headers["idempotency-key"];
    const sequence = req.headers["x-client-seq"] ?? req.headers["client-seq"];
    return this.waitlistService.createStaffEntry(dto, idempotencyKey, sequence, req.user);
  }
  accept(id, req) {
    const idempotencyKey = req.headers["idempotency-key"];
    const sequence = req.headers["x-client-seq"] ?? req.headers["client-seq"];
    return this.waitlistService.accept(id, idempotencyKey, sequence, req.user);
  }
  findAll(campgroundId, type) {
    return this.waitlistService.findAll(campgroundId, type);
  }
  remove(id) {
    return this.waitlistService.remove(id);
  }
};
__decorateClass([
  (0, import_common48.Post)(),
  __decorateParam(0, (0, import_common48.Body)()),
  __decorateParam(1, (0, import_common48.Req)())
], WaitlistController.prototype, "create", 1);
__decorateClass([
  (0, import_common48.Post)("staff"),
  __decorateParam(0, (0, import_common48.Body)()),
  __decorateParam(1, (0, import_common48.Req)())
], WaitlistController.prototype, "createStaffEntry", 1);
__decorateClass([
  (0, import_common48.Post)(":id/accept"),
  __decorateParam(0, (0, import_common48.Param)("id")),
  __decorateParam(1, (0, import_common48.Req)())
], WaitlistController.prototype, "accept", 1);
__decorateClass([
  (0, import_common48.Get)(),
  __decorateParam(0, (0, import_common48.Query)("campgroundId")),
  __decorateParam(1, (0, import_common48.Query)("type"))
], WaitlistController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common48.Delete)(":id"),
  __decorateParam(0, (0, import_common48.Param)("id"))
], WaitlistController.prototype, "remove", 1);
WaitlistController = __decorateClass([
  (0, import_common48.UseGuards)(JwtAuthGuard),
  (0, import_common48.Controller)("waitlist")
], WaitlistController);

// src/prisma/prisma.module.ts
var import_common49 = require("@nestjs/common");
var PrismaModule = class {
};
PrismaModule = __decorateClass([
  (0, import_common49.Module)({
    providers: [PrismaService],
    exports: [PrismaService]
  })
], PrismaModule);

// src/observability/observability.module.ts
var import_common60 = require("@nestjs/common");

// src/observability/observability.controller.ts
var import_common50 = require("@nestjs/common");
var ObservabilityController = class {
  constructor(observability) {
    this.observability = observability;
  }
  getSnapshot() {
    return this.observability.snapshot();
  }
  getAlerts() {
    return this.observability.alerts();
  }
  getFlags() {
    return {
      commsAlertsEnabled: (process.env.ENABLE_COMMS_METRICS ?? process.env.comms_alerts_enabled ?? "true").toString().toLowerCase() === "true",
      readyAlertsEnabled: (process.env.ENABLE_READY_PROBE ?? process.env.ready_checks_enabled ?? "true").toString().toLowerCase() === "true",
      otaAlertsEnabled: (process.env.ENABLE_OTA_MONITORING ?? process.env.ota_alerts_enabled ?? "true").toString().toLowerCase() === "true",
      syntheticsEnabled: (process.env.SYNTHETICS_ENABLED ?? "true").toLowerCase() === "true"
    };
  }
};
__decorateClass([
  (0, import_common50.Get)("snapshot")
], ObservabilityController.prototype, "getSnapshot", 1);
__decorateClass([
  (0, import_common50.Get)("alerts")
], ObservabilityController.prototype, "getAlerts", 1);
__decorateClass([
  (0, import_common50.Get)("flags")
], ObservabilityController.prototype, "getFlags", 1);
ObservabilityController = __decorateClass([
  (0, import_common50.Controller)("observability")
], ObservabilityController);

// src/observability/observability.service.ts
var import_common51 = require("@nestjs/common");
var ObservabilityService = class {
  constructor() {
    this.apiSamples = [];
    this.jobSamples = [];
    this.queues = {};
    this.domainEvents = {
      redeem: [],
      offline: [],
      offer: [],
      report: [],
      comms: [],
      ota: [],
      ready: []
    };
    this.webLcpSamples = [];
    this.webTtfbSamples = [];
    this.syntheticResults = {};
    this.maxSamples = Number(process.env.OBS_MAX_SAMPLES ?? 800);
    this.targets = {
      apiP95Ms: Number(process.env.SLO_API_P95_MS ?? 400),
      apiErrorRate: Number(process.env.SLO_API_ERROR_RATE ?? 0.01),
      jobP95Ms: Number(process.env.SLO_JOB_P95_MS ?? 3e4),
      jobFailureRate: Number(process.env.SLO_JOB_FAILURE_RATE ?? 0.02),
      webLcpP75Ms: Number(process.env.SLO_WEB_LCP_P75_MS ?? 2500),
      webTtfbP75Ms: Number(process.env.SLO_WEB_TTFB_P75_MS ?? 500),
      smsFailureRate: Number(process.env.SLO_SMS_FAILURE_RATE ?? 0.05),
      smsMinFailures: Number(process.env.SLO_SMS_MIN_FAILURES ?? 3)
    };
    this.queueMaxDepth = Number(process.env.SLO_QUEUE_MAX_DEPTH ?? 200);
    this.queueLagThresholdMs = Number(process.env.SLO_QUEUE_LAG_MS ?? 5 * 60 * 1e3);
    this.domainWindowMs = Number(process.env.OBS_DOMAIN_WINDOW_MS ?? 15 * 60 * 1e3);
  }
  // 15 minutes
  recordApiRequest(sample) {
    this.apiSamples.unshift({ ...sample, at: Date.now() });
    if (this.apiSamples.length > this.maxSamples) {
      this.apiSamples.pop();
    }
  }
  recordJobRun(sample) {
    this.jobSamples.unshift({ ...sample, at: Date.now() });
    if (this.jobSamples.length > this.maxSamples) {
      this.jobSamples.pop();
    }
  }
  setQueueState(queue, running, queued, oldestMs, meta) {
    const normalized = this.normalizeQueueName(queue);
    this.queues[normalized] = {
      running,
      queued,
      oldestMs,
      maxQueue: meta?.maxQueue,
      concurrency: meta?.concurrency,
      updatedAt: Date.now(),
      rawName: queue
    };
  }
  recordRedeemOutcome(ok, latencyMs, meta) {
    this.emit("redeem", { ok, latencyMs, meta });
  }
  recordOfflineReplay(ok, latencyMs, meta) {
    this.emit("offline", { ok, latencyMs, meta });
  }
  recordOfferLag(seconds, meta) {
    this.emit("offer", { ok: seconds <= 30, latencyMs: seconds * 1e3, value: seconds, meta });
  }
  recordReportResult(ok, latencyMs, meta) {
    this.emit("report", { ok, latencyMs, meta });
  }
  recordCommsStatus(status, meta) {
    const ok = status === "delivered" || status === "sent";
    this.emit("comms", { ok, kind: status, meta });
  }
  recordOtaStatus(ok, backlogSeconds, meta) {
    this.emit("ota", { ok, value: backlogSeconds, meta });
  }
  recordWebMetric(kind, valueMs) {
    const entry = { ok: true, value: valueMs, latencyMs: valueMs, at: Date.now() };
    const targetArray = kind === "lcp" ? this.webLcpSamples : this.webTtfbSamples;
    targetArray.unshift(entry);
    if (targetArray.length > this.maxSamples) targetArray.pop();
  }
  recordSynthetic(name, ok, latencyMs, message) {
    this.syntheticResults[name] = { ok, latencyMs, at: Date.now(), message };
  }
  recordReady(ok, meta) {
    this.emit("ready", { ok, meta });
  }
  emit(key, event) {
    this.recordDomainEvent(key, event);
  }
  snapshot() {
    const apiAgg = this.aggregate(this.apiSamples.map((s) => s.durationMs));
    const jobAgg = this.aggregate(this.jobSamples.map((s) => s.durationMs));
    const lcpAgg = this.aggregate(this.webLcpSamples.map((s) => s.value ?? 0));
    const ttfbAgg = this.aggregate(this.webTtfbSamples.map((s) => s.value ?? 0));
    const percentile = (values, p) => {
      if (!values.length) return 0;
      const sorted = [...values].sort((a, b) => a - b);
      const idx = Math.min(sorted.length - 1, Math.floor(p * sorted.length));
      return sorted[idx];
    };
    const lcpP75 = percentile(this.webLcpSamples.map((s) => s.value ?? 0), 0.75);
    const ttfbP75 = percentile(this.webTtfbSamples.map((s) => s.value ?? 0), 0.75);
    return {
      captured: Math.max(this.apiSamples.length, this.jobSamples.length),
      targets: this.targets,
      api: {
        ...apiAgg,
        errors: this.apiSamples.filter((s) => s.status >= 400).length,
        recentErrors: this.apiSamples.filter((s) => s.status >= 400).slice(0, 10).map((s) => ({ path: s.path, status: s.status, at: s.at }))
      },
      jobs: {
        ...jobAgg,
        errors: this.jobSamples.filter((s) => !s.success).length,
        queues: this.queues
      },
      web: {
        lcp: lcpAgg,
        ttfb: ttfbAgg,
        p75: { lcp: lcpP75, ttfb: ttfbP75 }
      },
      synthetics: this.syntheticResults
    };
  }
  alerts() {
    const snapshot = this.snapshot();
    const apiErrorRate = snapshot.api.count ? snapshot.api.errors / snapshot.api.count : 0;
    const jobFailureRate = snapshot.jobs.count ? snapshot.jobs.errors / snapshot.jobs.count : 0;
    const queues = snapshot.jobs.queues || {};
    const queueDepthBreaches = Object.entries(queues).filter(([, state]) => (state?.queued ?? 0) > this.queueMaxDepth).map(([name, state]) => ({ name: state.rawName ?? name, queued: state.queued, running: state.running }));
    const queueLagBreaches = Object.entries(queues).filter(([, state]) => (state?.oldestMs ?? 0) > this.queueLagThresholdMs).map(([name, state]) => ({ name: state.rawName ?? name, oldestMs: state.oldestMs, queued: state.queued }));
    const percentile = (values, p) => {
      if (!values.length) return 0;
      const sorted = [...values].sort((a, b) => a - b);
      const idx = Math.min(sorted.length - 1, Math.floor(p * sorted.length));
      return sorted[idx];
    };
    const windowStart = Date.now() - this.domainWindowMs;
    const domainRate = (key) => {
      const events = (this.domainEvents[key] || []).filter((e) => e.at >= windowStart);
      const total = events.length;
      const failures = events.filter((e) => !e.ok).length;
      const failureRate = total === 0 ? 0 : failures / total;
      return { total, failures, failureRate, events };
    };
    const redeemStats = domainRate("redeem");
    const offlineStats = domainRate("offline");
    const offerStats = domainRate("offer");
    const reportStats = domainRate("report");
    const commsEvents = (this.domainEvents["comms"] || []).filter((e) => e.at >= windowStart);
    const commsTotals = commsEvents.reduce(
      (acc, e) => {
        const status = e.kind ?? "sent";
        const provider = e.meta?.provider ?? "unknown";
        acc.total += 1;
        acc.byProvider[provider] = acc.byProvider[provider] ?? { total: 0, delivered: 0, failures: 0 };
        acc.byProvider[provider].total += 1;
        if (status === "delivered" || status === "sent") {
          acc.delivered += 1;
          acc.byProvider[provider].delivered += 1;
        }
        if (status === "bounced") acc.bounced += 1;
        if (status === "spam_complaint") acc.complaints += 1;
        if (!e.ok) {
          acc.failures += 1;
          acc.byProvider[provider].failures += 1;
        }
        return acc;
      },
      { total: 0, delivered: 0, bounced: 0, complaints: 0, failures: 0, byProvider: {} }
    );
    const commsDeliveryRate = commsTotals.total === 0 ? 1 : commsTotals.delivered / commsTotals.total;
    const commsBounceRate = commsTotals.total === 0 ? 0 : commsTotals.bounced / commsTotals.total;
    const commsComplaintRate = commsTotals.total === 0 ? 0 : commsTotals.complaints / commsTotals.total;
    const twilio = commsTotals.byProvider["twilio"] || { total: 0, failures: 0, delivered: 0 };
    const smsFailureRate = twilio.total === 0 ? 0 : twilio.failures / twilio.total;
    const webLcp = snapshot.web.lcp;
    const webTtfb = snapshot.web.ttfb;
    const lcpValues = this.webLcpSamples.map((s) => s.value ?? 0);
    const ttfbValues = this.webTtfbSamples.map((s) => s.value ?? 0);
    const webLcpP75 = percentile(lcpValues, 0.75);
    const webTtfbP75 = percentile(ttfbValues, 0.75);
    const otaEvents = domainRate("ota");
    const otaBacklogBreaches = otaEvents.events.filter((e) => typeof e.value === "number" && (e.value ?? 0) > 900).map((e) => ({ backlogSeconds: e.value, meta: e.meta }));
    const readyEvents = (this.domainEvents["ready"] || []).filter((e) => e.at >= windowStart);
    const lastReadyOkAt = readyEvents.filter((e) => e.ok).sort((a, b) => b.at - a.at)[0]?.at ?? null;
    const readyFailures = readyEvents.filter((e) => !e.ok);
    const readyBreach = readyFailures.length > 0 && (!lastReadyOkAt || Date.now() - lastReadyOkAt > 2 * 60 * 1e3);
    return {
      captured: snapshot.captured,
      targets: this.targets,
      api: {
        p95: snapshot.api.p95,
        errorRate: apiErrorRate,
        breaches: {
          p95: snapshot.api.p95 > this.targets.apiP95Ms,
          errorRate: apiErrorRate > this.targets.apiErrorRate
        }
      },
      jobs: {
        p95: snapshot.jobs.p95,
        failureRate: jobFailureRate,
        breaches: {
          p95: snapshot.jobs.p95 > this.targets.jobP95Ms,
          failureRate: jobFailureRate > this.targets.jobFailureRate
        }
      },
      queues: {
        maxDepth: this.queueMaxDepth,
        depthBreaches: queueDepthBreaches,
        lagBreaches: queueLagBreaches,
        state: queues
      },
      domain: {
        redeem: {
          failureRate: redeemStats.failureRate,
          total: redeemStats.total,
          failures: redeemStats.failures,
          breach: redeemStats.failureRate > 0.05 && redeemStats.failures >= 3
        },
        offlineBacklog: {
          total: offlineStats.total,
          failures: offlineStats.failures,
          breach: offlineStats.failureRate > 0.1 || queueDepthBreaches.some((q) => q.name.includes("offline"))
        },
        offerLag: {
          samples: offerStats.total,
          maxSeconds: Math.max(0, ...offerStats.events.map((e) => e.value ?? 0)),
          breach: offerStats.events.some((e) => (e.value ?? 0) > 300)
        },
        reports: {
          failureRate: reportStats.failureRate,
          total: reportStats.total,
          failures: reportStats.failures,
          breach: reportStats.failureRate > 0.05 && reportStats.failures >= 1
        },
        ready: {
          lastOkAt: lastReadyOkAt,
          failures: readyFailures.length,
          breach: readyBreach
        }
      },
      comms: {
        deliveryRate: commsDeliveryRate,
        bounceRate: commsBounceRate,
        complaintRate: commsComplaintRate,
        totals: commsTotals,
        breaches: {
          delivery: commsDeliveryRate < 0.98,
          bounce: commsBounceRate > 0.02,
          complaint: commsComplaintRate > 0.01,
          smsFailures: smsFailureRate > this.targets.smsFailureRate && twilio.failures >= this.targets.smsMinFailures
        },
        providers: {
          twilio: {
            failureRate: smsFailureRate,
            failures: twilio.failures,
            total: twilio.total
          }
        }
      },
      web: {
        lcp: webLcp,
        ttfb: webTtfb,
        p75: { lcp: webLcpP75, ttfb: webTtfbP75 },
        breaches: {
          lcp: webLcpP75 > this.targets.webLcpP75Ms,
          ttfb: webTtfbP75 > this.targets.webTtfbP75Ms
        }
      },
      synthetics: this.syntheticResults,
      ota: {
        backlogBreaches: otaBacklogBreaches
      }
    };
  }
  recordDomainEvent(key, event) {
    if (!this.domainEvents[key]) {
      this.domainEvents[key] = [];
    }
    this.domainEvents[key].unshift({ ...event, at: event.at ?? Date.now() });
    if (this.domainEvents[key].length > this.maxSamples) {
      this.domainEvents[key].pop();
    }
  }
  normalizeQueueName(name) {
    const lower = (name || "").toLowerCase();
    if (lower.includes("dead") && lower.includes("letter") && !lower.includes("dlq")) {
      return `${lower}-dlq`;
    }
    return lower;
  }
  aggregate(durations) {
    if (durations.length === 0) {
      return { count: 0, errors: 0, p50: 0, p95: 0, p99: 0, avg: 0 };
    }
    const sorted = [...durations].sort((a, b) => a - b);
    const quantile = (p) => {
      const idx = Math.min(sorted.length - 1, Math.floor(p * sorted.length));
      return sorted[idx];
    };
    const total = sorted.reduce((sum, n) => sum + n, 0);
    return {
      count: durations.length,
      errors: 0,
      p50: quantile(0.5),
      p95: quantile(0.95),
      p99: quantile(0.99),
      avg: Math.round(total / durations.length * 100) / 100
    };
  }
};
ObservabilityService = __decorateClass([
  (0, import_common51.Injectable)()
], ObservabilityService);

// src/observability/job-queue.service.ts
var import_common52 = require("@nestjs/common");
var JobQueueService = class {
  constructor(observability) {
    this.observability = observability;
    this.logger = new import_common52.Logger(JobQueueService.name);
    this.queues = /* @__PURE__ */ new Map();
    this.defaultConcurrency = Number(process.env.JOB_QUEUE_CONCURRENCY ?? 3);
    this.defaultMaxQueue = Number(process.env.JOB_QUEUE_MAX ?? 200);
    this.defaultTimeoutMs = Number(process.env.JOB_QUEUE_TIMEOUT_MS ?? 45e3);
  }
  async enqueue(queueName, fn, opts) {
    const normalizedName = queueName.toLowerCase();
    const state = this.ensureQueue(normalizedName, opts);
    if (state.pending.length >= state.maxQueue) {
      const err = new Error(`Queue ${normalizedName} is saturated (${state.maxQueue} pending)`);
      this.logger.warn(err.message);
      this.observability.recordJobRun({
        name: normalizedName,
        durationMs: 0,
        success: false,
        queueDepth: state.pending.length
      });
      throw err;
    }
    return new Promise((resolve, reject) => {
      state.pending.push({
        fn,
        resolve: (val) => resolve(val),
        reject: (err) => reject(err),
        jobName: opts?.jobName ?? queueName,
        timeoutMs: opts?.timeoutMs,
        enqueuedAt: Date.now()
      });
      this.drain(state);
    });
  }
  ensureQueue(queueName, opts) {
    if (!this.queues.has(queueName)) {
      this.queues.set(queueName, {
        name: queueName,
        running: 0,
        pending: [],
        concurrency: opts?.concurrency ?? this.defaultConcurrency,
        maxQueue: opts?.maxQueue ?? this.defaultMaxQueue
      });
    }
    const state = this.queues.get(queueName);
    state.concurrency = opts?.concurrency ?? this.defaultConcurrency;
    state.maxQueue = opts?.maxQueue ?? this.defaultMaxQueue;
    const oldest = state.pending[0]?.enqueuedAt ? Date.now() - state.pending[0].enqueuedAt : 0;
    this.observability.setQueueState(queueName, state.running, state.pending.length, oldest, {
      maxQueue: state.maxQueue,
      concurrency: state.concurrency
    });
    return state;
  }
  async drain(state) {
    while (state.running < state.concurrency && state.pending.length > 0) {
      const job = state.pending.shift();
      if (!job) break;
      state.running += 1;
      const oldest = state.pending[0]?.enqueuedAt ? Date.now() - state.pending[0].enqueuedAt : 0;
      this.observability.setQueueState(state.name, state.running, state.pending.length, oldest, {
        maxQueue: state.maxQueue,
        concurrency: state.concurrency
      });
      const started = Date.now();
      const timeoutMs = job.timeoutMs ?? this.defaultTimeoutMs;
      const finish = (success) => {
        const durationMs = Date.now() - started;
        this.observability.recordJobRun({
          name: job.jobName ?? state.name,
          durationMs,
          success,
          queueDepth: state.pending.length
        });
        state.running = Math.max(0, state.running - 1);
        const oldestRemaining = state.pending[0]?.enqueuedAt ? Date.now() - state.pending[0].enqueuedAt : 0;
        this.observability.setQueueState(state.name, state.running, state.pending.length, oldestRemaining, {
          maxQueue: state.maxQueue,
          concurrency: state.concurrency
        });
        setImmediate(() => this.drain(state));
      };
      try {
        const res = await this.runWithTimeout(job.fn, timeoutMs);
        finish(true);
        job.resolve(res);
      } catch (err) {
        finish(false);
        job.reject(err);
      }
    }
  }
  async runWithTimeout(fn, timeoutMs) {
    let timeoutHandle;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutHandle = setTimeout(() => reject(new Error(`Job exceeded timeout ${timeoutMs}ms`)), timeoutMs);
    });
    const result = await Promise.race([fn(), timeoutPromise]);
    clearTimeout(timeoutHandle);
    return result;
  }
  /**
   * Lightweight read of queue state for capacity guards/observability.
   * Returns undefined if queue not yet created.
   */
  getQueueState(queueName) {
    const state = this.queues.get(queueName.toLowerCase());
    if (!state) return void 0;
    const oldest = state.pending[0]?.enqueuedAt ? Date.now() - state.pending[0].enqueuedAt : 0;
    return {
      name: state.name,
      running: state.running,
      pending: state.pending.length,
      concurrency: state.concurrency,
      maxQueue: state.maxQueue,
      oldestMs: oldest
    };
  }
};
JobQueueService = __decorateClass([
  (0, import_common52.Injectable)()
], JobQueueService);

// src/observability/alerting.service.ts
var import_common53 = require("@nestjs/common");
var AlertingService = class {
  constructor() {
    this.logger = new import_common53.Logger(AlertingService.name);
    this.slackWebhook = process.env.SLACK_ALERT_WEBHOOK;
    this.pagerDutyKey = process.env.PAGERDUTY_SERVICE_KEY;
    this.namespace = process.env.METRICS_NAMESPACE || "campreserv";
  }
  async notifySlack(text, payload) {
    if (!this.slackWebhook) {
      this.logger.debug(`Slack alert skipped (no webhook configured)`);
      return { ok: false, skipped: true };
    }
    try {
      await fetch(this.slackWebhook, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, ...payload })
      });
      return { ok: true };
    } catch (err) {
      this.logger.warn(`Failed to post Slack alert: ${err?.message ?? err}`);
      return { ok: false, error: err };
    }
  }
  async notifyPagerDuty(summary, severity = "error", source = "campreserv-api", dedupKey, details) {
    if (!this.pagerDutyKey) {
      this.logger.debug(`PagerDuty alert skipped (no service key configured)`);
      return { ok: false, skipped: true };
    }
    const body = {
      routing_key: this.pagerDutyKey,
      event_action: "trigger",
      dedup_key: dedupKey ?? `${this.namespace}:${summary.toLowerCase().replace(/\s+/g, "-")}`,
      payload: {
        summary,
        source,
        severity,
        custom_details: details ?? {}
      }
    };
    try {
      await fetch("https://events.pagerduty.com/v2/enqueue", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      return { ok: true };
    } catch (err) {
      this.logger.warn(`Failed to post PagerDuty alert: ${err?.message ?? err}`);
      return { ok: false, error: err };
    }
  }
  async dispatch(title, body, severity = "error", dedupKey, details) {
    const slack = await this.notifySlack(`:rotating_light: ${title}
${body}`);
    const pd = await this.notifyPagerDuty(`${title} \u2014 ${body}`, severity, "campreserv-api", dedupKey, details);
    return { slack, pagerDuty: pd };
  }
};
AlertingService = __decorateClass([
  (0, import_common53.Injectable)()
], AlertingService);

// src/observability/alert-monitor.service.ts
var import_common54 = require("@nestjs/common");
var import_schedule3 = require("@nestjs/schedule");
var AlertMonitorService = class {
  constructor(observability, alerting, prisma, otaService) {
    this.observability = observability;
    this.alerting = alerting;
    this.prisma = prisma;
    this.otaService = otaService;
    this.logger = new import_common54.Logger(AlertMonitorService.name);
    this.commsAlertsEnabled = (process.env.ENABLE_COMMS_METRICS ?? process.env.comms_alerts_enabled ?? "true").toString().toLowerCase() === "true";
    this.readyAlertsEnabled = (process.env.ENABLE_READY_PROBE ?? process.env.ready_checks_enabled ?? "true").toString().toLowerCase() === "true";
    this.otaAlertsEnabled = (process.env.ENABLE_OTA_MONITORING ?? process.env.ota_alerts_enabled ?? "true").toString().toLowerCase() === "true";
  }
  async evaluate() {
    try {
      const alerts = this.observability.alerts();
      const breaches = [];
      if (alerts.domain.redeem.breach) breaches.push("redeem failure spike");
      const offlineQueued = Object.entries(alerts.queues.state || {}).some(
        ([name, state]) => name?.toLowerCase().includes("offline") && (state?.queued ?? 0) > 0
      );
      if (alerts.domain.offlineBacklog.breach || offlineQueued) breaches.push("offline backlog");
      if (alerts.domain.offerLag.breach) breaches.push("offer lag high");
      if (alerts.domain.reports.breach) breaches.push("report failures");
      const hasDlq = Object.entries(alerts.queues.state || {}).some(
        ([name, state]) => name?.toLowerCase().includes("dlq") && (state?.queued ?? 0) > 0
      );
      if (hasDlq) breaches.push("DLQ non-empty");
      if (alerts.queues.lagBreaches.length > 0) breaches.push("queue lag");
      if (alerts.api.breaches.p95 || alerts.api.breaches.errorRate) breaches.push("API perf budget");
      if (alerts.web.breaches.lcp || alerts.web.breaches.ttfb) breaches.push("Web perf budget");
      if (this.commsAlertsEnabled && (alerts.comms.breaches.delivery || alerts.comms.breaches.bounce || alerts.comms.breaches.complaint)) {
        breaches.push("comms delivery/bounce");
      }
      if (this.commsAlertsEnabled && alerts.comms.breaches.smsFailures) {
        breaches.push("sms failures");
      }
      if (this.readyAlertsEnabled && alerts.domain.ready.breach) {
        breaches.push("readiness failing");
      }
      if (this.otaAlertsEnabled) {
        const ota = this.otaService.alerts?.() ?? { freshnessBreaches: [], webhookBreaches: [], successBreaches: [] };
        [...ota.freshnessBreaches || [], ...ota.webhookBreaches || [], ...ota.successBreaches || []].forEach((b) => {
          const ageSeconds = typeof b.ageMinutes === "number" ? b.ageMinutes * 60 : void 0;
          this.observability.recordOtaStatus(!(b.webhookErrorRate || b.ageMinutes === Infinity || (b.successRate ?? 1) < 0.95), ageSeconds, b);
        });
        if (ota.freshnessBreaches?.length) breaches.push("OTA backlog/freshness");
        if (ota.webhookBreaches?.length) breaches.push("OTA webhook error rate");
        if (ota.successBreaches?.length) breaches.push("OTA success rate drop");
      }
      const failedSynthetics = Object.entries(alerts.synthetics || {}).filter(([, v]) => v && !v.ok);
      if (failedSynthetics.length > 0) {
        breaches.push(`synthetics failing (${failedSynthetics.map(([k]) => k).join(", ")})`);
      }
      const reportSignal = await this.reportWindowSignal();
      if (reportSignal.breach && !breaches.includes("report failures")) {
        breaches.push("report failures");
      }
      if (breaches.length === 0) {
        return;
      }
      this.logger.warn(`Alert breaches detected: ${breaches.join(", ")}`);
      const message = `Alerts: ${breaches.join(", ")}
API p95=${alerts.api.p95}ms (budget ${alerts.targets.apiP95Ms}), errorRate=${alerts.api.errorRate.toFixed(3)}
Queues lag=${alerts.queues.lagBreaches.length}, depth=${alerts.queues.depthBreaches.length}
Comms delivery=${(alerts.comms.deliveryRate * 100).toFixed(1)}% bounce=${(alerts.comms.bounceRate * 100).toFixed(2)}% smsFail=${((alerts.comms.providers.twilio?.failureRate ?? 0) * 100).toFixed(2)}%`;
      await this.alerting.dispatch("Observability alerts firing", message, "error", "observability-breach", {
        breaches,
        api: alerts.api,
        comms: alerts.comms,
        queues: alerts.queues,
        reportRuns: reportSignal
      });
    } catch (err) {
      this.logger.error(`Alert evaluation failed: ${err?.message ?? err}`);
    }
  }
  async reportWindowSignal() {
    const since = new Date(Date.now() - 60 * 60 * 1e3);
    const [failures, total] = await Promise.all([
      this.prisma.reportRun.count({ where: { createdAt: { gte: since }, status: { in: ["failed", "error"] } } }),
      this.prisma.reportRun.count({ where: { createdAt: { gte: since } } })
    ]);
    const rate = total === 0 ? 0 : failures / total;
    return {
      failures,
      total,
      rate,
      breach: failures > 0 && rate > 0.05
    };
  }
};
__decorateClass([
  (0, import_schedule3.Cron)("*/5 * * * *")
], AlertMonitorService.prototype, "evaluate", 1);
AlertMonitorService = __decorateClass([
  (0, import_common54.Injectable)()
], AlertMonitorService);

// src/ota/ota.module.ts
var import_common58 = require("@nestjs/common");

// src/ota/ota.controller.ts
var import_common55 = require("@nestjs/common");
var OtaController = class {
  constructor(ota) {
    this.ota = ota;
  }
  getConfig(campgroundId) {
    return this.ota.getConfig(campgroundId);
  }
  saveConfig(campgroundId, body) {
    return this.ota.saveConfig(campgroundId, body);
  }
  getSyncStatus(campgroundId) {
    return this.ota.getSyncStatus(campgroundId);
  }
  listChannels(campgroundId) {
    return this.ota.listChannels(campgroundId);
  }
  createChannel(campgroundId, body) {
    return this.ota.createChannel(campgroundId, body);
  }
  updateChannel(id, body) {
    return this.ota.updateChannel(id, body);
  }
  listMappings(id) {
    return this.ota.listMappings(id);
  }
  upsertMapping(id, body) {
    return this.ota.upsertMapping(id, body);
  }
  ensureIcalToken(id) {
    return this.ota.ensureIcalToken(id);
  }
  setIcalUrl(id, body) {
    return this.ota.setIcalUrl(id, body?.url || "");
  }
  importIcal(id) {
    return this.ota.importIcal(id);
  }
  listLogs(id) {
    return this.ota.listSyncLogs?.(id) ?? [];
  }
  pushAvailability(id) {
    return this.ota.pushAvailability(id);
  }
  listImports(id) {
    return this.ota.listImports?.(id) ?? [];
  }
  webhook(provider, body, req, signature, timestamp) {
    const raw = req.rawBody ? req.rawBody.toString() : JSON.stringify(body);
    return this.ota.handleWebhook(provider, body, raw, signature, timestamp);
  }
  monitor() {
    return this.ota.monitor();
  }
  alerts() {
    return this.ota.alerts();
  }
};
__decorateClass([
  (0, import_common55.Get)("campgrounds/:campgroundId/config"),
  __decorateParam(0, (0, import_common55.Param)("campgroundId"))
], OtaController.prototype, "getConfig", 1);
__decorateClass([
  (0, import_common55.Post)("campgrounds/:campgroundId/config"),
  __decorateParam(0, (0, import_common55.Param)("campgroundId")),
  __decorateParam(1, (0, import_common55.Body)())
], OtaController.prototype, "saveConfig", 1);
__decorateClass([
  (0, import_common55.Get)("campgrounds/:campgroundId/sync-status"),
  __decorateParam(0, (0, import_common55.Param)("campgroundId"))
], OtaController.prototype, "getSyncStatus", 1);
__decorateClass([
  (0, import_common55.Get)("campgrounds/:campgroundId/channels"),
  __decorateParam(0, (0, import_common55.Param)("campgroundId"))
], OtaController.prototype, "listChannels", 1);
__decorateClass([
  (0, import_common55.Post)("campgrounds/:campgroundId/channels"),
  __decorateParam(0, (0, import_common55.Param)("campgroundId")),
  __decorateParam(1, (0, import_common55.Body)())
], OtaController.prototype, "createChannel", 1);
__decorateClass([
  (0, import_common55.Patch)("channels/:id"),
  __decorateParam(0, (0, import_common55.Param)("id")),
  __decorateParam(1, (0, import_common55.Body)())
], OtaController.prototype, "updateChannel", 1);
__decorateClass([
  (0, import_common55.Get)("channels/:id/mappings"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "listMappings", 1);
__decorateClass([
  (0, import_common55.Post)("channels/:id/mappings"),
  __decorateParam(0, (0, import_common55.Param)("id")),
  __decorateParam(1, (0, import_common55.Body)())
], OtaController.prototype, "upsertMapping", 1);
__decorateClass([
  (0, import_common55.Post)("mappings/:id/ical/token"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "ensureIcalToken", 1);
__decorateClass([
  (0, import_common55.Post)("mappings/:id/ical/url"),
  __decorateParam(0, (0, import_common55.Param)("id")),
  __decorateParam(1, (0, import_common55.Body)())
], OtaController.prototype, "setIcalUrl", 1);
__decorateClass([
  (0, import_common55.Post)("mappings/:id/ical/import"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "importIcal", 1);
__decorateClass([
  (0, import_common55.Get)("channels/:id/logs"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "listLogs", 1);
__decorateClass([
  (0, import_common55.Post)("channels/:id/push"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "pushAvailability", 1);
__decorateClass([
  (0, import_common55.Get)("channels/:id/imports"),
  __decorateParam(0, (0, import_common55.Param)("id"))
], OtaController.prototype, "listImports", 1);
__decorateClass([
  (0, import_common55.Post)("webhooks/:provider"),
  __decorateParam(0, (0, import_common55.Param)("provider")),
  __decorateParam(1, (0, import_common55.Body)()),
  __decorateParam(2, (0, import_common55.Req)()),
  __decorateParam(3, (0, import_common55.Headers)("x-ota-signature")),
  __decorateParam(4, (0, import_common55.Headers)("x-ota-timestamp"))
], OtaController.prototype, "webhook", 1);
__decorateClass([
  (0, import_common55.Get)("monitor")
], OtaController.prototype, "monitor", 1);
__decorateClass([
  (0, import_common55.Get)("alerts")
], OtaController.prototype, "alerts", 1);
OtaController = __decorateClass([
  (0, import_common55.UseGuards)(JwtAuthGuard),
  (0, import_common55.Controller)("ota")
], OtaController);

// src/ota/ota-public.controller.ts
var import_common56 = require("@nestjs/common");
var OtaPublicController = class {
  constructor(ota) {
    this.ota = ota;
  }
  async feed(token, res) {
    const ics = await this.ota.getIcsFeed(token);
    res.setHeader("Content-Type", "text/calendar; charset=utf-8");
    res.send(ics);
  }
};
__decorateClass([
  (0, import_common56.Get)(":token"),
  __decorateParam(0, (0, import_common56.Param)("token")),
  __decorateParam(1, (0, import_common56.Res)())
], OtaPublicController.prototype, "feed", 1);
OtaPublicController = __decorateClass([
  (0, import_common56.Controller)("ota/ical")
], OtaPublicController);

// src/ota/ota.service.ts
var import_common57 = require("@nestjs/common");
var import_crypto6 = require("crypto");
var import_crypto7 = require("crypto");
var OtaService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.configStore = /* @__PURE__ */ new Map();
    this.stats = /* @__PURE__ */ new Map();
    this.freshnessMinutes = Number(process.env.OTA_SYNC_MAX_AGE_MINUTES ?? 15);
    this.webhookErrorRateTarget = Number(process.env.OTA_WEBHOOK_ERROR_RATE ?? 0.01);
    this.successRateTarget = Number(process.env.OTA_SUCCESS_RATE ?? 0.95);
  }
  defaultConfig(campgroundId) {
    return {
      campgroundId,
      provider: "Hipcamp",
      externalAccountId: "",
      propertyId: "",
      apiKey: "",
      channelId: "",
      notes: null,
      lastSyncStatus: "not_started",
      lastSyncMessage: "Not connected yet. This endpoint is stubbed.",
      lastSyncAt: null,
      lastUpdatedAt: null,
      pendingSyncs: 0
    };
  }
  getConfig(campgroundId) {
    return this.configStore.get(campgroundId) ?? this.defaultConfig(campgroundId);
  }
  saveConfig(campgroundId, payload) {
    const base = this.getConfig(campgroundId);
    const saved = {
      ...base,
      ...payload,
      campgroundId,
      lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      lastSyncStatus: "stubbed",
      lastSyncMessage: "Saved locally. External provider calls are not wired yet.",
      pendingSyncs: 0,
      lastSyncAt: base.lastSyncAt ?? (/* @__PURE__ */ new Date()).toISOString()
    };
    this.configStore.set(campgroundId, saved);
    return saved;
  }
  getSyncStatus(campgroundId) {
    const config2 = this.getConfig(campgroundId);
    return {
      campgroundId,
      lastSyncStatus: config2.lastSyncStatus,
      lastSyncAt: config2.lastSyncAt ?? null,
      lastSyncMessage: config2.lastSyncMessage ?? "Not synced yet.",
      pendingSyncs: config2.pendingSyncs ?? 0
    };
  }
  listChannels(campgroundId) {
    return this.prisma.otaChannel.findMany({
      where: { campgroundId },
      include: { mappings: true },
      orderBy: { createdAt: "desc" }
    });
  }
  createChannel(campgroundId, data) {
    return this.prisma.otaChannel.create({
      data: {
        campgroundId,
        name: data.name,
        provider: data.provider,
        status: data.status ?? "disabled",
        rateMultiplier: data.rateMultiplier ?? 1,
        defaultStatus: data.defaultStatus ?? "confirmed",
        sendEmailNotifications: data.sendEmailNotifications ?? false,
        ignoreSiteRestrictions: data.ignoreSiteRestrictions ?? false,
        ignoreCategoryRestrictions: data.ignoreCategoryRestrictions ?? false,
        feeMode: data.feeMode ?? "absorb",
        webhookSecret: data.webhookSecret
      }
    });
  }
  updateChannel(id, data) {
    return this.prisma.otaChannel.update({
      where: { id },
      data
    });
  }
  listMappings(channelId) {
    return this.prisma.otaListingMapping.findMany({
      where: { channelId },
      include: {
        site: { select: { id: true, name: true } },
        siteClass: { select: { id: true, name: true } }
      },
      orderBy: { createdAt: "desc" }
    });
  }
  upsertMapping(channelId, body) {
    return this.prisma.otaListingMapping.upsert({
      where: { channelId_externalId: { channelId, externalId: body.externalId } },
      create: {
        channelId,
        externalId: body.externalId,
        siteId: body.siteId ?? null,
        siteClassId: body.siteClassId ?? null,
        status: body.status ?? "mapped"
      },
      update: {
        siteId: body.siteId ?? null,
        siteClassId: body.siteClassId ?? null,
        status: body.status ?? "mapped",
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  listImports(channelId) {
    return this.prisma.otaReservationImport.findMany({
      where: { channelId },
      orderBy: { createdAt: "desc" },
      take: 200
    });
  }
  listSyncLogs(channelId) {
    return this.prisma.otaSyncLog.findMany({
      where: { channelId },
      orderBy: { createdAt: "desc" },
      take: 200
    });
  }
  logSync(channelId, payload, direction, eventType, status, message) {
    return this.prisma.otaSyncLog.create({
      data: {
        channelId,
        direction,
        eventType,
        status,
        message,
        payload
      }
    });
  }
  verifyHmac(raw, secret, signature, timestamp) {
    if (!secret) return true;
    if (!signature) throw new import_common57.BadRequestException("Missing signature");
    if (timestamp) {
      const ts = Number(timestamp);
      if (!Number.isFinite(ts) || Math.abs(Date.now() - ts) > 5 * 60 * 1e3) {
        throw new import_common57.BadRequestException("Signature expired");
      }
    }
    const expected = (0, import_crypto6.createHmac)("sha256", secret).update(raw).digest("hex");
    if (expected !== signature) {
      throw new import_common57.BadRequestException("Invalid signature");
    }
    return true;
  }
  async ensureIcalToken(mappingId) {
    const mapping = await this.prisma.otaListingMapping.findUnique({
      where: { id: mappingId },
      select: { id: true, icalToken: true }
    });
    if (!mapping) throw new import_common57.NotFoundException("Mapping not found");
    if (mapping.icalToken) return mapping.icalToken;
    const token = (0, import_crypto7.randomUUID)();
    await this.prisma.otaListingMapping.update({
      where: { id: mappingId },
      data: { icalToken: token }
    });
    return token;
  }
  async setIcalUrl(mappingId, url) {
    await this.ensureIcalToken(mappingId);
    await this.prisma.otaListingMapping.update({
      where: { id: mappingId },
      data: { icalUrl: url || null }
    });
    return { ok: true };
  }
  formatIcsDate(date) {
    const pad = (n) => String(n).padStart(2, "0");
    return date.getUTCFullYear().toString() + pad(date.getUTCMonth() + 1) + pad(date.getUTCDate()) + "T" + pad(date.getUTCHours()) + pad(date.getUTCMinutes()) + pad(date.getUTCSeconds()) + "Z";
  }
  async getIcsFeed(token) {
    const mapping = await this.prisma.otaListingMapping.findFirst({
      where: { icalToken: token },
      select: { id: true, siteId: true, channelId: true }
    });
    if (!mapping) throw new import_common57.NotFoundException("Calendar not found");
    if (!mapping.siteId) throw new import_common57.BadRequestException("Mapping is not linked to a site");
    const reservations = await this.prisma.reservation.findMany({
      where: { siteId: mapping.siteId, status: { not: "cancelled" } },
      select: { id: true, arrivalDate: true, departureDate: true, guestId: true, bookedAt: true },
      orderBy: { arrivalDate: "asc" },
      take: 500
    });
    const blackouts = await this.prisma.blackoutDate.findMany({
      where: {
        OR: [{ siteId: mapping.siteId }, { siteId: null }]
      },
      select: { id: true, startDate: true, endDate: true, reason: true },
      orderBy: { startDate: "asc" },
      take: 200
    });
    const lines = [
      "BEGIN:VCALENDAR",
      "VERSION:2.0",
      "PRODID:-//Campreserv//OTA iCal//EN",
      "CALSCALE:GREGORIAN"
    ];
    for (const res of reservations) {
      lines.push(
        "BEGIN:VEVENT",
        `UID:${res.id}@campreserv`,
        `DTSTAMP:${this.formatIcsDate(new Date(res.bookedAt || res.arrivalDate))}`,
        `DTSTART:${this.formatIcsDate(new Date(res.arrivalDate))}`,
        `DTEND:${this.formatIcsDate(new Date(res.departureDate))}`,
        "SUMMARY:Reservation (busy)",
        "END:VEVENT"
      );
    }
    for (const b of blackouts) {
      lines.push(
        "BEGIN:VEVENT",
        `UID:${b.id}@campreserv`,
        `DTSTAMP:${this.formatIcsDate(new Date(b.startDate))}`,
        `DTSTART:${this.formatIcsDate(new Date(b.startDate))}`,
        `DTEND:${this.formatIcsDate(new Date(b.endDate))}`,
        `SUMMARY:Blocked${b.reason ? " - " + b.reason : ""}`,
        "END:VEVENT"
      );
    }
    lines.push("END:VCALENDAR");
    return lines.join("\r\n");
  }
  async importIcal(mappingId) {
    const mapping = await this.prisma.otaListingMapping.findUnique({
      where: { id: mappingId },
      select: { id: true, icalUrl: true, siteId: true, channelId: true, channel: { select: { campgroundId: true } } }
    });
    if (!mapping) throw new import_common57.NotFoundException("Mapping not found");
    if (!mapping.icalUrl) throw new import_common57.BadRequestException("No iCal URL configured for this mapping");
    if (!mapping.siteId) throw new import_common57.BadRequestException("Mapping missing siteId for import");
    const campgroundId = mapping.channel?.campgroundId;
    if (!campgroundId) throw new import_common57.BadRequestException("Mapping missing campground context");
    const res = await fetch(mapping.icalUrl);
    if (!res.ok) throw new import_common57.BadRequestException("Failed to fetch iCal feed");
    const text = await res.text();
    const events = [];
    const blocks = text.split("BEGIN:VEVENT").slice(1);
    for (const block of blocks) {
      const dtStartMatch = block.match(/DTSTART[^:]*:([^\r\n]+)/);
      const dtEndMatch = block.match(/DTEND[^:]*:([^\r\n]+)/);
      if (!dtStartMatch || !dtEndMatch) continue;
      const start = new Date(dtStartMatch[1]);
      const end = new Date(dtEndMatch[1]);
      if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) continue;
      const summaryMatch = block.match(/SUMMARY:([^\r\n]+)/);
      events.push({ start, end, summary: summaryMatch?.[1] });
    }
    await this.prisma.blackoutDate.deleteMany({
      where: { siteId: mapping.siteId, reason: { contains: `[ical:${mapping.id}]` } }
    });
    if (events.length > 0) {
      await this.prisma.blackoutDate.createMany({
        data: events.map((e) => ({
          campgroundId,
          siteId: mapping.siteId,
          startDate: e.start,
          endDate: e.end,
          reason: `${e.summary ?? "OTA iCal"} [ical:${mapping.id}]`
        })),
        skipDuplicates: true
      });
    }
    await this.logSync(mapping.channelId, { imported: events.length }, "pull", "availability", "success", "iCal import");
    this.recordSync("ical", campgroundId, true, "pull");
    return { ok: true, imported: events.length };
  }
  async handleWebhook(provider, body, rawBody, signature, timestamp) {
    const channel = await this.prisma.otaChannel.findFirst({
      where: { provider },
      select: { id: true, webhookSecret: true, campgroundId: true, defaultStatus: true, rateMultiplier: true, feeMode: true }
    });
    if (!channel?.id) {
      return { ok: true, ignored: true };
    }
    this.verifyHmac(rawBody, channel.webhookSecret || "", signature, timestamp);
    this.recordWebhook(provider, channel.campgroundId, true);
    const externalReservationId = body?.id || body?.reservationId || body?.externalId || "unknown";
    const importRecord = await this.prisma.otaReservationImport.upsert({
      where: { channelId_externalReservationId: { channelId: channel.id, externalReservationId } },
      create: {
        channelId: channel.id,
        externalReservationId,
        status: "pending",
        message: "Webhook received"
      },
      update: {
        status: "pending",
        message: "Webhook received"
      }
    });
    await this.logSync(channel.id, body, "pull", "reservation", "success", "Webhook received");
    const externalListingId = body?.listingId || body?.siteId || body?.siteExternalId || body?.listingExternalId || null;
    if (externalListingId) {
      const mapping = await this.prisma.otaListingMapping.findFirst({
        where: { channelId: channel.id, externalId: String(externalListingId) },
        select: { id: true, siteId: true, siteClassId: true }
      });
      if (!mapping) {
        await this.prisma.otaReservationImport.update({
          where: { id: importRecord.id },
          data: { status: "failed", message: "No mapping found for listing", updatedAt: /* @__PURE__ */ new Date() }
        });
        await this.logSync(channel.id, body, "pull", "reservation", "failed", "No mapping found");
        return { ok: false, reason: "no_mapping" };
      }
      await this.prisma.otaReservationImport.update({
        where: { id: importRecord.id },
        data: { message: "Mapping found; pending processing", status: "pending", updatedAt: /* @__PURE__ */ new Date() }
      });
      const normalizedStatus = this.mapExternalStatus(body?.status || body?.reservationStatus || body?.state);
      if (normalizedStatus === "cancelled") {
        if (importRecord.reservationId) {
          await this.prisma.reservation.update({
            where: { id: importRecord.reservationId },
            data: { status: "cancelled" }
          });
          await this.prisma.otaReservationImport.update({
            where: { id: importRecord.id },
            data: { status: "imported", message: "Cancelled", updatedAt: /* @__PURE__ */ new Date() }
          });
          await this.logSync(channel.id, body, "pull", "reservation", "success", "Cancelled reservation");
          this.recordSync(provider, channel.campgroundId, true, "pull");
          return { ok: true, importId: importRecord.id, reservationId: importRecord.reservationId, cancelled: true };
        } else {
          await this.prisma.otaReservationImport.update({
            where: { id: importRecord.id },
            data: { status: "failed", message: "Cancellation received but reservation not found", updatedAt: /* @__PURE__ */ new Date() }
          });
          await this.logSync(channel.id, body, "pull", "reservation", "failed", "Cancellation without reservation");
          return { ok: false, reason: "missing_reservation_for_cancel" };
        }
      }
      try {
        const result = await this.importReservationFromPayload({
          channelId: channel.id,
          campgroundId: channel.campgroundId,
          mappingId: mapping.id,
          siteId: mapping.siteId,
          siteClassId: mapping.siteClassId,
          payload: body,
          channelDefaultStatus: channel.defaultStatus,
          rateMultiplier: channel.rateMultiplier ?? 1,
          feeMode: channel.feeMode ?? "absorb"
        });
        await this.prisma.otaReservationImport.update({
          where: { id: importRecord.id },
          data: { status: "imported", message: "Imported", reservationId: result.reservationId, updatedAt: /* @__PURE__ */ new Date() }
        });
        await this.logSync(channel.id, body, "pull", "reservation", "success", "Imported");
        return { ok: true, importId: importRecord.id, reservationId: result.reservationId };
      } catch (err) {
        await this.prisma.otaReservationImport.update({
          where: { id: importRecord.id },
          data: { status: "failed", message: err?.message || "Import failed", updatedAt: /* @__PURE__ */ new Date() }
        });
        await this.logSync(channel.id, body, "pull", "reservation", "failed", err?.message || "Import failed");
        return { ok: false, reason: "import_failed", error: err?.message };
      }
    }
    return { ok: true, importId: importRecord.id };
  }
  async importReservationFromPayload(opts) {
    const { payload } = opts;
    const arrival = payload?.arrivalDate || payload?.startDate;
    const departure = payload?.departureDate || payload?.endDate;
    if (!arrival || !departure) throw new import_common57.BadRequestException("Missing arrival/departure dates");
    const guestEmail = payload?.guestEmail || payload?.email || payload?.guest?.email;
    const guestFirst = payload?.guestFirstName || payload?.firstName || payload?.guest?.firstName || "OTA Guest";
    const guestLast = payload?.guestLastName || payload?.lastName || payload?.guest?.lastName || "Imported";
    if (!guestEmail) throw new import_common57.BadRequestException("Missing guest email");
    const rateMultiplier = opts.rateMultiplier ?? 1;
    const baseSubtotal = Math.round((payload?.baseSubtotalCents ?? payload?.totalCents ?? 0) * rateMultiplier);
    const feesAmount = Math.round((payload?.feesCents ?? 0) * rateMultiplier);
    const taxesAmount = Math.round((payload?.taxesCents ?? 0) * rateMultiplier);
    const channelFeeCents = Math.round((payload?.channelFeeCents ?? payload?.commissionCents ?? 0) * rateMultiplier);
    const totalAmount = Math.max(0, baseSubtotal + feesAmount + taxesAmount);
    const existingGuest = await this.prisma.guest.findFirst({
      where: { email: guestEmail, campgroundId: opts.campgroundId },
      select: { id: true }
    });
    let guestId = existingGuest?.id;
    if (!guestId) {
      const guest = await this.prisma.guest.create({
        data: {
          campgroundId: opts.campgroundId,
          firstName: guestFirst,
          lastName: guestLast,
          email: guestEmail
        },
        select: { id: true }
      });
      guestId = guest.id;
    }
    let siteId = opts.siteId;
    if (!siteId && opts.siteClassId) {
      siteId = await this.findAvailableSiteInClass(opts.campgroundId, opts.siteClassId, new Date(arrival), new Date(departure));
    }
    if (!siteId) throw new import_common57.BadRequestException("Mapping missing siteId");
    const status = this.mapExternalStatus(payload?.status || payload?.reservationStatus || payload?.state) || (opts.channelDefaultStatus ?? "pending");
    const reservation = await this.prisma.reservation.create({
      data: {
        campgroundId: opts.campgroundId,
        siteId,
        guestId,
        arrivalDate: new Date(arrival),
        departureDate: new Date(departure),
        adults: payload?.adults ?? 2,
        children: payload?.children ?? 0,
        status,
        totalAmount,
        baseSubtotal,
        feesAmount,
        taxesAmount,
        balanceAmount: totalAmount,
        source: payload?.provider ?? payload?.channel ?? "ota",
        notes: `Imported from ${payload?.provider || "OTA"} | extRes: ${payload?.id ?? "n/a"}`,
        bookedAt: payload?.bookedAt ? new Date(payload.bookedAt) : /* @__PURE__ */ new Date()
      },
      select: { id: true }
    });
    const entries = [];
    if (totalAmount > 0) {
      entries.push({
        campgroundId: opts.campgroundId,
        reservationId: reservation.id,
        amountCents: totalAmount,
        direction: "credit",
        description: `OTA ${payload?.provider || "channel"} booking revenue`
      });
    }
    if (channelFeeCents > 0) {
      entries.push({
        campgroundId: opts.campgroundId,
        reservationId: reservation.id,
        amountCents: channelFeeCents,
        direction: opts.feeMode === "pass_through" ? "credit" : "debit",
        description: `OTA channel fee (${opts.feeMode === "pass_through" ? "pass-through" : "absorbed"})`
      });
    }
    if (entries.length > 0) {
      await this.prisma.ledgerEntry.createMany({ data: entries });
    }
    return { reservationId: reservation.id };
  }
  mapExternalStatus(raw) {
    if (!raw) return null;
    const s = String(raw).toLowerCase();
    if (["cancelled", "canceled", "void"].includes(s)) return "cancelled";
    if (["pending", "tentative", "unconfirmed", "hold"].includes(s)) return "pending";
    return "confirmed";
  }
  /**
   * Find an available site within a site class for the given date range.
   */
  async findAvailableSiteInClass(campgroundId, siteClassId, arrival, departure) {
    const sites = await this.prisma.site.findMany({
      where: { campgroundId, siteClassId, isActive: true },
      select: { id: true }
    });
    if (!sites?.length) return null;
    for (const s of sites) {
      const overlap = await this.prisma.$queryRaw`
        SELECT COUNT(*)::int as count
        FROM "Reservation" r
        WHERE r."siteId" = ${s.id}
          AND r."status" != 'cancelled'
          AND tstzrange(r."arrivalDate", r."departureDate", '[)'::text) && tstzrange(${arrival}, ${departure}, '[)'::text)
      `;
      const count = overlap?.[0]?.count ?? 0;
      if (count > 0) continue;
      const blackoutCount = await this.prisma.blackoutDate.count({
        where: {
          campgroundId,
          OR: [{ siteId: s.id }, { siteId: null }],
          startDate: { lt: departure },
          endDate: { gt: arrival }
        }
      });
      if (blackoutCount > 0) continue;
      return s.id;
    }
    return null;
  }
  /**
   * Manual availability/pricing push placeholder. In a real integration, this
   * would call the OTA provider API per mapped listing and enqueue retries.
   */
  async pushAvailability(channelId) {
    const channel = await this.prisma.otaChannel.findUnique({
      where: { id: channelId },
      select: { id: true, campgroundId: true, name: true, status: true, provider: true }
    });
    if (!channel) throw new import_common57.NotFoundException("Channel not found");
    const mappings = await this.prisma.otaListingMapping.findMany({
      where: { channelId },
      select: { id: true, externalId: true, siteId: true, siteClassId: true, status: true }
    });
    const now = /* @__PURE__ */ new Date();
    let successCount = 0;
    let errorCount = 0;
    const errors = [];
    for (const m of mappings) {
      if (m.status === "disabled") {
        errorCount++;
        await this.prisma.otaListingMapping.update({
          where: { id: m.id },
          data: { lastSyncAt: now, lastError: "Mapping disabled" }
        });
        continue;
      }
      if (!m.siteId) {
        errorCount++;
        await this.prisma.otaListingMapping.update({
          where: { id: m.id },
          data: { lastSyncAt: now, lastError: "Missing site mapping" }
        });
        continue;
      }
      await this.prisma.otaListingMapping.update({
        where: { id: m.id },
        data: { lastSyncAt: now, lastError: null }
      });
      successCount++;
    }
    await this.prisma.otaChannel.update({
      where: { id: channelId },
      data: { lastSyncAt: now }
    });
    const payload = {
      total: mappings.length,
      successCount,
      errorCount
    };
    await this.logSync(
      channelId,
      payload,
      "push",
      "availability",
      errorCount > 0 ? "failed" : "success",
      errorCount > 0 ? `Pushed with ${errorCount} errors` : "Availability/pricing push succeeded"
    );
    this.recordSync(channel.provider ?? "unknown", channel.campgroundId, errorCount === 0, "push");
    return { ok: true, total: mappings.length, successCount, errorCount };
  }
  monitor() {
    return Array.from(this.stats.values()).map((s) => {
      const successTotal = s.success + s.failure;
      const successRate = successTotal === 0 ? 1 : s.success / successTotal;
      const webhookTotal = s.webhookSuccess + s.webhookFailure;
      const webhookErrorRate = webhookTotal === 0 ? 0 : s.webhookFailure / webhookTotal;
      const ageMinutes = s.lastSuccessAt ? (Date.now() - s.lastSuccessAt) / 6e4 : Infinity;
      return {
        provider: s.provider,
        campgroundId: s.campgroundId,
        lastSuccessAt: s.lastSuccessAt ?? null,
        lastFailureAt: s.lastFailureAt ?? null,
        successRate,
        ageMinutes,
        webhookErrorRate,
        webhookLastFailureAt: s.lastWebhookFailureAt ?? null
      };
    });
  }
  alerts() {
    const monitors = this.monitor();
    const freshnessBreaches = monitors.filter((m) => m.ageMinutes === Infinity || m.ageMinutes > this.freshnessMinutes).map((m) => ({ provider: m.provider, campgroundId: m.campgroundId, ageMinutes: m.ageMinutes }));
    const webhookBreaches = monitors.filter((m) => m.webhookErrorRate > this.webhookErrorRateTarget).map((m) => ({
      provider: m.provider,
      campgroundId: m.campgroundId,
      webhookErrorRate: m.webhookErrorRate
    }));
    const successBreaches = monitors.filter((m) => (m.successRate ?? 1) < this.successRateTarget).map((m) => ({
      provider: m.provider,
      campgroundId: m.campgroundId,
      successRate: m.successRate ?? 1
    }));
    return {
      thresholds: {
        freshnessMinutes: this.freshnessMinutes,
        webhookErrorRate: this.webhookErrorRateTarget,
        successRate: this.successRateTarget
      },
      freshnessBreaches,
      webhookBreaches,
      successBreaches
    };
  }
  recordSync(provider, campgroundId, ok, _direction) {
    const key = `${provider}:${campgroundId}`;
    const s = this.stats.get(key) ?? {
      provider,
      campgroundId,
      success: 0,
      failure: 0,
      webhookFailure: 0,
      webhookSuccess: 0
    };
    if (ok) {
      s.success += 1;
      s.lastSuccessAt = Date.now();
    } else {
      s.failure += 1;
      s.lastFailureAt = Date.now();
    }
    this.stats.set(key, s);
  }
  recordWebhook(provider, campgroundId, ok) {
    const key = `${provider}:${campgroundId}`;
    const s = this.stats.get(key) ?? {
      provider,
      campgroundId,
      success: 0,
      failure: 0,
      webhookFailure: 0,
      webhookSuccess: 0
    };
    if (ok) {
      s.webhookSuccess += 1;
      s.lastWebhookSuccessAt = Date.now();
    } else {
      s.webhookFailure += 1;
      s.lastWebhookFailureAt = Date.now();
    }
    this.stats.set(key, s);
  }
};
OtaService = __decorateClass([
  (0, import_common57.Injectable)()
], OtaService);

// src/ota/ota.module.ts
var OtaModule = class {
};
OtaModule = __decorateClass([
  (0, import_common58.Module)({
    imports: [PrismaModule],
    controllers: [OtaController, OtaPublicController],
    providers: [OtaService],
    exports: [OtaService]
  })
], OtaModule);

// src/observability/synthetics.service.ts
var import_common59 = require("@nestjs/common");
var import_schedule4 = require("@nestjs/schedule");
var SyntheticsService = class {
  constructor(observability) {
    this.observability = observability;
    this.logger = new import_common59.Logger(SyntheticsService.name);
    this.enabled = (process.env.SYNTHETICS_ENABLED ?? "true").toLowerCase() === "true";
    this.baseUrl = process.env.SYNTHETIC_API_BASE;
    this.budgetMs = Number(process.env.SYNTHETIC_BUDGET_MS ?? 3e3);
  }
  async run() {
    if (!this.enabled || !this.baseUrl) {
      return;
    }
    const specs = [
      { name: "redeem", path: process.env.SYNTHETIC_REDEEM_PATH ?? "/api/health" },
      { name: "pos-order", path: process.env.SYNTHETIC_POS_PATH ?? "/api/health" },
      { name: "offer-accept", path: process.env.SYNTHETIC_OFFER_PATH ?? "/api/health" },
      { name: "report-export", path: process.env.SYNTHETIC_REPORT_PATH ?? "/api/health" }
    ];
    for (const spec of specs) {
      await this.runSingle(spec);
    }
  }
  async runSingle(spec) {
    const started = Date.now();
    const url = `${this.baseUrl}${spec.path}`;
    try {
      const headers = { "Content-Type": "application/json" };
      if (process.env.SYNTHETIC_TOKEN) {
        headers.Authorization = `Bearer ${process.env.SYNTHETIC_TOKEN}`;
      }
      const res = await fetch(url, {
        method: spec.method ?? "GET",
        headers,
        body: spec.body ? JSON.stringify(spec.body) : void 0
      });
      const latency = Date.now() - started;
      const ok = res.ok && latency <= this.budgetMs;
      this.observability.recordSynthetic(spec.name, ok, latency, ok ? void 0 : `HTTP ${res.status} latency ${latency}ms`);
      if (!ok) {
        this.logger.warn(`Synthetic ${spec.name} failed (${latency}ms)`);
      }
    } catch (err) {
      const latency = Date.now() - started;
      this.observability.recordSynthetic(spec.name, false, latency, err?.message);
      this.logger.warn(`Synthetic ${spec.name} error: ${err?.message ?? err}`);
    }
  }
};
__decorateClass([
  (0, import_schedule4.Cron)("*/5 * * * *")
], SyntheticsService.prototype, "run", 1);
SyntheticsService = __decorateClass([
  (0, import_common59.Injectable)()
], SyntheticsService);

// src/observability/observability.module.ts
var ObservabilityModule = class {
};
ObservabilityModule = __decorateClass([
  (0, import_common60.Global)(),
  (0, import_common60.Module)({
    imports: [PrismaModule, OtaModule],
    controllers: [ObservabilityController],
    providers: [
      ObservabilityService,
      JobQueueService,
      AlertingService,
      AlertMonitorService,
      SyntheticsService
    ],
    exports: [ObservabilityService, JobQueueService, AlertingService]
  })
], ObservabilityModule);

// src/waitlist/waitlist.module.ts
var WaitlistModule = class {
};
WaitlistModule = __decorateClass([
  (0, import_common61.Module)({
    imports: [PrismaModule, EmailModule, ObservabilityModule],
    controllers: [WaitlistController],
    providers: [WaitlistService, IdempotencyService],
    exports: [WaitlistService]
  })
], WaitlistModule);

// src/loyalty/loyalty.module.ts
var import_common64 = require("@nestjs/common");

// src/loyalty/loyalty.service.ts
var import_common62 = require("@nestjs/common");
var LoyaltyService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async getProfile(guestId) {
    const profile = await this.prisma.loyaltyProfile.findUnique({
      where: { guestId },
      include: {
        transactions: {
          orderBy: { createdAt: "desc" }
        }
      }
    });
    if (!profile) {
      return this.createProfile(guestId);
    }
    return profile;
  }
  async createProfile(guestId) {
    return this.prisma.loyaltyProfile.create({
      data: {
        guestId
      },
      include: {
        transactions: true
      }
    });
  }
  async awardPoints(guestId, amount, reason) {
    let profile = await this.prisma.loyaltyProfile.findUnique({
      where: { guestId }
    });
    if (!profile) {
      profile = await this.createProfile(guestId);
    }
    const newBalance = profile.pointsBalance + amount;
    const newTier = this.calculateTier(newBalance);
    return this.prisma.$transaction(async (tx) => {
      await tx.pointsTransaction.create({
        data: {
          profileId: profile.id,
          amount,
          reason
        }
      });
      return tx.loyaltyProfile.update({
        where: { id: profile.id },
        data: {
          pointsBalance: newBalance,
          tier: newTier
        }
      });
    });
  }
  calculateTier(points) {
    if (points >= 1e4) return "Platinum";
    if (points >= 5e3) return "Gold";
    if (points >= 1e3) return "Silver";
    return "Bronze";
  }
};
LoyaltyService = __decorateClass([
  (0, import_common62.Injectable)()
], LoyaltyService);

// src/loyalty/loyalty.controller.ts
var import_common63 = require("@nestjs/common");
var LoyaltyController = class {
  constructor(loyaltyService) {
    this.loyaltyService = loyaltyService;
  }
  async getGuestProfile(guestId) {
    return this.loyaltyService.getProfile(guestId);
  }
  async awardPoints(guestId, body) {
    return this.loyaltyService.awardPoints(guestId, body.amount, body.reason);
  }
};
__decorateClass([
  (0, import_common63.Get)("guests/:guestId"),
  __decorateParam(0, (0, import_common63.Param)("guestId"))
], LoyaltyController.prototype, "getGuestProfile", 1);
__decorateClass([
  (0, import_common63.Post)("guests/:guestId/points"),
  __decorateParam(0, (0, import_common63.Param)("guestId")),
  __decorateParam(1, (0, import_common63.Body)())
], LoyaltyController.prototype, "awardPoints", 1);
LoyaltyController = __decorateClass([
  (0, import_common63.UseGuards)(JwtAuthGuard),
  (0, import_common63.Controller)("loyalty")
], LoyaltyController);

// src/loyalty/loyalty.module.ts
var LoyaltyModule = class {
};
LoyaltyModule = __decorateClass([
  (0, import_common64.Module)({
    controllers: [LoyaltyController],
    providers: [LoyaltyService, PrismaService],
    exports: [LoyaltyService]
  })
], LoyaltyModule);

// src/seasonal-rates/seasonal-rates.module.ts
var import_common67 = require("@nestjs/common");

// src/seasonal-rates/seasonal-rates.service.ts
var import_common65 = require("@nestjs/common");
var SeasonalRatesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(data) {
    return this.prisma.seasonalRate.create({
      data: {
        campgroundId: data.campgroundId,
        siteClassId: data.siteClassId,
        name: data.name,
        rateType: data.rateType,
        amount: data.amount,
        minNights: data.minNights,
        startDate: data.startDate,
        endDate: data.endDate
      }
    });
  }
  async findAllByCampground(campgroundId) {
    return this.prisma.seasonalRate.findMany({
      where: { campgroundId },
      include: { siteClass: true },
      orderBy: { minNights: "desc" }
    });
  }
  async findOne(id) {
    const rate = await this.prisma.seasonalRate.findUnique({
      where: { id },
      include: { siteClass: true }
    });
    if (!rate) throw new import_common65.NotFoundException("Seasonal rate not found");
    return rate;
  }
  async update(id, data) {
    return this.prisma.seasonalRate.update({
      where: { id },
      data
    });
  }
  async remove(id) {
    return this.prisma.seasonalRate.delete({ where: { id } });
  }
  // Find the best applicable rate for a reservation
  async findApplicableRate(campgroundId, siteClassId, nights, arrivalDate) {
    const rates = await this.prisma.seasonalRate.findMany({
      where: {
        campgroundId,
        isActive: true,
        OR: [
          { siteClassId: null },
          // Campground-wide rates
          { siteClassId: siteClassId || void 0 }
          // Class-specific rates
        ]
      },
      orderBy: [
        { minNights: "desc" }
        // Prefer longer-stay rates first
      ]
    });
    for (const rate of rates) {
      if (rate.minNights && nights < rate.minNights) continue;
      if (rate.startDate && arrivalDate < rate.startDate) continue;
      if (rate.endDate && arrivalDate > rate.endDate) continue;
      return rate;
    }
    return null;
  }
};
SeasonalRatesService = __decorateClass([
  (0, import_common65.Injectable)()
], SeasonalRatesService);

// src/seasonal-rates/seasonal-rates.controller.ts
var import_common66 = require("@nestjs/common");
var SeasonalRatesController = class {
  constructor(seasonalRatesService) {
    this.seasonalRatesService = seasonalRatesService;
  }
  create(body) {
    return this.seasonalRatesService.create(body);
  }
  findAllByCampground(campgroundId) {
    return this.seasonalRatesService.findAllByCampground(campgroundId);
  }
  findOne(id) {
    return this.seasonalRatesService.findOne(id);
  }
  update(id, body) {
    return this.seasonalRatesService.update(id, body);
  }
  remove(id) {
    return this.seasonalRatesService.remove(id);
  }
};
__decorateClass([
  (0, import_common66.Post)(),
  __decorateParam(0, (0, import_common66.Body)())
], SeasonalRatesController.prototype, "create", 1);
__decorateClass([
  (0, import_common66.Get)("campground/:campgroundId"),
  __decorateParam(0, (0, import_common66.Param)("campgroundId"))
], SeasonalRatesController.prototype, "findAllByCampground", 1);
__decorateClass([
  (0, import_common66.Get)(":id"),
  __decorateParam(0, (0, import_common66.Param)("id"))
], SeasonalRatesController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common66.Patch)(":id"),
  __decorateParam(0, (0, import_common66.Param)("id")),
  __decorateParam(1, (0, import_common66.Body)())
], SeasonalRatesController.prototype, "update", 1);
__decorateClass([
  (0, import_common66.Delete)(":id"),
  __decorateParam(0, (0, import_common66.Param)("id"))
], SeasonalRatesController.prototype, "remove", 1);
SeasonalRatesController = __decorateClass([
  (0, import_common66.UseGuards)(JwtAuthGuard),
  (0, import_common66.Controller)("seasonal-rates")
], SeasonalRatesController);

// src/seasonal-rates/seasonal-rates.module.ts
var SeasonalRatesModule = class {
};
SeasonalRatesModule = __decorateClass([
  (0, import_common67.Module)({
    controllers: [SeasonalRatesController],
    providers: [SeasonalRatesService, PrismaService],
    exports: [SeasonalRatesService]
  })
], SeasonalRatesModule);

// src/tax-rules/tax-rules.module.ts
var import_common70 = require("@nestjs/common");

// src/tax-rules/tax-rules.service.ts
var import_common68 = require("@nestjs/common");
var TaxRulesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(data) {
    return this.prisma.taxRule.create({
      data: {
        campgroundId: data.campgroundId,
        name: data.name,
        type: data.type,
        rate: data.rate,
        minNights: data.minNights,
        maxNights: data.maxNights,
        requiresWaiver: data.requiresWaiver ?? false,
        waiverText: data.waiverText
      }
    });
  }
  async findAllByCampground(campgroundId) {
    return this.prisma.taxRule.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" }
    });
  }
  async findOne(id) {
    const rule = await this.prisma.taxRule.findUnique({ where: { id } });
    if (!rule) throw new import_common68.NotFoundException("Tax rule not found");
    return rule;
  }
  async update(id, data) {
    return this.prisma.taxRule.update({
      where: { id },
      data
    });
  }
  async remove(id) {
    return this.prisma.taxRule.delete({ where: { id } });
  }
  // Evaluate applicable tax exemption for a reservation
  async evaluateExemption(campgroundId, nights, waiverSigned) {
    const rules = await this.prisma.taxRule.findMany({
      where: {
        campgroundId,
        type: "exemption",
        isActive: true
      }
    });
    for (const rule of rules) {
      const meetsMinNights = rule.minNights ? nights >= rule.minNights : true;
      const meetsMaxNights = rule.maxNights ? nights <= rule.maxNights : true;
      if (meetsMinNights && meetsMaxNights) {
        if (rule.requiresWaiver && !waiverSigned) {
          return { eligible: true, applied: false, rule, reason: "Waiver required" };
        }
        return { eligible: true, applied: true, rule };
      }
    }
    return { eligible: false, applied: false, rule: null };
  }
};
TaxRulesService = __decorateClass([
  (0, import_common68.Injectable)()
], TaxRulesService);

// src/tax-rules/tax-rules.controller.ts
var import_common69 = require("@nestjs/common");
var TaxRulesController = class {
  constructor(taxRulesService) {
    this.taxRulesService = taxRulesService;
  }
  create(body) {
    return this.taxRulesService.create(body);
  }
  findAllByCampground(campgroundId) {
    return this.taxRulesService.findAllByCampground(campgroundId);
  }
  findOne(id) {
    return this.taxRulesService.findOne(id);
  }
  update(id, body) {
    return this.taxRulesService.update(id, body);
  }
  remove(id) {
    return this.taxRulesService.remove(id);
  }
};
__decorateClass([
  (0, import_common69.Post)(),
  __decorateParam(0, (0, import_common69.Body)())
], TaxRulesController.prototype, "create", 1);
__decorateClass([
  (0, import_common69.Get)("campground/:campgroundId"),
  __decorateParam(0, (0, import_common69.Param)("campgroundId"))
], TaxRulesController.prototype, "findAllByCampground", 1);
__decorateClass([
  (0, import_common69.Get)(":id"),
  __decorateParam(0, (0, import_common69.Param)("id"))
], TaxRulesController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common69.Patch)(":id"),
  __decorateParam(0, (0, import_common69.Param)("id")),
  __decorateParam(1, (0, import_common69.Body)())
], TaxRulesController.prototype, "update", 1);
__decorateClass([
  (0, import_common69.Delete)(":id"),
  __decorateParam(0, (0, import_common69.Param)("id"))
], TaxRulesController.prototype, "remove", 1);
TaxRulesController = __decorateClass([
  (0, import_common69.UseGuards)(JwtAuthGuard),
  (0, import_common69.Controller)("tax-rules")
], TaxRulesController);

// src/tax-rules/tax-rules.module.ts
var TaxRulesModule = class {
};
TaxRulesModule = __decorateClass([
  (0, import_common70.Module)({
    controllers: [TaxRulesController],
    providers: [TaxRulesService, PrismaService],
    exports: [TaxRulesService]
  })
], TaxRulesModule);

// src/gamification/gamification.module.ts
var import_common73 = require("@nestjs/common");

// src/gamification/gamification.controller.ts
var import_common71 = require("@nestjs/common");
var GamificationController = class {
  constructor(gamificationService) {
    this.gamificationService = gamificationService;
  }
  resolveCampgroundId(req, provided) {
    const cg = provided || req.headers?.["x-campground-id"] || req.query?.campgroundId;
    if (!cg || typeof cg !== "string") {
      throw new import_common71.BadRequestException("campgroundId is required");
    }
    return cg;
  }
  getDashboard(req, campgroundId) {
    const cg = this.resolveCampgroundId(req, campgroundId);
    return this.gamificationService.getDashboard(req.user.id, cg);
  }
  getSettings(req, campgroundId) {
    const cg = this.resolveCampgroundId(req, campgroundId);
    return this.gamificationService.getSettingsForManager(req.user.id, cg);
  }
  updateSettings(req, body) {
    const cg = this.resolveCampgroundId(req, body?.campgroundId);
    const rawEnabled = body?.enabled;
    let enabled;
    if (typeof rawEnabled === "boolean") {
      enabled = rawEnabled;
    } else if (typeof rawEnabled === "string") {
      const v = rawEnabled.trim().toLowerCase();
      if (v === "true") enabled = true;
      else if (v === "false") enabled = false;
      else throw new import_common71.BadRequestException("enabled must be a boolean");
    } else if (typeof rawEnabled === "number") {
      enabled = rawEnabled === 1;
    } else {
      throw new import_common71.BadRequestException("enabled must be a boolean");
    }
    const enabledRoles = Array.isArray(body?.enabledRoles) ? body.enabledRoles.filter((r) => typeof r === "string") : [];
    return this.gamificationService.updateSettings(req.user.id, {
      campgroundId: cg,
      enabled,
      enabledRoles
    });
  }
  getRules(req, campgroundId) {
    const cg = this.resolveCampgroundId(req, campgroundId);
    return this.gamificationService.getRules(req.user.id, cg);
  }
  upsertRule(req, body) {
    const cg = this.resolveCampgroundId(req, body?.campgroundId);
    return this.gamificationService.upsertRule(req.user.id, { ...body, campgroundId: cg });
  }
  manualAward(req, body) {
    const cg = this.resolveCampgroundId(req, body?.campgroundId);
    return this.gamificationService.manualAward(req.user.id, { ...body, campgroundId: cg });
  }
  listLevels() {
    return this.gamificationService.getLevels();
  }
  getLeaderboard(req, campgroundId, days, limit) {
    const cg = this.resolveCampgroundId(req, campgroundId);
    const parsedDays = days ? Number(days) : void 0;
    const parsedLimit = limit ? Number(limit) : void 0;
    return this.gamificationService.getLeaderboard({
      campgroundId: cg,
      viewerId: req.user.id,
      days: parsedDays,
      limit: parsedLimit
    });
  }
  getStats(req, campgroundId, days) {
    const cg = this.resolveCampgroundId(req, campgroundId);
    const parsedDays = days ? Number(days) : void 0;
    return this.gamificationService.getStats(cg, parsedDays);
  }
};
__decorateClass([
  (0, import_common71.Get)("dashboard"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Query)("campgroundId"))
], GamificationController.prototype, "getDashboard", 1);
__decorateClass([
  (0, import_common71.Get)("settings"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Query)("campgroundId"))
], GamificationController.prototype, "getSettings", 1);
__decorateClass([
  (0, import_common71.Patch)("settings"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Body)())
], GamificationController.prototype, "updateSettings", 1);
__decorateClass([
  (0, import_common71.Get)("rules"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Query)("campgroundId"))
], GamificationController.prototype, "getRules", 1);
__decorateClass([
  (0, import_common71.Post)("rules"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Body)())
], GamificationController.prototype, "upsertRule", 1);
__decorateClass([
  (0, import_common71.Post)("award"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Body)())
], GamificationController.prototype, "manualAward", 1);
__decorateClass([
  (0, import_common71.Get)("levels")
], GamificationController.prototype, "listLevels", 1);
__decorateClass([
  (0, import_common71.Get)("leaderboard"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Query)("campgroundId")),
  __decorateParam(2, (0, import_common71.Query)("days")),
  __decorateParam(3, (0, import_common71.Query)("limit"))
], GamificationController.prototype, "getLeaderboard", 1);
__decorateClass([
  (0, import_common71.Get)("stats"),
  __decorateParam(0, (0, import_common71.Request)()),
  __decorateParam(1, (0, import_common71.Query)("campgroundId")),
  __decorateParam(2, (0, import_common71.Query)("days"))
], GamificationController.prototype, "getStats", 1);
GamificationController = __decorateClass([
  (0, import_common71.UseGuards)(JwtAuthGuard),
  (0, import_common71.Controller)("gamification")
], GamificationController);

// src/gamification/gamification.service.ts
var import_common72 = require("@nestjs/common");
var import_client11 = require("@prisma/client");
var GamificationService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.defaultRules = [
      { category: "task", minXp: 5, maxXp: 25, defaultXp: 10 },
      { category: "maintenance", minXp: 10, maxXp: 40, defaultXp: 20 },
      { category: "check_in", minXp: 5, maxXp: 25, defaultXp: 15 },
      { category: "reservation_quality", minXp: 5, maxXp: 20, defaultXp: 10 },
      { category: "checklist", minXp: 2, maxXp: 10, defaultXp: 5 },
      { category: "review_mention", minXp: 15, maxXp: 50, defaultXp: 25 },
      { category: "on_time_assignment", minXp: 5, maxXp: 20, defaultXp: 10 },
      { category: "assist", minXp: 5, maxXp: 20, defaultXp: 10 },
      { category: "manual", minXp: 5, maxXp: 100, defaultXp: 25 },
      { category: "other", minXp: 1, maxXp: 10, defaultXp: 5 }
    ];
  }
  async getSettings(campgroundId) {
    const setting = await this.prisma.gamificationSetting.findUnique({
      where: { campgroundId }
    });
    return setting ?? { campgroundId, enabled: false, enabledRoles: [] };
  }
  roleAllowed(setting, role) {
    if (!setting.enabledRoles || setting.enabledRoles.length === 0) return true;
    if (!role) return false;
    return setting.enabledRoles.includes(role);
  }
  async getMembership(userId, campgroundId) {
    return this.prisma.campgroundMembership.findFirst({
      where: { userId, campgroundId }
    });
  }
  async assertManager(userId, campgroundId) {
    const membership = await this.getMembership(userId, campgroundId);
    const allowedRoles = [import_client11.UserRole.owner, import_client11.UserRole.manager];
    if (!membership || !allowedRoles.includes(membership.role)) {
      throw new import_common72.ForbiddenException("Manager or owner role required for gamification settings");
    }
    return membership;
  }
  async getLevelDefinitions(client = this.prisma) {
    return client.levelDefinition.findMany({
      orderBy: { minXp: "asc" }
    });
  }
  computeLevel(totalXp, levels) {
    if (!levels || levels.length === 0) {
      return { level: 1, minXp: 0, progressToNext: 0, nextLevel: null, nextMinXp: null, name: null };
    }
    const sorted = [...levels].sort((a, b) => a.minXp - b.minXp);
    let current = sorted[0];
    for (const lvl of sorted) {
      if (lvl.minXp <= totalXp) current = lvl;
      else break;
    }
    const next = sorted.find((l) => l.minXp > totalXp) ?? null;
    const progressToNext = next ? Math.min(1, Math.max(0, (totalXp - current.minXp) / Math.max(1, next.minXp - current.minXp))) : 1;
    return {
      level: current.level,
      name: current.name,
      minXp: current.minXp,
      nextLevel: next?.level ?? null,
      nextMinXp: next?.minXp ?? null,
      progressToNext
    };
  }
  resolveXpAmount(inputXp, rule) {
    const base = inputXp ?? rule?.defaultXp ?? 10;
    if (!rule) return base;
    const clampedMin = rule.minXp ?? base;
    const clampedMax = rule.maxXp ?? base;
    return Math.min(clampedMax || base, Math.max(clampedMin || base, base));
  }
  async updateSettings(userId, dto) {
    await this.assertManager(userId, dto.campgroundId);
    const setting = await this.prisma.gamificationSetting.upsert({
      where: { campgroundId: dto.campgroundId },
      create: {
        campgroundId: dto.campgroundId,
        enabled: dto.enabled ?? false,
        enabledRoles: dto.enabledRoles ?? []
      },
      update: {
        enabled: dto.enabled ?? false,
        enabledRoles: dto.enabledRoles ?? []
      }
    });
    if (setting.enabled) {
      const existingRules = await this.prisma.xpRule.count({ where: { campgroundId: dto.campgroundId } });
      if (existingRules === 0) {
        await this.prisma.xpRule.createMany({
          data: this.defaultRules.map((r) => ({
            campgroundId: dto.campgroundId,
            category: r.category,
            minXp: r.minXp,
            maxXp: r.maxXp,
            defaultXp: r.defaultXp,
            isActive: true,
            createdById: userId
          })),
          skipDuplicates: true
        });
      }
    }
    return setting;
  }
  async getSettingsForManager(userId, campgroundId) {
    await this.assertManager(userId, campgroundId);
    return this.getSettings(campgroundId);
  }
  async getRules(userId, campgroundId) {
    await this.assertManager(userId, campgroundId);
    return this.prisma.xpRule.findMany({
      where: { campgroundId },
      orderBy: { category: "asc" }
    });
  }
  async upsertRule(userId, dto) {
    await this.assertManager(userId, dto.campgroundId);
    return this.prisma.xpRule.upsert({
      where: { campgroundId_category: { campgroundId: dto.campgroundId, category: dto.category } },
      create: {
        campgroundId: dto.campgroundId,
        category: dto.category,
        minXp: dto.minXp ?? 0,
        maxXp: dto.maxXp ?? 0,
        defaultXp: dto.defaultXp ?? 0,
        isActive: dto.isActive ?? true,
        createdById: userId
      },
      update: {
        minXp: dto.minXp ?? 0,
        maxXp: dto.maxXp ?? 0,
        defaultXp: dto.defaultXp ?? 0,
        isActive: dto.isActive ?? true,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async getLevels() {
    return this.getLevelDefinitions();
  }
  async recordEvent(params) {
    const [setting, membership, rule] = await Promise.all([
      this.getSettings(params.campgroundId),
      this.getMembership(params.userId, params.campgroundId),
      this.prisma.xpRule.findUnique({
        where: { campgroundId_category: { campgroundId: params.campgroundId, category: params.category } }
      })
    ]);
    if (!membership) {
      return { skipped: true, reason: "User is not a member of this campground", setting, membershipRole: null };
    }
    if (!setting.enabled) {
      return { skipped: true, reason: "Gamification is disabled for this campground", setting, membershipRole: membership.role };
    }
    if (!this.roleAllowed(setting, membership.role)) {
      return { skipped: true, reason: "Gamification disabled for this role", setting, membershipRole: membership.role };
    }
    const xpAmount = this.resolveXpAmount(params.xpOverride, rule);
    if (xpAmount === 0) {
      return { skipped: true, reason: "XP resolved to zero; skipping", setting, membershipRole: membership.role };
    }
    const levels = await this.getLevelDefinitions();
    const result = await this.prisma.$transaction(async (tx) => {
      let event;
      try {
        event = await tx.xpEvent.create({
          data: {
            campgroundId: params.campgroundId,
            userId: params.userId,
            membershipId: params.membershipId ?? membership.id,
            category: params.category,
            xp: xpAmount,
            reason: params.reason,
            sourceType: params.sourceType,
            sourceId: params.sourceId,
            eventKey: params.eventKey,
            metadata: params.metadata
          }
        });
      } catch (err) {
        const isUniqueKey = err instanceof import_client11.Prisma.PrismaClientKnownRequestError && err.code === "P2002" && params.eventKey;
        if (isUniqueKey) {
          event = await tx.xpEvent.findUnique({ where: { eventKey: params.eventKey } });
        } else {
          throw err;
        }
      }
      if (!event) {
        return { skipped: true, reason: "Event was not created", setting, membershipRole: membership.role };
      }
      const balance = await tx.xpBalance.upsert({
        where: { campgroundId_userId: { campgroundId: params.campgroundId, userId: params.userId } },
        create: {
          campgroundId: params.campgroundId,
          userId: params.userId,
          totalXp: xpAmount,
          currentLevel: 1,
          lastEventAt: event.createdAt
        },
        update: {
          totalXp: { increment: xpAmount },
          lastEventAt: event.createdAt
        }
      });
      const levelInfo = this.computeLevel(balance.totalXp, levels);
      const updatedBalance = await tx.xpBalance.update({
        where: { id: balance.id },
        data: { currentLevel: levelInfo.level }
      });
      return { event, balance: updatedBalance, level: levelInfo, ruleApplied: rule?.id };
    });
    return { ...result, setting, membershipRole: membership.role, skipped: false };
  }
  async manualAward(actorId, dto) {
    await this.assertManager(actorId, dto.campgroundId);
    return this.recordEvent({
      campgroundId: dto.campgroundId,
      userId: dto.targetUserId,
      membershipId: dto.membershipId,
      category: dto.category,
      xpOverride: dto.xp,
      reason: dto.reason ?? "Merit XP",
      sourceType: dto.sourceType ?? "manual_award",
      sourceId: dto.sourceId,
      eventKey: dto.eventKey,
      metadata: dto.metadata
    });
  }
  async getDashboard(userId, campgroundId) {
    const [setting, membership] = await Promise.all([
      this.getSettings(campgroundId),
      this.getMembership(userId, campgroundId)
    ]);
    if (!membership) {
      return { enabled: false, allowed: false, membershipRole: null, setting };
    }
    const allowed = this.roleAllowed(setting, membership.role);
    if (!setting.enabled || !allowed) {
      return {
        enabled: false,
        allowed,
        membershipRole: membership.role,
        setting
      };
    }
    const [balance, recentEvents, levels] = await Promise.all([
      this.prisma.xpBalance.findUnique({
        where: { campgroundId_userId: { campgroundId, userId } }
      }),
      this.prisma.xpEvent.findMany({
        where: { campgroundId, userId },
        orderBy: { createdAt: "desc" },
        take: 20
      }),
      this.getLevelDefinitions()
    ]);
    const totalXp = balance?.totalXp ?? 0;
    const level = this.computeLevel(totalXp, levels);
    return {
      enabled: true,
      allowed: true,
      membershipRole: membership.role,
      setting,
      balance: balance ?? {
        id: null,
        campgroundId,
        userId,
        totalXp,
        currentLevel: level.level,
        lastEventAt: null,
        createdAt: null,
        updatedAt: null
      },
      level,
      recentEvents
    };
  }
  async getLeaderboard(params) {
    const { campgroundId, viewerId } = params;
    const days = params.days ?? 7;
    const limit = params.limit ?? 5;
    const since = days > 0 ? (() => {
      const d = /* @__PURE__ */ new Date();
      d.setDate(d.getDate() - days);
      return d;
    })() : null;
    const rows = await this.prisma.xpEvent.groupBy({
      by: ["userId"],
      where: { campgroundId, ...since ? { createdAt: { gte: since } } : {} },
      _sum: { xp: true },
      orderBy: { _sum: { xp: "desc" } },
      take: limit
    });
    const userIds = rows.map((r) => r.userId);
    const users = await this.prisma.user.findMany({
      where: { id: { in: userIds } },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        memberships: {
          where: { campgroundId },
          select: { role: true }
        }
      }
    });
    const userMap = new Map(users.map((u) => [u.id, u]));
    const leaderboard = rows.map((r, idx) => {
      const u = userMap.get(r.userId);
      return {
        userId: r.userId,
        rank: idx + 1,
        xp: r._sum.xp ?? 0,
        name: u ? `${u.firstName ?? ""} ${u.lastName ?? ""}`.trim() || u.email : "Unknown",
        role: u?.memberships?.[0]?.role ?? null
      };
    });
    const viewerRow = leaderboard.find((r) => r.userId === viewerId);
    let viewer = viewerRow;
    if (!viewerRow) {
      const viewerAgg = await this.prisma.xpEvent.groupBy({
        by: ["userId"],
        where: { campgroundId, ...since ? { createdAt: { gte: since } } : {}, userId: viewerId },
        _sum: { xp: true }
      });
      if (viewerAgg[0]) {
        const u = await this.prisma.user.findUnique({
          where: { id: viewerId },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            memberships: { where: { campgroundId }, select: { role: true } }
          }
        });
        viewer = {
          userId: viewerId,
          rank: 0,
          xp: viewerAgg[0]._sum.xp ?? 0,
          name: u ? `${u.firstName ?? ""} ${u.lastName ?? ""}`.trim() || u.email : "You",
          role: u?.memberships?.[0]?.role ?? null
        };
      }
    }
    return { leaderboard, viewer, since };
  }
  async getStats(campgroundId, days = 30) {
    const since = /* @__PURE__ */ new Date();
    since.setDate(since.getDate() - days);
    const categories = await this.prisma.xpEvent.groupBy({
      by: ["category"],
      where: { campgroundId, createdAt: { gte: since } },
      _sum: { xp: true },
      orderBy: { _sum: { xp: "desc" } }
    });
    return {
      categories: categories.map((c) => ({ category: c.category, xp: c._sum.xp ?? 0 })),
      since
    };
  }
};
GamificationService = __decorateClass([
  (0, import_common72.Injectable)()
], GamificationService);

// src/gamification/gamification.module.ts
var GamificationModule = class {
};
GamificationModule = __decorateClass([
  (0, import_common73.Module)({
    imports: [PrismaModule],
    controllers: [GamificationController],
    providers: [GamificationService],
    exports: [GamificationService]
  })
], GamificationModule);

// src/reservations/reservation-import-export.service.ts
var import_common74 = require("@nestjs/common");

// src/reservations/dto/reservation-import.dto.ts
var import_zod = require("zod");
var reservationImportRecordSchema = import_zod.z.object({
  externalId: import_zod.z.string().min(1).optional(),
  campgroundId: import_zod.z.string().min(1),
  siteId: import_zod.z.string().min(1),
  guestId: import_zod.z.string().min(1),
  arrivalDate: import_zod.z.string().min(1),
  departureDate: import_zod.z.string().min(1),
  adults: import_zod.z.coerce.number().int().nonnegative(),
  children: import_zod.z.coerce.number().int().nonnegative().default(0),
  status: import_zod.z.enum(["pending", "confirmed", "checked_in", "checked_out", "cancelled"]).default("confirmed"),
  totalAmount: import_zod.z.coerce.number().int().nonnegative(),
  paidAmount: import_zod.z.coerce.number().int().nonnegative().optional(),
  notes: import_zod.z.string().optional(),
  source: import_zod.z.string().optional(),
  promoCode: import_zod.z.string().optional(),
  rigType: import_zod.z.string().optional(),
  rigLength: import_zod.z.coerce.number().int().nonnegative().optional(),
  holdId: import_zod.z.string().optional(),
  createdBy: import_zod.z.string().optional(),
  updatedBy: import_zod.z.string().optional()
}).superRefine((value, ctx) => {
  const arrival = new Date(value.arrivalDate);
  const departure = new Date(value.departureDate);
  if (!(arrival instanceof Date) || isNaN(arrival.valueOf())) {
    ctx.addIssue({ code: import_zod.z.ZodIssueCode.custom, path: ["arrivalDate"], message: "Invalid arrivalDate" });
  }
  if (!(departure instanceof Date) || isNaN(departure.valueOf())) {
    ctx.addIssue({ code: import_zod.z.ZodIssueCode.custom, path: ["departureDate"], message: "Invalid departureDate" });
  }
  if (arrival instanceof Date && departure instanceof Date && !isNaN(arrival.valueOf()) && !isNaN(departure.valueOf()) && departure <= arrival) {
    ctx.addIssue({ code: import_zod.z.ZodIssueCode.custom, path: ["departureDate"], message: "departureDate must be after arrivalDate" });
  }
});
var reservationImportCsvColumns = [
  "campgroundId",
  "siteId",
  "guestId",
  "arrivalDate",
  "departureDate",
  "adults",
  "children",
  "status",
  "totalAmount",
  "paidAmount",
  "notes",
  "source",
  "promoCode",
  "externalId",
  "rigType",
  "rigLength",
  "holdId"
];
var reservationImportSchemaSummary = {
  requiredFields: ["campgroundId", "siteId", "guestId", "arrivalDate", "departureDate", "adults", "totalAmount"],
  optionalFields: ["children", "status", "paidAmount", "notes", "source", "promoCode", "externalId", "rigType", "rigLength", "holdId"],
  rules: [
    "departureDate must be after arrivalDate",
    "totals and paid amounts must be non-negative integers (cents)",
    "status must be one of pending|confirmed|checked_in|checked_out|cancelled",
    "campgroundId in file must match request path",
    "adults/children parsed as integers; defaults children to 0"
  ]
};

// src/reservations/reservation-import-export.service.ts
var ReservationImportExportService = class {
  constructor(prisma, reservations, idempotency, jobQueue, audit, observability) {
    this.prisma = prisma;
    this.reservations = reservations;
    this.idempotency = idempotency;
    this.jobQueue = jobQueue;
    this.audit = audit;
    this.observability = observability;
    this.importQueueName = "reservation-import";
    this.exportResource = "reservations_export";
    this.importResource = "reservations_import";
  }
  // ---------------------------------------------------------------------------
  // Schema helpers
  // ---------------------------------------------------------------------------
  importSchema() {
    return {
      formats: ["csv", "json"],
      csvColumns: reservationImportCsvColumns,
      jsonSchema: reservationImportRecordSchema.describe(),
      summary: reservationImportSchemaSummary
    };
  }
  // ---------------------------------------------------------------------------
  // Import
  // ---------------------------------------------------------------------------
  mask(value) {
    if (typeof value !== "string") return value;
    return value.replace(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi, "***@redacted").replace(/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "***-***-****");
  }
  parseCsv(raw) {
    const lines = raw.split(/\r?\n/).filter((l) => l.trim().length > 0);
    if (!lines.length) return { records: [], errors: ["CSV has no rows"] };
    const headers = lines[0].split(",").map((h) => h.trim());
    const records = [];
    const errors = [];
    for (let i = 1; i < lines.length; i++) {
      const cells = lines[i].split(",").map((c) => c.trim().replace(/^"|"$/g, ""));
      const row = {};
      headers.forEach((h, idx) => {
        row[h] = cells[idx] ?? "";
      });
      if (Object.values(row).every((v) => v === void 0 || String(v).trim() === "")) {
        continue;
      }
      records.push(row);
    }
    const missing = reservationImportSchemaSummary.requiredFields.filter((req) => !headers.includes(req));
    if (missing.length) {
      errors.push(`Missing required columns: ${missing.join(", ")}`);
    }
    return { records, errors };
  }
  validateRecords(campgroundId, records) {
    const valid = [];
    const errors = [];
    records.forEach((row, idx) => {
      const parsed = reservationImportRecordSchema.safeParse({
        campgroundId,
        ...row
      });
      if (!parsed.success) {
        parsed.error.issues.forEach(
          (issue) => errors.push({
            row: idx + 2,
            // account for header
            field: issue.path?.[0],
            message: issue.message,
            value: row[issue.path?.[0]]
          })
        );
        return;
      }
      if (parsed.data.campgroundId !== campgroundId) {
        errors.push({
          row: idx + 2,
          field: "campgroundId",
          message: "campgroundId must match request path",
          value: parsed.data.campgroundId
        });
        return;
      }
      valid.push(parsed.data);
    });
    return { valid, errors };
  }
  async enforceCapacityGuard() {
    const threshold = Number(process.env.RESERVATION_IMPORT_CAPACITY_GUARD ?? 75);
    const state = this.jobQueue.getQueueState(this.importQueueName);
    const queued = state?.pending ?? 0;
    const running = state?.running ?? 0;
    if (queued + running >= threshold) {
      const retryAfter = Number(process.env.RESERVATION_IMPORT_RETRY_AFTER_SEC ?? 120);
      const error = new import_common74.ServiceUnavailableException({
        message: "Import queue is temporarily saturated",
        retryAfter,
        reason: "capacity_guard"
      });
      error.retryAfter = retryAfter;
      throw error;
    }
  }
  normalizeIdempotencyKey(input) {
    if (input && input.trim().length > 0) return input.trim();
    return `import-${Date.now()}`;
  }
  async startImport(request) {
    if (!["csv", "json"].includes(request.format)) {
      throw new import_common74.BadRequestException("format must be csv or json");
    }
    const key = this.normalizeIdempotencyKey(request.idempotencyKey);
    await this.idempotency.throttleScope(request.campgroundId, null, "apply");
    const idemp = await this.idempotency.start(
      key,
      { format: request.format, dryRun: request.dryRun, filename: request.filename },
      request.campgroundId,
      { endpoint: "reservations.import", requestBody: { format: request.format, dryRun: request.dryRun, filename: request.filename } }
    );
    if (idemp?.status === "succeeded" && idemp?.responseJson) {
      return idemp.responseJson;
    }
    await this.enforceCapacityGuard();
    const { records, errors: parseErrors } = request.format === "csv" ? this.parseCsv(typeof request.payload === "string" ? request.payload : "") : { records: Array.isArray(request.payload) ? request.payload : [], errors: [] };
    if (!records.length) {
      await this.idempotency.fail(key);
      throw new import_common74.BadRequestException("No rows to import");
    }
    const validation = this.validateRecords(request.campgroundId, records);
    const responseBase = {
      dryRun: Boolean(request.dryRun),
      parseErrors: parseErrors.map((e) => this.mask(e)),
      validationErrors: validation.errors.slice(0, 25).map((e) => ({ ...e, value: this.mask(e.value) })),
      validCount: validation.valid.length,
      errorCount: validation.errors.length + parseErrors.length
    };
    if (parseErrors.length) {
      await this.idempotency.fail(key);
      throw new import_common74.BadRequestException({ ...responseBase, message: "Invalid import payload" });
    }
    if (request.dryRun) {
      await this.idempotency.complete(key, responseBase);
      return responseBase;
    }
    const job = await this.prisma.integrationExportJob.create({
      data: {
        campgroundId: request.campgroundId,
        type: "api",
        resource: this.importResource,
        status: "queued",
        location: request.format,
        filters: {
          filename: request.filename,
          requestedById: request.requestedById,
          totalRows: validation.valid.length,
          errorCount: validation.errors.length
        },
        requestedById: request.requestedById ?? null,
        lastError: validation.errors.length ? "Some rows failed validation; see status" : null
      }
    });
    void this.jobQueue.enqueue(
      this.importQueueName,
      () => this.processImportJob(job.id, request.campgroundId, validation.valid, validation.errors),
      { jobName: `${this.importQueueName}:${request.campgroundId}` }
    );
    const response = { jobId: job.id, status: "queued", ...responseBase };
    await this.idempotency.complete(key, response);
    return response;
  }
  async processImportJob(jobId, campgroundId, records, validationErrors) {
    await this.prisma.integrationExportJob.update({
      where: { id: jobId },
      data: { status: "processing", startedAt: /* @__PURE__ */ new Date() }
    });
    const created = [];
    const failed = [...validationErrors];
    for (const row of records) {
      try {
        await this.reservations.create({
          campgroundId,
          siteId: row.siteId,
          guestId: row.guestId,
          arrivalDate: row.arrivalDate,
          departureDate: row.departureDate,
          adults: row.adults,
          children: row.children ?? 0,
          status: row.status,
          totalAmount: row.totalAmount,
          paidAmount: row.paidAmount ?? 0,
          notes: row.notes,
          source: row.source,
          promoCode: row.promoCode,
          rigType: row.rigType,
          rigLength: row.rigLength,
          holdId: row.holdId,
          createdBy: row.createdBy,
          updatedBy: row.updatedBy
        });
        created.push(row.externalId || row.guestId);
      } catch (err) {
        failed.push({
          row: failed.length + created.length + 2,
          field: "create",
          message: err?.message || "Failed to create reservation"
        });
      }
    }
    const status = failed.length ? "failed" : "success";
    await this.prisma.integrationExportJob.update({
      where: { id: jobId },
      data: {
        status,
        completedAt: /* @__PURE__ */ new Date(),
        lastError: failed.length ? `${failed.length} rows failed` : null,
        filters: {
          createdCount: created.length,
          failedCount: failed.length,
          errors: failed.slice(0, 50).map((f) => ({ ...f, value: this.mask(f.value) }))
        }
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: null,
      action: "reservation.import",
      entity: "reservation_import_job",
      entityId: jobId,
      after: { created: created.length, failed: failed.length }
    });
    this.observability.recordJobRun({
      name: this.importQueueName,
      durationMs: 0,
      success: status === "success",
      queueDepth: this.jobQueue.getQueueState(this.importQueueName)?.pending ?? 0
    });
    return { created: created.length, failed: failed.length };
  }
  async getImportStatus(campgroundId, jobId) {
    const job = await this.prisma.integrationExportJob.findUnique({ where: { id: jobId } });
    if (!job || job.campgroundId !== campgroundId || job.resource !== this.importResource) {
      throw new import_common74.BadRequestException("Import job not found for this campground");
    }
    return {
      id: job.id,
      status: job.status,
      createdAt: job.createdAt,
      startedAt: job.startedAt,
      completedAt: job.completedAt,
      format: job.location,
      metadata: job.filters,
      lastError: job.lastError
    };
  }
  // ---------------------------------------------------------------------------
  // Export
  // ---------------------------------------------------------------------------
  exportMaxRows() {
    return Number(process.env.RESERVATION_EXPORT_MAX_ROWS ?? 5e4);
  }
  exportPageSize() {
    return Number(process.env.RESERVATION_EXPORT_PAGE_SIZE ?? 500);
  }
  encodeToken(payload) {
    return Buffer.from(JSON.stringify(payload)).toString("base64url");
  }
  decodeToken(token) {
    if (!token) return null;
    try {
      return JSON.parse(Buffer.from(token, "base64url").toString());
    } catch {
      return null;
    }
  }
  redactRow(row, includePII) {
    if (includePII) return row;
    return {
      ...row,
      guestEmail: this.mask(row.guestEmail),
      guestPhone: this.mask(row.guestPhone),
      guestName: row.guestName ? this.mask(row.guestName) : void 0,
      notes: row.notes ? this.mask(row.notes) : void 0
    };
  }
  toCsv(rows) {
    if (!rows.length) return "";
    const headers = Object.keys(rows[0]);
    const lines = [headers.join(",")];
    rows.forEach((row) => {
      const values = headers.map((h) => {
        const val = row[h];
        if (val === null || val === void 0) return "";
        const str = String(val).replace(/"/g, '""');
        return str.includes(",") ? `"${str}"` : str;
      });
      lines.push(values.join(","));
    });
    return lines.join("\n");
  }
  async exportReservations(params) {
    await this.idempotency.throttleScope(params.campgroundId, null, "report");
    const decoded = this.decodeToken(params.paginationToken) || { emitted: 0 };
    const emitted = decoded.emitted ?? 0;
    const maxRows = this.exportMaxRows();
    if (emitted >= maxRows) {
      return { rows: [], nextToken: null, emitted, remaining: 0 };
    }
    const take = Math.min(Math.max(params.pageSize ?? this.exportPageSize(), 1), maxRows - emitted);
    const rows = await this.prisma.reservation.findMany({
      where: {
        campgroundId: params.campgroundId,
        ...params.filters ?? {}
      },
      orderBy: { createdAt: "asc" },
      ...decoded.lastId ? { cursor: { id: decoded.lastId }, skip: 1 } : {},
      take,
      select: {
        id: true,
        campgroundId: true,
        siteId: true,
        guestId: true,
        arrivalDate: true,
        departureDate: true,
        totalAmount: true,
        paidAmount: true,
        status: true,
        source: true,
        notes: true,
        createdAt: true
      }
    });
    const shaped = rows.map(
      (r) => this.redactRow(
        {
          id: r.id,
          campgroundId: r.campgroundId,
          siteId: r.siteId,
          guestId: r.guestId,
          arrivalDate: r.arrivalDate,
          departureDate: r.departureDate,
          totalAmount: r.totalAmount,
          paidAmount: r.paidAmount,
          status: r.status,
          source: r.source,
          notes: r.notes,
          createdAt: r.createdAt
        },
        params.includePII ?? false
      )
    );
    const newEmitted = emitted + shaped.length;
    const nextToken = shaped.length === take && newEmitted < maxRows ? this.encodeToken({ lastId: rows[rows.length - 1].id, emitted: newEmitted }) : null;
    const payload = (params.format ?? "json") === "csv" ? { csv: this.toCsv(shaped), nextToken, emitted: newEmitted, remaining: Math.max(0, maxRows - newEmitted) } : { rows: shaped, nextToken, emitted: newEmitted, remaining: Math.max(0, maxRows - newEmitted) };
    if (!params.paginationToken) {
      await this.audit.recordExport({
        campgroundId: params.campgroundId,
        requestedById: params.requestedById ?? "system",
        format: params.format ?? "json",
        filters: params.filters,
        recordCount: shaped.length
      });
    }
    return payload;
  }
  async listExports(campgroundId, limit = 10) {
    const take = Math.min(Math.max(limit, 1), 50);
    return this.prisma.integrationExportJob.findMany({
      where: { campgroundId, resource: this.exportResource },
      orderBy: { createdAt: "desc" },
      take
    });
  }
  async queueExport(campgroundId, filters, format = "json", requestedById) {
    await this.idempotency.throttleScope(campgroundId, null, "apply");
    const job = await this.prisma.integrationExportJob.create({
      data: {
        campgroundId,
        type: "api",
        resource: this.exportResource,
        status: "queued",
        location: format,
        filters: filters ?? {},
        requestedById: requestedById ?? null
      }
    });
    return job;
  }
};
ReservationImportExportService = __decorateClass([
  (0, import_common74.Injectable)()
], ReservationImportExportService);

// src/reservations/match-score.service.ts
var import_common75 = require("@nestjs/common");
var MatchScoreService = class {
  calculateMatchScore(guest, site) {
    let score = 50;
    const reasons = [];
    if (guest.rigLength && site.rigMaxLength && guest.rigLength > site.rigMaxLength) {
      return { score: 0, reasons: ["Rig too long for site"] };
    }
    const pastReservations = guest.reservations || [];
    const hasStayedInSite = pastReservations.some((r) => r.siteId === site.id);
    const hasStayedInClass = pastReservations.some((r) => r.site?.siteClassId === site.siteClassId);
    if (hasStayedInSite) {
      score += 30;
      reasons.push("Guest has stayed in this specific site before");
    } else if (hasStayedInClass) {
      score += 15;
      reasons.push("Guest has stayed in this site class before");
    }
    const preferences = guest.preferences || {};
    const vibeTags = site.vibeTags || [];
    if (preferences.secluded && vibeTags.includes("Secluded")) {
      score += 15;
      reasons.push("Matches preference: Secluded");
    }
    if (preferences.shade && vibeTags.includes("Shade")) {
      score += 10;
      reasons.push("Matches preference: Shade");
    }
    if (preferences.nearBathrooms && vibeTags.includes("Near Bathrooms")) {
      score += 10;
      reasons.push("Matches preference: Near Bathrooms");
    }
    if (site.popularityScore) {
      score += Math.round(site.popularityScore / 5);
    }
    return {
      score: Math.min(100, Math.max(0, score)),
      reasons
    };
  }
};
MatchScoreService = __decorateClass([
  (0, import_common75.Injectable)()
], MatchScoreService);

// src/pricing-v2/pricing-v2.service.ts
var import_common76 = require("@nestjs/common");
var import_client12 = require("@prisma/client");
var PricingV2Service = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
  }
  list(campgroundId) {
    return this.prisma.pricingRuleV2.findMany({
      where: { campgroundId },
      orderBy: [{ active: "desc" }, { priority: "asc" }, { createdAt: "desc" }]
    });
  }
  /**
   * Evaluate pricing rules for a reservation.
   * Returns a breakdown of base rate + adjustments + demand, with caps applied.
   */
  async evaluate(campgroundId, siteClassId, baseRateCents, arrivalDate, departureDate, occupancyPct) {
    const nights = this.computeNights(arrivalDate, departureDate);
    const rules = await this.prisma.pricingRuleV2.findMany({
      where: {
        campgroundId,
        active: true,
        OR: [{ siteClassId: null }, { siteClassId }]
      },
      orderBy: [{ priority: "asc" }]
    });
    const demandRules = rules.filter((r) => r.type === import_client12.PricingRuleType.demand);
    const standardRules = rules.filter((r) => r.type !== import_client12.PricingRuleType.demand);
    let totalCents = 0;
    let baseSubtotalCents = 0;
    let adjustmentsCents = 0;
    const appliedRules = [];
    for (let i = 0; i < nights; i++) {
      const day = new Date(arrivalDate);
      day.setDate(day.getDate() + i);
      const dow = day.getDay();
      let nightlyRate = baseRateCents;
      let nightlyAdjustment = 0;
      let overrideApplied = false;
      for (const rule of standardRules) {
        if (!this.ruleApplies(rule, day, dow, nights)) continue;
        const adj = this.computeAdjustment(rule.adjustmentType, rule.adjustmentValue, nightlyRate);
        if (rule.stackMode === import_client12.PricingStackMode.override) {
          nightlyAdjustment = adj;
          overrideApplied = true;
          if (!appliedRules.find((r) => r.id === rule.id)) {
            appliedRules.push({ id: rule.id, name: rule.name, type: rule.type, adjustmentCents: adj });
          }
          break;
        } else if (rule.stackMode === import_client12.PricingStackMode.additive) {
          nightlyAdjustment += adj;
          if (!appliedRules.find((r) => r.id === rule.id)) {
            appliedRules.push({ id: rule.id, name: rule.name, type: rule.type, adjustmentCents: adj });
          }
        } else if (rule.stackMode === import_client12.PricingStackMode.max) {
          if (adj > nightlyAdjustment) {
            nightlyAdjustment = adj;
            if (!appliedRules.find((r) => r.id === rule.id)) {
              appliedRules.push({ id: rule.id, name: rule.name, type: rule.type, adjustmentCents: adj });
            }
          }
        }
      }
      baseSubtotalCents += baseRateCents;
      adjustmentsCents += nightlyAdjustment;
      totalCents += nightlyRate + nightlyAdjustment;
    }
    let demandAdjustmentCents = 0;
    if (occupancyPct !== void 0 && demandRules.length > 0) {
      for (const rule of demandRules) {
        if (!rule.demandBandId) continue;
        const band = await this.prisma.demandBand.findUnique({ where: { id: rule.demandBandId } });
        if (!band || !band.active) continue;
        if (occupancyPct >= band.thresholdPct) {
          const adj = this.computeAdjustment(band.adjustmentType, band.adjustmentValue, totalCents / nights) * nights;
          demandAdjustmentCents += adj;
          appliedRules.push({ id: rule.id, name: rule.name, type: "demand", adjustmentCents: adj });
        }
      }
    }
    totalCents += demandAdjustmentCents;
    let cappedAt = null;
    const minCaps = rules.filter((r) => r.minRateCap !== null).map((r) => r.minRateCap);
    const maxCaps = rules.filter((r) => r.maxRateCap !== null).map((r) => r.maxRateCap);
    const minCap = minCaps.length > 0 ? Math.max(...minCaps) : null;
    const maxCap = maxCaps.length > 0 ? Math.min(...maxCaps) : null;
    if (minCap !== null && totalCents < minCap * nights) {
      totalCents = minCap * nights;
      cappedAt = "min";
    }
    if (maxCap !== null && totalCents > maxCap * nights) {
      totalCents = maxCap * nights;
      cappedAt = "max";
    }
    const ruleIds = rules.map((r) => r.id).sort().join(",");
    const pricingRuleVersion = `v2:${ruleIds.slice(0, 32)}:${Date.now()}`;
    return {
      nights,
      baseSubtotalCents,
      adjustmentsCents,
      demandAdjustmentCents,
      totalBeforeTaxCents: totalCents,
      appliedRules,
      cappedAt,
      pricingRuleVersion
    };
  }
  computeNights(arrival, departure) {
    const ms = departure.getTime() - arrival.getTime();
    if (!Number.isFinite(ms) || ms <= 0) return 1;
    return Math.max(1, Math.round(ms / (1e3 * 60 * 60 * 24)));
  }
  ruleApplies(rule, day, dow, nights) {
    if (rule.startDate && day < rule.startDate) return false;
    if (rule.endDate && day > rule.endDate) return false;
    if (rule.dowMask && rule.dowMask.length > 0 && !rule.dowMask.includes(dow)) return false;
    return true;
  }
  computeAdjustment(adjustmentType, value, baseCents) {
    const val = Number(value);
    if (adjustmentType === import_client12.AdjustmentType.percent) {
      return Math.round(baseCents * val);
    }
    return Math.round(val);
  }
  async create(campgroundId, dto, actorId) {
    await this.validateRule(campgroundId, dto);
    const rule = await this.prisma.pricingRuleV2.create({
      data: {
        ...dto,
        campgroundId,
        siteClassId: dto.siteClassId ?? null,
        calendarRefId: dto.calendarRefId ?? null,
        demandBandId: dto.demandBandId ?? null,
        startDate: dto.startDate ? new Date(dto.startDate) : null,
        endDate: dto.endDate ? new Date(dto.endDate) : null
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "pricing_rule_v2.create",
      entity: "PricingRuleV2",
      entityId: rule.id,
      before: null,
      after: rule
    });
    return rule;
  }
  async update(id, dto, actorId) {
    const existing = await this.prisma.pricingRuleV2.findUnique({ where: { id } });
    if (!existing) throw new import_common76.NotFoundException("Pricing rule not found");
    const existingForValidation = {
      ...existing,
      adjustmentValue: Number(existing.adjustmentValue),
      startDate: existing.startDate?.toISOString() ?? null,
      endDate: existing.endDate?.toISOString() ?? null
    };
    await this.validateRule(existing.campgroundId, { ...existingForValidation, ...dto });
    const updated = await this.prisma.pricingRuleV2.update({
      where: { id },
      data: {
        ...dto,
        siteClassId: dto.siteClassId === void 0 ? void 0 : dto.siteClassId ?? null,
        calendarRefId: dto.calendarRefId === void 0 ? void 0 : dto.calendarRefId ?? null,
        demandBandId: dto.demandBandId === void 0 ? void 0 : dto.demandBandId ?? null,
        startDate: dto.startDate === void 0 ? void 0 : dto.startDate ? new Date(dto.startDate) : null,
        endDate: dto.endDate === void 0 ? void 0 : dto.endDate ? new Date(dto.endDate) : null
      }
    });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "pricing_rule_v2.update",
      entity: "PricingRuleV2",
      entityId: id,
      before: existing,
      after: updated
    });
    return updated;
  }
  async remove(id, actorId) {
    const existing = await this.prisma.pricingRuleV2.findUnique({ where: { id } });
    if (!existing) throw new import_common76.NotFoundException("Pricing rule not found");
    await this.prisma.pricingRuleV2.delete({ where: { id } });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "pricing_rule_v2.delete",
      entity: "PricingRuleV2",
      entityId: id,
      before: existing,
      after: null
    });
    return existing;
  }
  async validateRule(campgroundId, dto) {
    if (dto.stackMode === import_client12.PricingStackMode.override) {
      const overlapping = await this.prisma.pricingRuleV2.count({
        where: {
          campgroundId,
          id: dto.id ? { not: dto.id } : void 0,
          siteClassId: dto.siteClassId ?? null,
          stackMode: import_client12.PricingStackMode.override,
          active: dto.active ?? true,
          // Rough overlap check; refinement can be added later
          OR: [
            { startDate: null, endDate: null },
            {
              startDate: { lte: dto.endDate ? new Date(dto.endDate) : void 0 },
              endDate: { gte: dto.startDate ? new Date(dto.startDate) : void 0 }
            }
          ]
        }
      });
      if (overlapping > 0) {
        throw new import_common76.BadRequestException("Overlapping override pricing rules are not allowed");
      }
    }
    if (dto.type === import_client12.PricingRuleType.demand && !dto.demandBandId) {
      throw new import_common76.BadRequestException("Demand rules require a demandBandId");
    }
  }
};
PricingV2Service = __decorateClass([
  (0, import_common76.Injectable)()
], PricingV2Service);

// src/deposit-policies/deposit-policies.service.ts
var import_common77 = require("@nestjs/common");
var import_client13 = require("@prisma/client");
var DepositPoliciesService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
  }
  list(campgroundId) {
    return this.prisma.depositPolicy.findMany({
      where: { campgroundId },
      orderBy: [{ active: "desc" }, { createdAt: "desc" }]
    });
  }
  async create(campgroundId, dto, actorId) {
    const policy = await this.prisma.depositPolicy.create({
      data: {
        ...dto,
        campgroundId,
        siteClassId: dto.siteClassId ?? null,
        retryPlanId: dto.retryPlanId ?? null
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "deposit_policy.create",
      entity: "DepositPolicy",
      entityId: policy.id,
      before: null,
      after: policy
    });
    return policy;
  }
  async update(id, dto, actorId) {
    const existing = await this.prisma.depositPolicy.findUnique({ where: { id } });
    if (!existing) throw new import_common77.NotFoundException("Deposit policy not found");
    const updated = await this.prisma.depositPolicy.update({
      where: { id },
      data: {
        ...dto,
        siteClassId: dto.siteClassId === void 0 ? void 0 : dto.siteClassId ?? null,
        retryPlanId: dto.retryPlanId === void 0 ? void 0 : dto.retryPlanId ?? null
      }
    });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "deposit_policy.update",
      entity: "DepositPolicy",
      entityId: id,
      before: existing,
      after: updated
    });
    return updated;
  }
  async remove(id, actorId) {
    const existing = await this.prisma.depositPolicy.findUnique({ where: { id } });
    if (!existing) throw new import_common77.NotFoundException("Deposit policy not found");
    await this.prisma.depositPolicy.delete({ where: { id } });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "deposit_policy.delete",
      entity: "DepositPolicy",
      entityId: id,
      before: existing,
      after: null
    });
    return existing;
  }
  /**
   * Resolve the applicable deposit policy for a reservation.
   * Priority: siteClass-specific > campground default > legacy campground.depositRule
   */
  async resolve(campgroundId, siteClassId) {
    if (siteClassId) {
      const siteClassPolicy = await this.prisma.depositPolicy.findFirst({
        where: { campgroundId, siteClassId, active: true },
        orderBy: { createdAt: "desc" }
      });
      if (siteClassPolicy) return siteClassPolicy;
    }
    const campground = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: { defaultDepositPolicyId: true, depositRule: true, depositPercentage: true }
    });
    if (campground?.defaultDepositPolicyId) {
      const defaultPolicy = await this.prisma.depositPolicy.findUnique({
        where: { id: campground.defaultDepositPolicyId }
      });
      if (defaultPolicy?.active) return defaultPolicy;
    }
    const campgroundPolicy = await this.prisma.depositPolicy.findFirst({
      where: { campgroundId, siteClassId: null, active: true },
      orderBy: { createdAt: "desc" }
    });
    if (campgroundPolicy) return campgroundPolicy;
    return null;
  }
  /**
   * Calculate deposit amount using resolved policy or legacy fallback.
   */
  async calculateDeposit(campgroundId, siteClassId, totalAmountCents, lodgingOnlyCents, nights) {
    const policy = await this.resolve(campgroundId, siteClassId);
    if (!policy) {
      return null;
    }
    const baseCents = policy.applyTo === import_client13.DepositApplyTo.lodging_only ? lodgingOnlyCents : totalAmountCents;
    let depositAmountCents = 0;
    switch (policy.strategy) {
      case import_client13.DepositStrategy.first_night:
        depositAmountCents = Math.ceil(baseCents / nights);
        break;
      case import_client13.DepositStrategy.percent:
        depositAmountCents = Math.ceil(baseCents * (policy.value / 100));
        break;
      case import_client13.DepositStrategy.fixed:
        depositAmountCents = policy.value;
        break;
    }
    if (policy.minCap !== null && depositAmountCents < policy.minCap) {
      depositAmountCents = policy.minCap;
    }
    if (policy.maxCap !== null && depositAmountCents > policy.maxCap) {
      depositAmountCents = policy.maxCap;
    }
    depositAmountCents = Math.min(depositAmountCents, totalAmountCents);
    const depositPolicyVersion = `dp:${policy.id}:v${policy.version}`;
    return {
      depositAmountCents,
      policy: {
        id: policy.id,
        name: policy.name,
        strategy: policy.strategy,
        value: policy.value,
        applyTo: policy.applyTo
      },
      depositPolicyVersion
    };
  }
};
DepositPoliciesService = __decorateClass([
  (0, import_common77.Injectable)()
], DepositPoliciesService);

// src/signatures/signatures.module.ts
var import_common82 = require("@nestjs/common");

// src/signatures/signatures.controller.ts
var import_common78 = require("@nestjs/common");
var import_client14 = require("@prisma/client");
var SignaturesController = class {
  constructor(signatures) {
    this.signatures = signatures;
  }
  async create(req, dto) {
    return this.signatures.createAndSend(dto, req?.user?.id ?? null);
  }
  async resend(req, id) {
    return this.signatures.resend(id, req?.user?.id ?? null);
  }
  async voidRequest(req, id) {
    return this.signatures.voidRequest(id, req?.user?.id ?? null);
  }
  async getRequest(id) {
    return this.signatures.getById(id);
  }
  async listForReservation(reservationId) {
    return this.signatures.listByReservation(reservationId);
  }
  async handleWebhook(dto) {
    return this.signatures.handleWebhook(dto);
  }
  async uploadCoi(req, dto) {
    return this.signatures.createCoi(dto, req?.user?.id ?? null);
  }
};
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance),
  RequireScope({ resource: "reservations", action: "write" }),
  (0, import_common78.Post)("requests"),
  __decorateParam(0, (0, import_common78.Req)()),
  __decorateParam(1, (0, import_common78.Body)())
], SignaturesController.prototype, "create", 1);
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance),
  RequireScope({ resource: "reservations", action: "write" }),
  (0, import_common78.Post)("requests/:id/resend"),
  __decorateParam(0, (0, import_common78.Req)()),
  __decorateParam(1, (0, import_common78.Param)("id"))
], SignaturesController.prototype, "resend", 1);
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance),
  RequireScope({ resource: "reservations", action: "write" }),
  (0, import_common78.Post)("requests/:id/void"),
  __decorateParam(0, (0, import_common78.Req)()),
  __decorateParam(1, (0, import_common78.Param)("id"))
], SignaturesController.prototype, "voidRequest", 1);
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance, import_client14.UserRole.readonly),
  RequireScope({ resource: "reservations", action: "read" }),
  (0, import_common78.Get)("requests/:id"),
  __decorateParam(0, (0, import_common78.Param)("id"))
], SignaturesController.prototype, "getRequest", 1);
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance, import_client14.UserRole.readonly),
  RequireScope({ resource: "reservations", action: "read" }),
  (0, import_common78.Get)("reservations/:reservationId/requests"),
  __decorateParam(0, (0, import_common78.Param)("reservationId"))
], SignaturesController.prototype, "listForReservation", 1);
__decorateClass([
  (0, import_common78.HttpCode)(200),
  (0, import_common78.Post)("webhooks/internal"),
  __decorateParam(0, (0, import_common78.Body)())
], SignaturesController.prototype, "handleWebhook", 1);
__decorateClass([
  (0, import_common78.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  Roles(import_client14.UserRole.owner, import_client14.UserRole.manager, import_client14.UserRole.front_desk, import_client14.UserRole.finance),
  RequireScope({ resource: "reservations", action: "write" }),
  (0, import_common78.Post)("coi"),
  __decorateParam(0, (0, import_common78.Req)()),
  __decorateParam(1, (0, import_common78.Body)())
], SignaturesController.prototype, "uploadCoi", 1);
SignaturesController = __decorateClass([
  (0, import_common78.Controller)("signatures")
], SignaturesController);

// src/signatures/signatures.service.ts
var import_common79 = require("@nestjs/common");
var import_schedule5 = require("@nestjs/schedule");
var import_crypto8 = require("crypto");
var SignatureRequestStatus = {
  draft: "draft",
  sent: "sent",
  viewed: "viewed",
  signed: "signed",
  declined: "declined",
  voided: "voided",
  expired: "expired"
};
var SignatureDeliveryChannel = {
  email: "email",
  sms: "sms",
  email_and_sms: "email_and_sms"
};
var SignatureDocumentType = {
  long_term_stay: "long_term_stay",
  park_rules: "park_rules",
  deposit: "deposit",
  waiver: "waiver",
  coi: "coi",
  other: "other"
};
var CoiStatus = {
  pending: "pending",
  active: "active",
  voided: "voided",
  expired: "expired"
};
var FINAL_SIGNATURE_STATES = [
  SignatureRequestStatus.signed,
  SignatureRequestStatus.declined,
  SignatureRequestStatus.voided,
  SignatureRequestStatus.expired
];
var SignaturesService = class {
  constructor(prisma, email, sms, audit) {
    this.prisma = prisma;
    this.email = email;
    this.sms = sms;
    this.audit = audit;
    this.logger = new import_common79.Logger(SignaturesService.name);
  }
  appBaseUrl() {
    return process.env.FRONTEND_URL || "https://app.campreserv.com";
  }
  signingUrl(token) {
    return `${this.appBaseUrl()}/sign/${token}`;
  }
  computeReminder(expiresAt, fallbackDays = 2) {
    if (!expiresAt) return new Date(Date.now() + fallbackDays * 24 * 60 * 60 * 1e3);
    const target = new Date(expiresAt.getTime() - fallbackDays * 24 * 60 * 60 * 1e3);
    return target > /* @__PURE__ */ new Date() ? target : new Date(Date.now() + fallbackDays * 60 * 60 * 1e3);
  }
  buildStubPdf(request, payload) {
    const lines = [
      `Campground: ${request.campgroundId}`,
      `Reservation: ${request.reservationId ?? "n/a"}`,
      `Document: ${request.documentType}`,
      `Recipient: ${payload?.recipientEmail ?? request.recipientEmail ?? "guest"}`,
      `Status: signed`,
      `Signed At: ${(/* @__PURE__ */ new Date()).toISOString()}`
    ].join("\n");
    const base64 = Buffer.from(lines).toString("base64");
    return `data:application/pdf;base64,${base64}`;
  }
  async deliverRequest(request, context) {
    const link = this.signingUrl(request.token);
    const subject = request.subject || "Signature requested";
    const recipientEmail = request.recipientEmail || context?.guest?.email;
    const recipientPhone = request.recipientPhone || context?.guest?.phone;
    if (request.deliveryChannel === SignatureDeliveryChannel.email || request.deliveryChannel === SignatureDeliveryChannel.email_and_sms) {
      if (!recipientEmail) {
        throw new import_common79.BadRequestException("Recipient email required for email delivery");
      }
      const html = `
        <p>Hello ${request.recipientName || context?.guest?.primaryFirstName || "there"},</p>
        <p>You have a document to review and sign for your stay. Use the secure link below:</p>
        <p><a href="${link}">${link}</a></p>
        <p>${context?.message || request.message || "This link expires soon; please sign at your earliest convenience."}</p>
      `;
      await this.email.sendEmail({
        to: recipientEmail,
        subject,
        html,
        reservationId: request.reservationId,
        guestId: request.guestId,
        campgroundId: request.campgroundId
      });
    }
    if (request.deliveryChannel === SignatureDeliveryChannel.sms || request.deliveryChannel === SignatureDeliveryChannel.email_and_sms) {
      if (recipientPhone) {
        const body = `Campreserv: Signature needed for your stay. ${link}`;
        await this.sms.sendSms({ to: recipientPhone, body, reservationId: request.reservationId, campgroundId: request.campgroundId });
      } else {
        this.logger.warn(`SMS delivery requested but no phone found for request ${request.id}`);
      }
    }
  }
  async createAndSend(dto, actorId) {
    const reservation = dto.reservationId ? await this.prisma.reservation.findUnique({ where: { id: dto.reservationId }, include: { guest: true } }) : null;
    const campgroundId = dto.campgroundId || reservation?.campgroundId;
    if (!campgroundId) {
      throw new import_common79.BadRequestException("campgroundId is required");
    }
    const guest = reservation?.guest ?? (dto.guestId ? await this.prisma.guest.findUnique({ where: { id: dto.guestId } }) : null);
    const token = (0, import_crypto8.randomBytes)(24).toString("hex");
    const expiresAt = dto.expiresAt ? new Date(dto.expiresAt) : new Date(Date.now() + 14 * 24 * 60 * 60 * 1e3);
    const reminderAt = dto.reminderAt ? new Date(dto.reminderAt) : this.computeReminder(expiresAt);
    const deliveryChannel = dto.deliveryChannel || SignatureDeliveryChannel.email;
    const documentType = dto.documentType || SignatureDocumentType.other;
    const created = await this.prisma.signatureRequest.create({
      data: {
        campgroundId,
        reservationId: reservation?.id ?? dto.reservationId ?? null,
        guestId: guest?.id ?? dto.guestId ?? null,
        templateId: dto.templateId ?? null,
        documentType,
        status: SignatureRequestStatus.sent,
        deliveryChannel,
        token,
        subject: dto.subject ?? null,
        message: dto.message ?? null,
        recipientName: dto.recipientName ?? guest?.primaryFirstName ?? null,
        recipientEmail: dto.recipientEmail ?? guest?.email ?? null,
        recipientPhone: dto.recipientPhone ?? guest?.phone ?? null,
        sentAt: /* @__PURE__ */ new Date(),
        expiresAt,
        reminderAt,
        metadata: dto.metadata ?? null
      }
    });
    await this.deliverRequest(created, { reservation, guest, message: dto.message });
    await this.audit.record({
      campgroundId,
      actorId,
      action: "signature.request_sent",
      entity: "SignatureRequest",
      entityId: created.id,
      after: { status: created.status, documentType, reservationId: created.reservationId, guestId: created.guestId }
    });
    return { request: created, signingUrl: this.signingUrl(token) };
  }
  async resend(id, actorId) {
    const existing = await this.prisma.signatureRequest.findUnique({ where: { id } });
    if (!existing) throw new import_common79.NotFoundException("Signature request not found");
    if (FINAL_SIGNATURE_STATES.includes(existing.status)) {
      throw new import_common79.BadRequestException("Cannot resend a completed request");
    }
    const reminderAt = this.computeReminder(existing.expiresAt);
    const updated = await this.prisma.signatureRequest.update({
      where: { id },
      data: {
        status: SignatureRequestStatus.sent,
        sentAt: /* @__PURE__ */ new Date(),
        reminderAt,
        reminderCount: existing.reminderCount + 1
      }
    });
    const reservation = updated.reservationId ? await this.prisma.reservation.findUnique({ where: { id: updated.reservationId }, include: { guest: true } }) : null;
    await this.deliverRequest(updated, { reservation, guest: reservation?.guest });
    await this.audit.record({
      campgroundId: updated.campgroundId,
      actorId,
      action: "signature.request_resent",
      entity: "SignatureRequest",
      entityId: updated.id,
      before: { reminderCount: existing.reminderCount },
      after: { reminderCount: updated.reminderCount }
    });
    return updated;
  }
  async voidRequest(id, actorId) {
    const existing = await this.prisma.signatureRequest.findUnique({ where: { id } });
    if (!existing) throw new import_common79.NotFoundException("Signature request not found");
    if (existing.status === SignatureRequestStatus.voided) return existing;
    const updated = await this.prisma.signatureRequest.update({
      where: { id },
      data: {
        status: SignatureRequestStatus.voided,
        voidedAt: /* @__PURE__ */ new Date(),
        reminderAt: null
      }
    });
    await this.audit.record({
      campgroundId: updated.campgroundId,
      actorId,
      action: "signature.request_voided",
      entity: "SignatureRequest",
      entityId: updated.id,
      before: { status: existing.status },
      after: { status: updated.status }
    });
    return updated;
  }
  async handleWebhook(dto) {
    const request = await this.prisma.signatureRequest.findUnique({
      where: { token: dto.token },
      include: { reservation: true, guest: true }
    });
    if (!request) throw new import_common79.NotFoundException("Signature request not found");
    const now = /* @__PURE__ */ new Date();
    if (FINAL_SIGNATURE_STATES.includes(request.status) && dto.status !== "viewed") {
      return { request, artifact: await this.prisma.signatureArtifact.findUnique({ where: { requestId: request.id } }) };
    }
    let nextStatus = request.status;
    let viewedAt = null;
    let signedAt = null;
    let declinedAt = null;
    let voidedAt = null;
    switch (dto.status) {
      case "signed":
        nextStatus = SignatureRequestStatus.signed;
        signedAt = now;
        break;
      case "declined":
        nextStatus = SignatureRequestStatus.declined;
        declinedAt = now;
        break;
      case "voided":
        nextStatus = SignatureRequestStatus.voided;
        voidedAt = now;
        break;
      case "expired":
        nextStatus = SignatureRequestStatus.expired;
        break;
      case "viewed":
        nextStatus = request.status === SignatureRequestStatus.sent ? SignatureRequestStatus.viewed : request.status;
        viewedAt = now;
        break;
      default:
        break;
    }
    const updatedRequest = await this.prisma.signatureRequest.update({
      where: { id: request.id },
      data: {
        status: nextStatus,
        viewedAt: viewedAt ?? request.viewedAt,
        signedAt: signedAt ?? request.signedAt,
        declinedAt: declinedAt ?? request.declinedAt,
        voidedAt: voidedAt ?? request.voidedAt,
        reminderAt: null
      }
    });
    let artifact = await this.prisma.signatureArtifact.findUnique({ where: { requestId: request.id } });
    if (dto.status === "signed") {
      const pdfUrl = dto.pdfUrl || this.buildStubPdf(updatedRequest, dto);
      const checksum = (0, import_crypto8.createHash)("sha256").update(pdfUrl).digest("hex");
      artifact = await this.prisma.signatureArtifact.upsert({
        where: { requestId: request.id },
        update: {
          pdfUrl,
          storageKey: dto.storageKey ?? artifact?.storageKey ?? null,
          checksum,
          metadata: dto.metadata ?? artifact?.metadata ?? null,
          completedAt: dto.completedAt ? new Date(dto.completedAt) : now,
          reservationId: updatedRequest.reservationId,
          guestId: updatedRequest.guestId
        },
        create: {
          requestId: request.id,
          campgroundId: updatedRequest.campgroundId,
          reservationId: updatedRequest.reservationId,
          guestId: updatedRequest.guestId,
          pdfUrl,
          storageKey: dto.storageKey ?? null,
          checksum,
          metadata: dto.metadata ?? null,
          completedAt: dto.completedAt ? new Date(dto.completedAt) : now
        }
      });
    }
    await this.audit.record({
      campgroundId: updatedRequest.campgroundId,
      actorId: null,
      action: `signature.${dto.status}`,
      entity: "SignatureRequest",
      entityId: updatedRequest.id,
      before: { status: request.status },
      after: { status: updatedRequest.status },
      ip: dto.ipAddress,
      userAgent: dto.userAgent
    });
    return { request: updatedRequest, artifact };
  }
  async listByReservation(reservationId) {
    return this.prisma.signatureRequest.findMany({
      where: { reservationId },
      include: { artifact: true, template: true }
    });
  }
  async getById(id) {
    return this.prisma.signatureRequest.findUnique({
      where: { id },
      include: { artifact: true, template: true }
    });
  }
  scoreTemplate(tpl, siteId, siteClassId) {
    let score = 0;
    if (tpl.siteId && tpl.siteId === siteId) score += 3;
    if (tpl.siteClassId && tpl.siteClassId === siteClassId) score += 2;
    if (!tpl.siteId && !tpl.siteClassId) score += 1;
    score += (tpl.version ?? 0) / 1e3;
    return score;
  }
  async autoSendForReservation(reservation) {
    if (!reservation?.campgroundId || !reservation?.id) return null;
    const guest = reservation.guest ?? (reservation.guestId ? await this.prisma.guest.findUnique({ where: { id: reservation.guestId } }) : null);
    if (!guest?.email) return null;
    const templates = await this.prisma.documentTemplate.findMany({
      where: {
        campgroundId: reservation.campgroundId,
        isActive: true,
        autoSend: true,
        OR: [
          reservation.siteId ? { siteId: reservation.siteId } : void 0,
          reservation.site?.siteClassId ? { siteClassId: reservation.site.siteClassId } : void 0,
          { siteId: null, siteClassId: null }
        ].filter(Boolean)
      }
    });
    if (!templates.length) return null;
    const ranked = templates.map((tpl) => ({
      tpl,
      score: this.scoreTemplate(tpl, reservation.siteId, reservation.site?.siteClassId ?? null)
    })).sort((a, b) => b.score - a.score);
    const template = ranked[0]?.tpl;
    if (!template) return null;
    const existing = await this.prisma.signatureRequest.findFirst({
      where: {
        reservationId: reservation.id,
        documentType: template.type,
        status: { notIn: FINAL_SIGNATURE_STATES }
      }
    });
    if (existing) return existing;
    try {
      return await this.createAndSend(
        {
          campgroundId: reservation.campgroundId,
          reservationId: reservation.id,
          guestId: guest.id,
          templateId: template.id,
          documentType: template.type,
          subject: template.name,
          recipientEmail: guest.email,
          recipientPhone: guest.phone ?? void 0,
          message: template.content ? template.content.slice(0, 280) : void 0
        },
        null
      );
    } catch (err) {
      this.logger.warn(`Auto-send signature failed for reservation ${reservation.id}: ${err}`);
      return null;
    }
  }
  async createCoi(dto, actorId) {
    const expiresAt = dto.expiresAt ? new Date(dto.expiresAt) : null;
    const reminderAt = expiresAt ? this.computeReminder(expiresAt, 7) : null;
    const upload = await this.prisma.coiUpload.create({
      data: {
        campgroundId: dto.campgroundId,
        reservationId: dto.reservationId ?? null,
        guestId: dto.guestId ?? null,
        fileUrl: dto.fileUrl,
        storageKey: dto.storageKey ?? null,
        status: dto.status ?? CoiStatus.active,
        expiresAt,
        reminderAt,
        notes: dto.notes ?? null
      }
    });
    await this.audit.record({
      campgroundId: dto.campgroundId,
      actorId,
      action: "coi.uploaded",
      entity: "CoiUpload",
      entityId: upload.id,
      after: { reservationId: dto.reservationId, guestId: dto.guestId, expiresAt }
    });
    return upload;
  }
  async dispatchReminders() {
    const now = /* @__PURE__ */ new Date();
    const signatureCandidates = await this.prisma.signatureRequest.findMany({
      where: {
        status: { in: [SignatureRequestStatus.sent, SignatureRequestStatus.viewed] },
        reminderAt: { lte: now },
        expiresAt: { gt: now }
      },
      take: 25
    });
    for (const req of signatureCandidates) {
      try {
        await this.deliverRequest(req);
        await this.prisma.signatureRequest.update({
          where: { id: req.id },
          data: {
            reminderCount: req.reminderCount + 1,
            reminderAt: this.computeReminder(req.expiresAt)
          }
        });
      } catch (err) {
        this.logger.warn(`Failed to send reminder for ${req.id}: ${err}`);
      }
    }
    const expiryThreshold = new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3);
    const coiCandidates = await this.prisma.coiUpload.findMany({
      where: {
        status: { in: [CoiStatus.pending, CoiStatus.active] },
        expiresAt: { lte: expiryThreshold },
        OR: [{ reminderAt: null }, { reminderAt: { lte: now } }]
      },
      take: 25
    });
    for (const coi of coiCandidates) {
      try {
        const subject = "Certificate of Insurance expiring soon";
        const email = coi.guestId ? (await this.prisma.guest.findUnique({ where: { id: coi.guestId }, select: { email: true } }))?.email : null;
        if (email) {
          await this.email.sendEmail({
            to: email,
            subject,
            html: `<p>Your certificate of insurance on file will expire on ${coi.expiresAt?.toISOString()}. Please upload a new COI.</p>`
          });
        }
        await this.prisma.coiUpload.update({
          where: { id: coi.id },
          data: { reminderCount: coi.reminderCount + 1, reminderAt: this.computeReminder(coi.expiresAt, 3) }
        });
      } catch (err) {
        this.logger.warn(`Failed COI reminder for ${coi.id}: ${err}`);
      }
    }
  }
};
__decorateClass([
  (0, import_schedule5.Cron)(import_schedule5.CronExpression.EVERY_10_MINUTES)
], SignaturesService.prototype, "dispatchReminders", 1);
SignaturesService = __decorateClass([
  (0, import_common79.Injectable)()
], SignaturesService);

// src/sms/sms.module.ts
var import_common81 = require("@nestjs/common");

// src/sms/sms.service.ts
var import_common80 = require("@nestjs/common");
var import_node_fetch2 = __toESM(require("node-fetch"));
var SmsService = class {
  constructor(alerting) {
    this.alerting = alerting;
    this.logger = new import_common80.Logger(SmsService.name);
    this.twilioSid = process.env.TWILIO_ACCOUNT_SID || "";
    this.twilioToken = process.env.TWILIO_AUTH_TOKEN || "";
    this.fromNumber = process.env.TWILIO_FROM_NUMBER || "";
    this.smsEnabled = process.env.SMS_ENABLED !== "false";
    this.backoffScheduleMs = [0, 400, 1200];
    // Telemetry counters
    this.telemetry = {
      attempted: 0,
      sent: 0,
      failed: 0,
      skipped: 0
    };
    this.isConfigured = !!(this.twilioSid && this.twilioToken && this.fromNumber);
    if (this.isConfigured) {
      this.logger.log("SMS service initialized with Twilio credentials");
    } else {
      this.logger.warn("SMS service running in no-op mode (Twilio not configured)");
    }
  }
  /**
   * Check if SMS is available
   */
  isAvailable() {
    return this.smsEnabled && this.isConfigured;
  }
  /**
   * Get telemetry stats
   */
  getStats() {
    return { ...this.telemetry, configured: this.isConfigured, enabled: this.smsEnabled };
  }
  async sendSms(opts) {
    this.telemetry.attempted++;
    if (!this.smsEnabled) {
      this.logger.debug(`SMS disabled by feature flag, would send to ${opts.to}`);
      this.telemetry.skipped++;
      return { provider: "disabled", fallback: "feature_flag_off", success: false };
    }
    if (!this.isConfigured) {
      this.logger.warn(`SMS no-op: Twilio not configured. Would send to ${opts.to}: "${opts.body.substring(0, 50)}..."`);
      this.telemetry.skipped++;
      this.dispatchAlert("SMS not configured", `Twilio credentials missing; SMS send skipped for ${opts.to}`, "warning", {
        to: opts.to,
        campgroundId: opts.campgroundId,
        reservationId: opts.reservationId,
        reason: "not_configured"
      });
      return { provider: "noop", fallback: "not_configured", success: false };
    }
    const url = `https://api.twilio.com/2010-04-01/Accounts/${this.twilioSid}/Messages.json`;
    const params = new URLSearchParams();
    params.append("To", opts.to);
    params.append("From", this.fromNumber);
    params.append("Body", opts.body);
    const attemptSend = async () => {
      const res = await (0, import_node_fetch2.default)(url, {
        method: "POST",
        headers: {
          Authorization: "Basic " + Buffer.from(`${this.twilioSid}:${this.twilioToken}`).toString("base64"),
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params.toString()
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(`Twilio send failed: ${res.status} ${JSON.stringify(data)}`);
      }
      this.telemetry.sent++;
      this.logger.log(`SMS sent to ${opts.to} via Twilio (sid: ${data.sid})`);
      return { providerMessageId: data.sid, provider: "twilio", success: true };
    };
    let lastError;
    for (const delay of this.backoffScheduleMs) {
      if (delay > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
      try {
        return await attemptSend();
      } catch (err) {
        lastError = err;
        this.logger.warn(`Twilio send attempt failed (delay ${delay}ms): ${err}`);
      }
    }
    this.telemetry.failed++;
    this.logger.error(`Twilio failed for ${opts.to} after ${this.backoffScheduleMs.length} attempts: ${lastError}`);
    await this.dispatchAlert(
      "SMS send failure",
      `Twilio failed for ${opts.to} after retries`,
      "error",
      `sms-send-failure-${opts.campgroundId ?? "global"}`,
      { to: opts.to, campgroundId: opts.campgroundId, reservationId: opts.reservationId, error: lastError?.message }
    );
    return { provider: "twilio", fallback: "send_failed", success: false };
  }
  async dispatchAlert(title, body, severity, dedupKey, details) {
    try {
      await this.alerting.dispatch(title, body, severity, dedupKey, details);
    } catch (err) {
      this.logger.debug(`SMS alert dispatch skipped: ${err?.message ?? err}`);
    }
  }
};
SmsService = __decorateClass([
  (0, import_common80.Injectable)()
], SmsService);

// src/sms/sms.module.ts
var SmsModule = class {
};
SmsModule = __decorateClass([
  (0, import_common81.Module)({
    providers: [SmsService],
    exports: [SmsService]
  })
], SmsModule);

// src/signatures/signatures.module.ts
var SignaturesModule = class {
};
SignaturesModule = __decorateClass([
  (0, import_common82.Module)({
    imports: [PrismaModule, EmailModule, SmsModule, AuditModule, PermissionsModule],
    controllers: [SignaturesController],
    providers: [SignaturesService],
    exports: [SignaturesService]
  })
], SignaturesModule);

// src/approvals/approvals.module.ts
var import_common85 = require("@nestjs/common");

// src/approvals/approvals.service.ts
var import_common83 = require("@nestjs/common");
var import_crypto9 = require("crypto");
var ApprovalsService = class {
  constructor() {
    this.policies = [
      {
        id: "policy-refund",
        name: "Refunds over $250",
        appliesTo: ["refund"],
        thresholdCents: 25e3,
        currency: "USD",
        approversNeeded: 2,
        description: "Dual control for refunds above $250 or cross-currency refunds."
      },
      {
        id: "policy-payout",
        name: "Payout releases",
        appliesTo: ["payout"],
        approversNeeded: 2,
        currency: "USD",
        description: "Require two approvers for operator payouts."
      },
      {
        id: "policy-config",
        name: "High-value config",
        appliesTo: ["config_change"],
        approversNeeded: 1,
        currency: "USD",
        description: "Pricing/tax/currency changes above safe threshold."
      }
    ];
    this.requests = [
      {
        id: "ap-001",
        type: "refund",
        amount: 27500,
        currency: "USD",
        status: "pending",
        reason: "Refund for early departure (Reservation #R-1042)",
        requester: "Alex Rivera",
        approvals: [],
        requiredApprovals: 2,
        metadata: { reservationId: "R-1042", guest: "Morgan Lee" },
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        policyId: "policy-refund"
      },
      {
        id: "ap-002",
        type: "payout",
        amount: 128500,
        currency: "USD",
        status: "pending_second",
        reason: "Weekly operator payout",
        requester: "Finance Bot",
        approvals: [{ approver: "Dana W.", at: new Date(Date.now() - 5 * 60 * 1e3).toISOString() }],
        requiredApprovals: 2,
        metadata: { period: "2025-12-01 \u2192 2025-12-07" },
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        policyId: "policy-payout"
      },
      {
        id: "ap-003",
        type: "config_change",
        amount: 0,
        currency: "USD",
        status: "pending",
        reason: "Toggle VAT-inclusive pricing for EU parks",
        requester: "Compliance",
        approvals: [],
        requiredApprovals: 1,
        metadata: { portfolioId: "pf-continental", parkIds: ["cg-alpine"] },
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        policyId: "policy-config"
      }
    ];
  }
  list() {
    return { requests: this.requests, policies: this.policies };
  }
  create(payload) {
    const policy = this.resolvePolicy(payload.type, payload.amount, payload.currency);
    const requiredApprovals = policy?.approversNeeded ?? 1;
    const request = {
      id: (0, import_crypto9.randomUUID)(),
      type: payload.type,
      amount: payload.amount,
      currency: payload.currency,
      status: "pending",
      reason: payload.reason,
      requester: payload.requester,
      approvals: [],
      requiredApprovals,
      metadata: payload.metadata,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      policyId: policy?.id ?? "policy-manual"
    };
    this.requests.unshift(request);
    return request;
  }
  approve(id, approver) {
    const request = this.requests.find((r) => r.id === id);
    if (!request) return null;
    const already = request.approvals.some((a) => a.approver === approver);
    if (!already) {
      request.approvals.push({ approver, at: (/* @__PURE__ */ new Date()).toISOString() });
    }
    const approvalsCount = request.approvals.length;
    request.status = approvalsCount >= request.requiredApprovals ? "approved" : "pending_second";
    request.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    return request;
  }
  reject(id, approver, reason) {
    const request = this.requests.find((r) => r.id === id);
    if (!request) return null;
    request.status = "rejected";
    request.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    request.metadata = { ...request.metadata, rejectionReason: reason, rejectedBy: approver };
    return request;
  }
  policiesList() {
    return this.policies;
  }
  resolvePolicy(type, amount, currency) {
    return this.policies.find((p) => {
      const matchesType = p.appliesTo.includes(type);
      const matchesCurrency = !p.currency || p.currency === currency;
      const meetsThreshold = p.thresholdCents ? amount * 100 >= p.thresholdCents : true;
      return matchesType && matchesCurrency && meetsThreshold;
    });
  }
};
ApprovalsService = __decorateClass([
  (0, import_common83.Injectable)()
], ApprovalsService);

// src/approvals/approvals.controller.ts
var import_common84 = require("@nestjs/common");
var ApprovalsController = class {
  constructor(approvals) {
    this.approvals = approvals;
  }
  list() {
    return this.approvals.list();
  }
  policies() {
    return this.approvals.policiesList();
  }
  create(body) {
    return this.approvals.create(body);
  }
  approve(id, body) {
    return this.approvals.approve(id, body.approver);
  }
  reject(id, body) {
    return this.approvals.reject(id, body.approver, body.reason);
  }
};
__decorateClass([
  (0, import_common84.Get)()
], ApprovalsController.prototype, "list", 1);
__decorateClass([
  (0, import_common84.Get)("policies")
], ApprovalsController.prototype, "policies", 1);
__decorateClass([
  (0, import_common84.Post)(),
  __decorateParam(0, (0, import_common84.Body)())
], ApprovalsController.prototype, "create", 1);
__decorateClass([
  (0, import_common84.Post)(":id/approve"),
  __decorateParam(0, (0, import_common84.Param)("id")),
  __decorateParam(1, (0, import_common84.Body)())
], ApprovalsController.prototype, "approve", 1);
__decorateClass([
  (0, import_common84.Post)(":id/reject"),
  __decorateParam(0, (0, import_common84.Param)("id")),
  __decorateParam(1, (0, import_common84.Body)())
], ApprovalsController.prototype, "reject", 1);
ApprovalsController = __decorateClass([
  (0, import_common84.UseGuards)(JwtAuthGuard),
  (0, import_common84.Controller)("approvals")
], ApprovalsController);

// src/approvals/approvals.module.ts
var ApprovalsModule = class {
};
ApprovalsModule = __decorateClass([
  (0, import_common85.Module)({
    controllers: [ApprovalsController],
    providers: [ApprovalsService],
    exports: [ApprovalsService]
  })
], ApprovalsModule);

// src/reservations/reservations.module.ts
var ReservationsModule = class {
};
ReservationsModule = __decorateClass([
  (0, import_common86.Module)({
    imports: [WaitlistModule, LoyaltyModule, SeasonalRatesModule, TaxRulesModule, GamificationModule, AuditModule, AccessControlModule, SignaturesModule, ApprovalsModule],
    controllers: [ReservationsController],
    providers: [
      ReservationsService,
      ReservationImportExportService,
      PrismaService,
      PricingService,
      RedisService,
      LockService,
      PromotionsService,
      MatchScoreService,
      PricingV2Service,
      DepositPoliciesService,
      IdempotencyService
    ],
    exports: [ReservationsService, MatchScoreService]
  })
], ReservationsModule);

// src/redis/redis.module.ts
var import_common87 = require("@nestjs/common");
var RedisModule = class {
};
RedisModule = __decorateClass([
  (0, import_common87.Global)(),
  (0, import_common87.Module)({
    providers: [RedisService, LockService],
    exports: [RedisService, LockService]
  })
], RedisModule);

// src/site-classes/site-classes.module.ts
var import_common90 = require("@nestjs/common");

// src/site-classes/site-classes.service.ts
var import_common88 = require("@nestjs/common");
var SiteClassesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  findOne(id) {
    return this.prisma.siteClass.findUnique({
      where: { id },
      include: {
        campground: true
      }
    });
  }
  listByCampground(campgroundId) {
    return this.prisma.siteClass.findMany({ where: { campgroundId }, orderBy: { name: "asc" } });
  }
  create(data) {
    return this.prisma.siteClass.create({ data: { ...data, siteType: data.siteType } });
  }
  update(id, data) {
    const { campgroundId, siteType, ...rest } = data;
    return this.prisma.siteClass.update({
      where: { id },
      data: {
        ...rest,
        ...siteType ? { siteType } : {}
      }
    });
  }
  remove(id) {
    return this.prisma.siteClass.delete({ where: { id } });
  }
};
SiteClassesService = __decorateClass([
  (0, import_common88.Injectable)()
], SiteClassesService);

// src/site-classes/site-classes.controller.ts
var import_common89 = require("@nestjs/common");
var SiteClassesController = class {
  constructor(siteClasses) {
    this.siteClasses = siteClasses;
  }
  list(campgroundId) {
    return this.siteClasses.listByCampground(campgroundId);
  }
  getById(id) {
    return this.siteClasses.findOne(id);
  }
  create(campgroundId, body) {
    return this.siteClasses.create({ campgroundId, ...body });
  }
  update(id, body) {
    return this.siteClasses.update(id, body);
  }
  remove(id) {
    return this.siteClasses.remove(id);
  }
};
__decorateClass([
  (0, import_common89.Get)("campgrounds/:campgroundId/site-classes"),
  __decorateParam(0, (0, import_common89.Param)("campgroundId"))
], SiteClassesController.prototype, "list", 1);
__decorateClass([
  (0, import_common89.Get)("site-classes/:id"),
  __decorateParam(0, (0, import_common89.Param)("id"))
], SiteClassesController.prototype, "getById", 1);
__decorateClass([
  (0, import_common89.Post)("campgrounds/:campgroundId/site-classes"),
  __decorateParam(0, (0, import_common89.Param)("campgroundId")),
  __decorateParam(1, (0, import_common89.Body)())
], SiteClassesController.prototype, "create", 1);
__decorateClass([
  (0, import_common89.Patch)("site-classes/:id"),
  __decorateParam(0, (0, import_common89.Param)("id")),
  __decorateParam(1, (0, import_common89.Body)())
], SiteClassesController.prototype, "update", 1);
__decorateClass([
  (0, import_common89.Delete)("site-classes/:id"),
  __decorateParam(0, (0, import_common89.Param)("id"))
], SiteClassesController.prototype, "remove", 1);
SiteClassesController = __decorateClass([
  (0, import_common89.UseGuards)(JwtAuthGuard),
  (0, import_common89.Controller)()
], SiteClassesController);

// src/site-classes/site-classes.module.ts
var SiteClassesModule = class {
};
SiteClassesModule = __decorateClass([
  (0, import_common90.Module)({
    controllers: [SiteClassesController],
    providers: [SiteClassesService, PrismaService]
  })
], SiteClassesModule);

// src/dashboard/dashboard.module.ts
var import_common93 = require("@nestjs/common");

// src/dashboard/dashboard.controller.ts
var import_common91 = require("@nestjs/common");
var DashboardController = class {
  constructor(dashboard) {
    this.dashboard = dashboard;
  }
  summary(campgroundId, req) {
    const org = req.organizationId || void 0;
    return this.dashboard.summary(campgroundId, org);
  }
};
__decorateClass([
  (0, import_common91.Get)("campgrounds/:campgroundId/summary"),
  __decorateParam(0, (0, import_common91.Param)("campgroundId")),
  __decorateParam(1, (0, import_common91.Req)())
], DashboardController.prototype, "summary", 1);
DashboardController = __decorateClass([
  (0, import_common91.UseGuards)(JwtAuthGuard),
  (0, import_common91.Controller)("dashboard")
], DashboardController);

// src/dashboard/dashboard.service.ts
var import_common92 = require("@nestjs/common");
var DashboardService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async summary(campgroundId, orgId) {
    const campground = await this.prisma.campground.findFirst({
      where: { id: campgroundId, ...orgId ? { organizationId: orgId } : {} },
      select: { id: true, organizationId: true, name: true }
    });
    if (!campground) throw new import_common92.NotFoundException("Campground not found");
    const now = /* @__PURE__ */ new Date();
    const [sites, reservations, maintenanceOpen, maintenanceOverdue] = await Promise.all([
      this.prisma.site.count({ where: { campgroundId } }),
      this.prisma.reservation.findMany({
        where: { campgroundId },
        select: { arrivalDate: true, departureDate: true, totalAmount: true, paidAmount: true, status: true }
      }),
      this.prisma.maintenanceTicket.count({
        where: { campgroundId, status: { not: "closed" } }
      }),
      this.prisma.maintenanceTicket.count({
        where: {
          campgroundId,
          status: { not: "closed" },
          dueDate: { lt: now }
        }
      })
    ]);
    const windowEnd = new Date(now);
    windowEnd.setDate(windowEnd.getDate() + 30);
    let bookedNights = 0;
    let totalNights = 0;
    let revenueCents = 0;
    let futureReservations = 0;
    let overdueBalancesCents = 0;
    for (const r of reservations) {
      const arrival = new Date(r.arrivalDate);
      const departure = new Date(r.departureDate);
      if (arrival >= now) futureReservations += 1;
      const start = arrival > now ? arrival : now;
      const end = departure < windowEnd ? departure : windowEnd;
      const ms = end.getTime() - start.getTime();
      const nights = Math.max(0, Math.round(ms / (1e3 * 60 * 60 * 24)));
      bookedNights += nights;
      const stayNights = Math.max(
        0,
        Math.round((departure.getTime() - arrival.getTime()) / (1e3 * 60 * 60 * 24))
      );
      totalNights += stayNights;
      revenueCents += r.totalAmount ?? 0;
      const balance = (r.totalAmount ?? 0) - (r.paidAmount ?? 0);
      if (balance > 0 && arrival < now) {
        overdueBalancesCents += balance;
      }
    }
    const occupancy = sites > 0 ? Math.min(100, Math.round(bookedNights / (sites * 30) * 100)) : 0;
    const adr = totalNights > 0 ? revenueCents / 100 / totalNights : 0;
    const revpar = sites > 0 ? revenueCents / 100 / (sites * 30) : 0;
    return {
      campground: { id: campground.id, name: campground.name },
      sites,
      futureReservations,
      occupancy,
      adr,
      revpar,
      revenue: revenueCents / 100,
      overdueBalance: overdueBalancesCents / 100,
      maintenanceOpen,
      maintenanceOverdue
    };
  }
};
DashboardService = __decorateClass([
  (0, import_common92.Injectable)()
], DashboardService);

// src/dashboard/dashboard.module.ts
var DashboardModule = class {
};
DashboardModule = __decorateClass([
  (0, import_common93.Module)({
    controllers: [DashboardController],
    providers: [DashboardService, PrismaService]
  })
], DashboardModule);

// src/maintenance/maintenance.module.ts
var import_common96 = require("@nestjs/common");

// src/maintenance/maintenance.controller.ts
var import_common94 = require("@nestjs/common");
var MaintenanceController = class {
  constructor(maintenanceService) {
    this.maintenanceService = maintenanceService;
  }
  create(createMaintenanceDto) {
    return this.maintenanceService.create(createMaintenanceDto);
  }
  findAll(campgroundId, status, siteId, outOfOrder) {
    const outOfOrderBool = outOfOrder === "true" ? true : outOfOrder === "false" ? false : void 0;
    return this.maintenanceService.findAll(campgroundId, status, siteId, outOfOrderBool);
  }
  findOne(id) {
    return this.maintenanceService.findOne(id);
  }
  update(id, updateMaintenanceDto) {
    return this.maintenanceService.update(id, updateMaintenanceDto);
  }
  remove(id) {
    return this.maintenanceService.remove(id);
  }
};
__decorateClass([
  (0, import_common94.Post)(),
  __decorateParam(0, (0, import_common94.Body)())
], MaintenanceController.prototype, "create", 1);
__decorateClass([
  (0, import_common94.Get)(),
  __decorateParam(0, (0, import_common94.Query)("campgroundId")),
  __decorateParam(1, (0, import_common94.Query)("status")),
  __decorateParam(2, (0, import_common94.Query)("siteId")),
  __decorateParam(3, (0, import_common94.Query)("outOfOrder"))
], MaintenanceController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common94.Get)(":id"),
  __decorateParam(0, (0, import_common94.Param)("id"))
], MaintenanceController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common94.Patch)(":id"),
  __decorateParam(0, (0, import_common94.Param)("id")),
  __decorateParam(1, (0, import_common94.Body)())
], MaintenanceController.prototype, "update", 1);
__decorateClass([
  (0, import_common94.Delete)(":id"),
  __decorateParam(0, (0, import_common94.Param)("id"))
], MaintenanceController.prototype, "remove", 1);
MaintenanceController = __decorateClass([
  (0, import_common94.UseGuards)(JwtAuthGuard),
  (0, import_common94.Controller)("maintenance")
], MaintenanceController);

// src/maintenance/maintenance.service.ts
var import_common95 = require("@nestjs/common");
var import_client15 = require("@prisma/client");
var import_crypto10 = require("crypto");
var MaintenanceService = class {
  constructor(prisma, gamification) {
    this.prisma = prisma;
    this.gamification = gamification;
  }
  async create(data) {
    const lockId = data.lockId ?? (0, import_crypto10.randomUUID)();
    return this.prisma.maintenanceTicket.create({
      data: {
        campgroundId: data.campgroundId,
        siteId: data.siteId,
        title: data.title,
        description: data.description,
        priority: data.priority,
        dueDate: data.dueDate ? new Date(data.dueDate) : void 0,
        assignedTo: data.assignedTo,
        isBlocking: data.isBlocking,
        outOfOrder: data.outOfOrder ?? false,
        outOfOrderReason: data.outOfOrderReason,
        outOfOrderUntil: data.outOfOrderUntil ? new Date(data.outOfOrderUntil) : void 0,
        checklist: data.checklist,
        photos: data.photos,
        notes: data.notes,
        lockId
      },
      include: {
        site: true,
        assignee: true
      }
    });
  }
  async findAll(campgroundId, status, siteId, outOfOrder) {
    return this.prisma.maintenanceTicket.findMany({
      where: {
        campgroundId,
        status,
        siteId,
        outOfOrder: outOfOrder !== void 0 ? outOfOrder : void 0
      },
      include: {
        site: true,
        assignee: true
      },
      orderBy: {
        createdAt: "desc"
      }
    });
  }
  async findOne(id) {
    return this.prisma.maintenanceTicket.findUnique({
      where: { id },
      include: {
        site: true,
        assignee: true
      }
    });
  }
  async update(id, data) {
    const existing = await this.prisma.maintenanceTicket.findUnique({
      where: { id }
    });
    if (!existing) throw new Error("Ticket not found");
    let resolvedAt = data.resolvedAt ? new Date(data.resolvedAt) : void 0;
    if (data.status === "closed" && !resolvedAt) {
      resolvedAt = /* @__PURE__ */ new Date();
    }
    let reopenedAt;
    const isReopening = existing.status === "closed" && data.status && data.status !== "closed";
    if (isReopening) {
      reopenedAt = /* @__PURE__ */ new Date();
    }
    let outOfOrder = data.outOfOrder;
    if (data.status === "closed" && outOfOrder === void 0) {
      outOfOrder = false;
    }
    const updatePayload = {
      title: data.title,
      description: data.description,
      status: data.status,
      priority: data.priority,
      dueDate: data.dueDate ? new Date(data.dueDate) : void 0,
      assignedTo: data.assignedTo,
      assignedToTeamId: data.assignedToTeamId,
      isBlocking: data.isBlocking,
      resolvedAt,
      reopenedAt,
      outOfOrder,
      outOfOrderReason: data.outOfOrderReason,
      outOfOrderUntil: data.outOfOrderUntil ? new Date(data.outOfOrderUntil) : void 0,
      checklist: data.checklist,
      photos: data.photos,
      notes: data.notes
    };
    const updated = await this.prisma.maintenanceTicket.update({
      where: { id },
      data: updatePayload,
      include: {
        site: true,
        assignee: true
      }
    });
    const isClosing = existing && data.status === "closed" && existing.status !== "closed";
    const targetUserId = updatePayload.assignedTo ?? existing?.assignedTo;
    if (isClosing && targetUserId) {
      await this.gamification.recordEvent({
        campgroundId: updated.campgroundId,
        userId: targetUserId,
        membershipId: void 0,
        category: import_client15.GamificationEventCategory.maintenance,
        reason: `Maintenance closed: ${updated.title}`,
        sourceType: "maintenance_ticket",
        sourceId: updated.id,
        eventKey: `maintenance:${updated.id}:closed`
      });
    }
    return updated;
  }
  async remove(id) {
    return this.prisma.maintenanceTicket.delete({
      where: { id }
    });
  }
};
MaintenanceService = __decorateClass([
  (0, import_common95.Injectable)()
], MaintenanceService);

// src/maintenance/maintenance.module.ts
var MaintenanceModule = class {
};
MaintenanceModule = __decorateClass([
  (0, import_common96.Module)({
    imports: [PrismaModule, GamificationModule],
    controllers: [MaintenanceController],
    providers: [MaintenanceService],
    exports: [MaintenanceService]
  })
], MaintenanceModule);

// src/pricing/pricing.module.ts
var import_common98 = require("@nestjs/common");

// src/pricing/pricing.controller.ts
var import_common97 = require("@nestjs/common");
var import_client16 = require("@prisma/client");
var PricingController = class {
  constructor(pricing) {
    this.pricing = pricing;
  }
  list(campgroundId) {
    return this.pricing.listByCampground(campgroundId);
  }
  create(campgroundId, dto) {
    return this.pricing.create(campgroundId, dto);
  }
  update(id, dto) {
    return this.pricing.update(id, dto);
  }
  remove(id) {
    return this.pricing.remove(id);
  }
};
__decorateClass([
  Roles(import_client16.UserRole.owner, import_client16.UserRole.manager),
  (0, import_common97.Get)("campgrounds/:campgroundId/pricing-rules"),
  __decorateParam(0, (0, import_common97.Param)("campgroundId"))
], PricingController.prototype, "list", 1);
__decorateClass([
  Roles(import_client16.UserRole.owner, import_client16.UserRole.manager),
  (0, import_common97.Post)("campgrounds/:campgroundId/pricing-rules"),
  __decorateParam(0, (0, import_common97.Param)("campgroundId")),
  __decorateParam(1, (0, import_common97.Body)())
], PricingController.prototype, "create", 1);
__decorateClass([
  Roles(import_client16.UserRole.owner, import_client16.UserRole.manager),
  (0, import_common97.Patch)("pricing-rules/:id"),
  __decorateParam(0, (0, import_common97.Param)("id")),
  __decorateParam(1, (0, import_common97.Body)())
], PricingController.prototype, "update", 1);
__decorateClass([
  Roles(import_client16.UserRole.owner, import_client16.UserRole.manager),
  (0, import_common97.Delete)("pricing-rules/:id"),
  __decorateParam(0, (0, import_common97.Param)("id"))
], PricingController.prototype, "remove", 1);
PricingController = __decorateClass([
  (0, import_common97.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common97.Controller)()
], PricingController);

// src/pricing/pricing.module.ts
var PricingModule = class {
};
PricingModule = __decorateClass([
  (0, import_common98.Module)({
    imports: [PrismaModule],
    providers: [PricingService],
    controllers: [PricingController]
  })
], PricingModule);

// src/ledger/ledger.module.ts
var import_common101 = require("@nestjs/common");

// src/ledger/ledger.service.ts
var import_common99 = require("@nestjs/common");
var import_crypto11 = require("crypto");
var LedgerGuard = class {
  static ensureBalanced(lines) {
    if (!lines || lines.length < 2) {
      throw new import_common99.BadRequestException("At least two ledger lines are required for double-entry");
    }
    let debit = 0;
    let credit = 0;
    for (const line of lines) {
      if (!line.glAccountId) throw new import_common99.BadRequestException("Ledger line missing GL account id");
      if (line.amountCents <= 0) throw new import_common99.BadRequestException("Ledger line amount must be positive");
      if (line.side !== "debit" && line.side !== "credit") {
        throw new import_common99.BadRequestException("Ledger line side must be debit or credit");
      }
      if (line.side === "debit") debit += line.amountCents;
      if (line.side === "credit") credit += line.amountCents;
    }
    if (debit !== credit) {
      throw new import_common99.BadRequestException(`Ledger not balanced (debits=${debit} credits=${credit})`);
    }
  }
};
var LedgerService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  list(campgroundId, start, end, glCode) {
    return this.prisma.ledgerEntry.findMany({
      where: {
        campgroundId,
        glCode: glCode || void 0,
        ...start || end ? {
          occurredAt: {
            gte: start,
            lte: end
          }
        } : {}
      },
      orderBy: { occurredAt: "desc" }
    });
  }
  listByReservation(reservationId) {
    return this.prisma.ledgerEntry.findMany({
      where: { reservationId },
      orderBy: { occurredAt: "desc" }
    });
  }
  async summaryByGl(campgroundId, start, end) {
    const rows = await this.list(campgroundId, start, end);
    const map = {};
    for (const r of rows) {
      const key = r.glCode || "Unassigned";
      const sign = r.direction === "credit" ? 1 : -1;
      map[key] = (map[key] || 0) + sign * r.amountCents;
    }
    return Object.entries(map).map(([glCode, netCents]) => ({ glCode, netCents }));
  }
  async ensureAccount(campgroundId, code, name, type) {
    const existing = await this.prisma.glAccount.findFirst({ where: { campgroundId, code }, select: { id: true } });
    if (existing) return existing.id;
    const created = await this.prisma.glAccount.create({
      data: { campgroundId, code, name, type }
    });
    return created.id;
  }
  async resolvePeriodId(campgroundId, occurredAt, allowAdjustment) {
    const period = await this.prisma.glPeriod.findFirst({
      where: { campgroundId, startDate: { lte: occurredAt }, endDate: { gte: occurredAt } },
      orderBy: { startDate: "desc" }
    });
    if (!period) return null;
    if (period.status !== "open" && !allowAdjustment) {
      throw new import_common99.ForbiddenException("GL period is closed or locked for this date");
    }
    return period.id;
  }
  async postEntries(request) {
    LedgerGuard.ensureBalanced(request.lines);
    const occurredAt = request.occurredAt ?? /* @__PURE__ */ new Date();
    const allowAdjustment = request.adjustment ?? false;
    const periodId = request.periodId ?? await this.resolvePeriodId(request.campgroundId, occurredAt, allowAdjustment);
    const payloadForHash = {
      campgroundId: request.campgroundId,
      reservationId: request.reservationId ?? null,
      occurredAt: occurredAt.toISOString(),
      sourceType: request.sourceType ?? null,
      sourceTxId: request.sourceTxId ?? null,
      description: request.description ?? null,
      lines: request.lines.map((l) => ({ side: l.side, amountCents: l.amountCents, glAccountId: l.glAccountId, memo: l.memo }))
    };
    const hash4 = (0, import_crypto11.createHash)("sha256").update(JSON.stringify(payloadForHash)).digest("hex");
    const dedupeKey = request.dedupeKey ?? hash4;
    const dedupeFilters = [
      dedupeKey ? { dedupeKey } : null,
      request.sourceTxId ? { sourceTxId: request.sourceTxId } : null
    ].filter(Boolean);
    if (dedupeFilters.length > 0) {
      const exists = await this.prisma.ledgerEntry.findFirst({
        where: {
          campgroundId: request.campgroundId,
          OR: dedupeFilters
        },
        select: { id: true }
      });
      if (exists) {
        return { duplicated: true, entryIds: [exists.id] };
      }
    }
    const entryIds = [];
    await this.prisma.$transaction(async (tx) => {
      for (const line of request.lines) {
        const entry = await tx.ledgerEntry.create({
          data: {
            campgroundId: request.campgroundId,
            reservationId: request.reservationId ?? null,
            periodId,
            glCode: line.glCode ?? null,
            account: line.accountName ?? request.description ?? null,
            description: line.memo ?? request.description ?? null,
            amountCents: line.amountCents,
            direction: line.side === "credit" ? "credit" : "debit",
            occurredAt,
            externalRef: request.externalRef ?? null,
            dedupeKey,
            sourceType: request.sourceType ?? null,
            sourceTxId: request.sourceTxId ?? null,
            sourceTs: request.sourceTs ?? occurredAt,
            hash: hash4,
            adjustment: allowAdjustment
          }
        });
        entryIds.push(entry.id);
        await tx.ledgerLine.create({
          data: {
            ledgerEntryId: entry.id,
            glAccountId: line.glAccountId,
            side: line.side,
            amountCents: line.amountCents,
            memo: line.memo ?? request.description ?? null,
            productCode: line.productCode ?? null,
            channelCode: line.channelCode ?? null,
            taxJurisdiction: line.taxJurisdiction ?? null,
            taxRateBps: line.taxRateBps ?? null,
            taxableBaseCents: line.taxableBaseCents ?? null,
            reconciliationKey: line.reconciliationKey ?? request.sourceTxId ?? null
          }
        });
      }
    });
    return { duplicated: false, entryIds };
  }
  async listPeriods(campgroundId) {
    return this.prisma.glPeriod.findMany({
      where: { campgroundId },
      orderBy: [{ startDate: "asc" }, { endDate: "asc" }]
    });
  }
  async assertNoOverlap(campgroundId, startDate, endDate) {
    const overlap = await this.prisma.glPeriod.findFirst({
      where: {
        campgroundId,
        startDate: { lte: endDate },
        endDate: { gte: startDate }
      },
      select: { id: true, status: true, startDate: true, endDate: true }
    });
    if (overlap) {
      throw new import_common99.BadRequestException(
        `GL period overlaps existing period (${overlap.startDate.toISOString()} - ${overlap.endDate.toISOString()})`
      );
    }
  }
  async createPeriod(campgroundId, startDate, endDate, name) {
    if (endDate <= startDate) {
      throw new import_common99.BadRequestException("endDate must be after startDate");
    }
    await this.assertNoOverlap(campgroundId, startDate, endDate);
    return this.prisma.glPeriod.create({
      data: {
        campgroundId,
        startDate,
        endDate,
        name: name ?? `${startDate.toISOString().slice(0, 10)}-${endDate.toISOString().slice(0, 10)}`,
        status: "open"
      }
    });
  }
  async closePeriod(id, actorId) {
    const period = await this.prisma.glPeriod.findUnique({ where: { id } });
    if (!period) throw new import_common99.NotFoundException("GL period not found");
    if (period.status === "locked") {
      throw new import_common99.BadRequestException("GL period is locked");
    }
    if (period.status === "closed") return period;
    return this.prisma.glPeriod.update({
      where: { id },
      data: { status: "closed", closedAt: /* @__PURE__ */ new Date(), closedBy: actorId ?? null }
    });
  }
  async lockPeriod(id, actorId) {
    const period = await this.prisma.glPeriod.findUnique({ where: { id } });
    if (!period) throw new import_common99.NotFoundException("GL period not found");
    if (period.status === "locked") return period;
    return this.prisma.glPeriod.update({
      where: { id },
      data: {
        status: "locked",
        lockedAt: /* @__PURE__ */ new Date(),
        lockedBy: actorId ?? null,
        closedAt: period.closedAt ?? /* @__PURE__ */ new Date(),
        closedBy: period.closedBy ?? actorId ?? null
      }
    });
  }
};
LedgerService = __decorateClass([
  (0, import_common99.Injectable)()
], LedgerService);

// src/ledger/ledger.controller.ts
var import_common100 = require("@nestjs/common");
var import_client17 = require("@prisma/client");
var LedgerController = class {
  constructor(ledger) {
    this.ledger = ledger;
  }
  async list(campgroundId, start, end, glCode) {
    const startDate = start ? new Date(start) : void 0;
    const endDate = end ? new Date(end) : void 0;
    return this.ledger.list(campgroundId, startDate, endDate, glCode);
  }
  async exportCsv(campgroundId, start, end, glCode, res) {
    const rows = await this.ledger.list(
      campgroundId,
      start ? new Date(start) : void 0,
      end ? new Date(end) : void 0,
      glCode || void 0
    );
    const headers = ["date", "glCode", "account", "reservationId", "amountCents", "direction", "description"];
    const csv = [headers.join(",")].concat(
      rows.map(
        (r) => [
          r.occurredAt.toISOString(),
          r.glCode ?? "",
          r.account ?? "",
          r.reservationId ?? "",
          r.amountCents,
          r.direction,
          (r.description ?? "").replace(/,/g, ";")
        ].join(",")
      )
    ).join("\n");
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", "attachment; filename=ledger.csv");
    return res.send(csv);
  }
  listByReservation(reservationId) {
    return this.ledger.listByReservation(reservationId);
  }
  summary(campgroundId, start, end) {
    return this.ledger.summaryByGl(campgroundId, start ? new Date(start) : void 0, end ? new Date(end) : void 0);
  }
  async listPeriods(campgroundId) {
    return this.ledger.listPeriods(campgroundId);
  }
  async createPeriod(campgroundId, body) {
    const startDate = new Date(body.startDate);
    const endDate = new Date(body.endDate);
    return this.ledger.createPeriod(campgroundId, startDate, endDate, body.name);
  }
  async closePeriod(campgroundId, id, req) {
    return this.ledger.closePeriod(id, req?.user?.id);
  }
  async lockPeriod(campgroundId, id, req) {
    return this.ledger.lockPeriod(id, req?.user?.id);
  }
};
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Get)("campgrounds/:campgroundId/ledger"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Query)("start")),
  __decorateParam(2, (0, import_common100.Query)("end")),
  __decorateParam(3, (0, import_common100.Query)("glCode"))
], LedgerController.prototype, "list", 1);
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Get)("campgrounds/:campgroundId/ledger/export"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Query)("start")),
  __decorateParam(2, (0, import_common100.Query)("end")),
  __decorateParam(3, (0, import_common100.Query)("glCode")),
  __decorateParam(4, (0, import_common100.Res)())
], LedgerController.prototype, "exportCsv", 1);
__decorateClass([
  (0, import_common100.Get)("reservations/:id/ledger"),
  __decorateParam(0, (0, import_common100.Param)("id"))
], LedgerController.prototype, "listByReservation", 1);
__decorateClass([
  (0, import_common100.Get)("campgrounds/:campgroundId/ledger/summary"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Query)("start")),
  __decorateParam(2, (0, import_common100.Query)("end"))
], LedgerController.prototype, "summary", 1);
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Get)("campgrounds/:campgroundId/gl-periods"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId"))
], LedgerController.prototype, "listPeriods", 1);
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Post)("campgrounds/:campgroundId/gl-periods"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Body)())
], LedgerController.prototype, "createPeriod", 1);
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Post)("campgrounds/:campgroundId/gl-periods/:id/close"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Param)("id")),
  __decorateParam(2, (0, import_common100.Req)())
], LedgerController.prototype, "closePeriod", 1);
__decorateClass([
  Roles(import_client17.UserRole.owner, import_client17.UserRole.manager, import_client17.UserRole.finance),
  (0, import_common100.Post)("campgrounds/:campgroundId/gl-periods/:id/lock"),
  __decorateParam(0, (0, import_common100.Param)("campgroundId")),
  __decorateParam(1, (0, import_common100.Param)("id")),
  __decorateParam(2, (0, import_common100.Req)())
], LedgerController.prototype, "lockPeriod", 1);
LedgerController = __decorateClass([
  (0, import_common100.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common100.Controller)()
], LedgerController);

// src/ledger/ledger.module.ts
var LedgerModule = class {
};
LedgerModule = __decorateClass([
  (0, import_common101.Module)({
    imports: [PrismaModule],
    controllers: [LedgerController],
    providers: [LedgerService],
    exports: [LedgerService]
  })
], LedgerModule);

// src/payments/payments.module.ts
var import_common108 = require("@nestjs/common");

// src/payments/payments.controller.ts
var import_common102 = require("@nestjs/common");
var import_client18 = require("@prisma/client");
var import_class_validator = require("class-validator");
var import_class_transformer = require("class-transformer");
var UpdatePaymentSettingsDto = class {
};
__decorateClass([
  (0, import_class_validator.IsOptional)(),
  (0, import_class_validator.IsInt)(),
  (0, import_class_validator.Min)(0),
  (0, import_class_transformer.Type)(() => Number)
], UpdatePaymentSettingsDto.prototype, "applicationFeeFlatCents", 2);
__decorateClass([
  (0, import_class_validator.IsOptional)()
], UpdatePaymentSettingsDto.prototype, "billingPlan", 2);
__decorateClass([
  (0, import_class_validator.IsOptional)(),
  (0, import_class_validator.IsInt)(),
  (0, import_class_validator.Min)(0),
  (0, import_class_transformer.Type)(() => Number)
], UpdatePaymentSettingsDto.prototype, "perBookingFeeCents", 2);
__decorateClass([
  (0, import_class_validator.IsOptional)(),
  (0, import_class_validator.IsInt)(),
  (0, import_class_validator.Min)(0),
  (0, import_class_transformer.Type)(() => Number)
], UpdatePaymentSettingsDto.prototype, "monthlyFeeCents", 2);
__decorateClass([
  (0, import_class_validator.IsOptional)()
], UpdatePaymentSettingsDto.prototype, "feeMode", 2);
var PaymentsController = class {
  constructor(reservations, stripeService, prisma, recon, idempotency, gatewayConfigService) {
    this.reservations = reservations;
    this.stripeService = stripeService;
    this.prisma = prisma;
    this.recon = recon;
    this.idempotency = idempotency;
    this.gatewayConfigService = gatewayConfigService;
    this.logger = new import_common102.Logger(PaymentsController.name);
    this.capabilitiesTtlMs = Number(process.env.STRIPE_CAPABILITIES_TTL_MS ?? 6 * 60 * 60 * 1e3);
  }
  // default 6h
  async refreshCapabilitiesIfNeeded(params) {
    const { campgroundId, stripeAccountId, currentCapabilities, fetchedAt, force } = params;
    if (!stripeAccountId) {
      return { capabilities: null, fetchedAt: null, refreshed: false, skipped: true };
    }
    const ageMs = fetchedAt ? Date.now() - new Date(fetchedAt).getTime() : Infinity;
    if (!force && ageMs < this.capabilitiesTtlMs) {
      return { capabilities: currentCapabilities ?? null, fetchedAt: fetchedAt ?? null, refreshed: false, skipped: false };
    }
    try {
      const capabilities = await this.stripeService.retrieveAccountCapabilities(stripeAccountId);
      if (!capabilities) {
        return { capabilities: currentCapabilities ?? null, fetchedAt: fetchedAt ?? null, refreshed: false, skipped: true };
      }
      const updated = await this.prisma.campground.update({
        where: { id: campgroundId },
        data: {
          stripeCapabilities: capabilities,
          stripeCapabilitiesFetchedAt: /* @__PURE__ */ new Date()
        },
        select: {
          stripeCapabilities: true,
          stripeCapabilitiesFetchedAt: true
        }
      });
      return {
        capabilities: updated.stripeCapabilities,
        fetchedAt: updated.stripeCapabilitiesFetchedAt,
        refreshed: true,
        skipped: false
      };
    } catch (err) {
      this.logger.warn(`Capability refresh failed for campground ${campgroundId}: ${err?.message || err}`);
      return { capabilities: currentCapabilities ?? null, fetchedAt: fetchedAt ?? null, refreshed: false, skipped: false, error: err };
    }
  }
  async getPaymentContext(reservationId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: {
        id: true,
        campgroundId: true,
        balanceAmount: true,
        totalAmount: true,
        paidAmount: true
      }
    });
    if (!reservation) {
      throw new import_common102.BadRequestException("Reservation not found for payment");
    }
    const gatewayConfig = await this.gatewayConfigService.getConfig(reservation.campgroundId);
    if (!gatewayConfig) {
      throw new import_common102.BadRequestException("Payment gateway configuration is missing for this campground.");
    }
    if (gatewayConfig.mode === "prod" && !gatewayConfig.hasProductionCredentials) {
      throw new import_common102.BadRequestException("Payment gateway is in production mode but credentials are not configured.");
    }
    if (gatewayConfig.gateway !== "stripe") {
      throw new import_common102.BadRequestException(`Gateway ${gatewayConfig.gateway} is not yet supported.`);
    }
    const campground = await this.prisma.campground.findUnique({
      where: { id: reservation.campgroundId },
      select: {
        // Note: prisma types may lag schema changes; cast to any for new fields.
        stripeAccountId: true,
        applicationFeeFlatCents: true,
        billingPlan: true,
        perBookingFeeCents: true,
        monthlyFeeCents: true,
        feeMode: true,
        name: true,
        stripeCapabilities: true,
        stripeCapabilitiesFetchedAt: true
      }
    });
    const stripeAccountId = campground?.stripeAccountId;
    if (!stripeAccountId) {
      throw new import_common102.BadRequestException("Campground is not connected to Stripe. Please complete onboarding.");
    }
    if (!this.stripeService.isConfigured()) {
      throw new import_common102.BadRequestException("Stripe keys are not configured for the platform. Set STRIPE_SECRET_KEY to enable payments.");
    }
    const plan = campground?.billingPlan;
    const planDefaultFee = plan === "standard" ? 200 : plan === "enterprise" ? 100 : 300;
    const applicationFeeCents = campground?.perBookingFeeCents ?? campground?.applicationFeeFlatCents ?? Number(process.env.PAYMENT_PLATFORM_FEE_CENTS ?? planDefaultFee);
    const feeMode = gatewayConfig?.feeMode ?? campground?.feeMode ?? "absorb";
    const gatewayFeePercentBasisPoints = gatewayConfig?.effectiveFee?.percentBasisPoints ?? 0;
    const gatewayFeeFlatCents = gatewayConfig?.effectiveFee?.flatFeeCents ?? 0;
    const refreshed = await this.refreshCapabilitiesIfNeeded({
      campgroundId: reservation.campgroundId,
      stripeAccountId,
      currentCapabilities: campground?.stripeCapabilities,
      fetchedAt: campground?.stripeCapabilitiesFetchedAt
    });
    return {
      stripeAccountId,
      applicationFeeCents,
      campgroundId: reservation.campgroundId,
      feeMode,
      gatewayConfig,
      gatewayFeePercentBasisPoints,
      gatewayFeeFlatCents,
      reservation,
      capabilities: refreshed.capabilities ?? campground?.stripeCapabilities,
      capabilitiesFetchedAt: refreshed.fetchedAt ?? campground?.stripeCapabilitiesFetchedAt
    };
  }
  getPaymentMethodTypes(capabilities) {
    const achActive = capabilities?.us_bank_account_ach_payments === "active";
    const cardActive = capabilities?.card_payments === "active";
    const types = [];
    if (cardActive) types.push("card");
    if (achActive) types.push("us_bank_account");
    return types.length ? types : ["card"];
  }
  calculateGatewayFee(amountCents, percentBasisPoints, flatFeeCents) {
    const percentPortion = Math.round(amountCents * (percentBasisPoints ?? 0) / 1e4);
    const flatPortion = flatFeeCents ?? 0;
    return Math.max(0, percentPortion + flatPortion);
  }
  computeChargeAmounts(opts) {
    const baseDue = opts.reservation.balanceAmount ?? Math.max(0, (opts.reservation.totalAmount ?? 0) - (opts.reservation.paidAmount ?? 0));
    const platformPassThroughFeeCents = opts.platformFeeMode === "pass_through" ? opts.applicationFeeCents : 0;
    const gatewayPassThroughFeeCents = opts.gatewayFeeMode === "pass_through" ? this.calculateGatewayFee(baseDue, opts.gatewayFeePercentBasisPoints, opts.gatewayFeeFlatCents) : 0;
    const maxCharge = Math.max(0, baseDue + platformPassThroughFeeCents + gatewayPassThroughFeeCents);
    const desired = opts.requestedAmountCents ?? maxCharge;
    const amountCents = Math.min(Math.max(desired, 0), maxCharge);
    return { amountCents, platformPassThroughFeeCents, gatewayPassThroughFeeCents, baseDue };
  }
  buildReceiptLinesFromIntent(intent) {
    const toNumber = (v) => v === void 0 || v === null || Number.isNaN(Number(v)) ? 0 : Number(v);
    const baseAmount = toNumber(intent?.metadata?.baseAmountCents ?? intent?.amount_received ?? intent?.amount);
    const platformFee = toNumber(intent?.metadata?.platformPassThroughFeeCents ?? intent?.metadata?.applicationFeeCents);
    const gatewayFee = toNumber(intent?.metadata?.gatewayPassThroughFeeCents);
    const taxCents = toNumber(intent?.metadata?.taxCents);
    const lineItems = baseAmount > 0 ? [{ label: "Reservation charge", amountCents: baseAmount }] : [];
    if (platformFee > 0) lineItems.push({ label: "Platform fee", amountCents: platformFee });
    if (gatewayFee > 0) lineItems.push({ label: "Gateway fee", amountCents: gatewayFee });
    const feeCents = platformFee + gatewayFee;
    return {
      lineItems,
      taxCents: taxCents || void 0,
      feeCents: feeCents > 0 ? feeCents : void 0,
      totalCents: toNumber(intent?.amount_received ?? intent?.amount)
    };
  }
  ensureCampgroundMembership(user, campgroundId) {
    const actorCampgrounds = user?.memberships?.map((m) => m.campgroundId) ?? [];
    if (!campgroundId || !actorCampgrounds.includes(campgroundId)) {
      throw new import_common102.ForbiddenException("Forbidden by campground scope");
    }
  }
  async createIntent(body, req, idempotencyKey) {
    const currency = (body.currency || "usd").toLowerCase();
    const ctx = await this.getPaymentContext(body.reservationId);
    this.ensureCampgroundMembership(req?.user, ctx.campgroundId);
    const {
      stripeAccountId,
      applicationFeeCents,
      feeMode,
      reservation,
      campgroundId,
      capabilities,
      gatewayConfig,
      gatewayFeePercentBasisPoints,
      gatewayFeeFlatCents
    } = ctx;
    const { amountCents, platformPassThroughFeeCents, gatewayPassThroughFeeCents, baseDue } = this.computeChargeAmounts({
      reservation,
      platformFeeMode: feeMode,
      applicationFeeCents,
      gatewayFeeMode: gatewayConfig?.feeMode ?? feeMode,
      gatewayFeePercentBasisPoints,
      gatewayFeeFlatCents,
      requestedAmountCents: body.amountCents
    });
    const feeBreakdown = {
      platformFeeMode: feeMode,
      platformPassThroughFeeCents,
      gatewayFeeMode: gatewayConfig?.feeMode ?? feeMode,
      gatewayPassThroughFeeCents,
      gatewayPercentBasisPoints: gatewayFeePercentBasisPoints,
      gatewayFlatFeeCents: gatewayFeeFlatCents,
      baseAmountCents: baseDue
    };
    const threeDsPolicy = this.buildThreeDsPolicy(currency, gatewayConfig);
    if (idempotencyKey) {
      const existing = await this.idempotency.start(idempotencyKey, body, campgroundId);
      if (existing.status === import_client18.IdempotencyStatus.succeeded && existing.responseJson) {
        return existing.responseJson;
      }
      if (existing.status === import_client18.IdempotencyStatus.inflight && existing.createdAt) {
        const ageMs = Date.now() - new Date(existing.createdAt).getTime();
        if (ageMs < 6e4) {
          throw new import_common102.ConflictException("Request already in progress");
        }
      }
    }
    try {
      const intent = await this.stripeService.createPaymentIntent(
        amountCents,
        currency,
        {
          reservationId: body.reservationId,
          campgroundId,
          source: "staff_checkout",
          feeMode,
          applicationFeeCents: String(applicationFeeCents),
          platformPassThroughFeeCents: String(platformPassThroughFeeCents),
          gatewayPassThroughFeeCents: String(gatewayPassThroughFeeCents),
          gatewayProvider: gatewayConfig?.gateway ?? "stripe",
          gatewayMode: gatewayConfig?.mode ?? "test",
          gatewayFeePercentBasisPoints: String(gatewayFeePercentBasisPoints),
          gatewayFeeFlatCents: String(gatewayFeeFlatCents),
          threeDsPolicy
        },
        stripeAccountId,
        applicationFeeCents,
        body.autoCapture === false ? "manual" : "automatic",
        this.getPaymentMethodTypes(capabilities),
        idempotencyKey,
        threeDsPolicy
      );
      const response = {
        id: intent.id,
        clientSecret: intent.client_secret,
        amountCents,
        currency,
        reservationId: body.reservationId,
        status: intent.status,
        fees: feeBreakdown,
        threeDsPolicy
      };
      if (idempotencyKey) {
        await this.idempotency.complete(idempotencyKey, response);
      }
      return response;
    } catch (err) {
      if (idempotencyKey) {
        await this.idempotency.fail(idempotencyKey);
      }
      throw err;
    }
  }
  async createSetupIntent(body, req) {
    if (!body.reservationId) throw new import_common102.BadRequestException("reservationId is required");
    const ctx = await this.getPaymentContext(body.reservationId);
    this.ensureCampgroundMembership(req?.user, ctx.campgroundId);
    const { stripeAccountId, capabilities } = ctx;
    const setupIntent = await this.stripeService.createSetupIntent(
      stripeAccountId,
      {
        reservationId: body.reservationId,
        source: "staff_setup"
      },
      this.getPaymentMethodTypes(capabilities)
    );
    return { id: setupIntent.id, clientSecret: setupIntent.client_secret };
  }
  async createPublicSetupIntent(body) {
    if (!body.reservationId) throw new import_common102.BadRequestException("reservationId is required");
    const { stripeAccountId, capabilities } = await this.getPaymentContext(body.reservationId);
    const setupIntent = await this.stripeService.createSetupIntent(
      stripeAccountId,
      {
        reservationId: body.reservationId,
        source: "public_setup",
        guestEmail: body.guestEmail || ""
      },
      this.getPaymentMethodTypes(capabilities)
    );
    return { id: setupIntent.id, clientSecret: setupIntent.client_secret };
  }
  async createPublicIntent(body, idempotencyKey) {
    const currency = (body.currency || "usd").toLowerCase();
    const effectiveIdempotencyKey = idempotencyKey?.trim();
    if (!effectiveIdempotencyKey) {
      throw new import_common102.BadRequestException({
        message: "Idempotency-Key header is required for public payments",
        retryAfterMs: 500,
        hint: "Send a unique Idempotency-Key per checkout attempt and reuse it when retrying."
      });
    }
    if (!body.reservationId) {
      throw new import_common102.BadRequestException("reservationId is required for payment");
    }
    const {
      stripeAccountId,
      applicationFeeCents,
      feeMode,
      reservation,
      campgroundId,
      capabilities,
      gatewayConfig,
      gatewayFeePercentBasisPoints,
      gatewayFeeFlatCents
    } = await this.getPaymentContext(body.reservationId);
    const { amountCents, platformPassThroughFeeCents, gatewayPassThroughFeeCents, baseDue } = this.computeChargeAmounts({
      reservation,
      platformFeeMode: feeMode,
      applicationFeeCents,
      gatewayFeeMode: gatewayConfig?.feeMode ?? feeMode,
      gatewayFeePercentBasisPoints,
      gatewayFeeFlatCents
    });
    const feeBreakdown = {
      platformFeeMode: feeMode,
      platformPassThroughFeeCents,
      gatewayFeeMode: gatewayConfig?.feeMode ?? feeMode,
      gatewayPassThroughFeeCents,
      gatewayPercentBasisPoints: gatewayFeePercentBasisPoints,
      gatewayFlatFeeCents: gatewayFeeFlatCents,
      baseAmountCents: baseDue
    };
    const metadata = {
      reservationId: body.reservationId,
      campgroundId,
      source: "public_checkout",
      feeMode,
      applicationFeeCents: String(applicationFeeCents),
      platformPassThroughFeeCents: String(platformPassThroughFeeCents),
      gatewayPassThroughFeeCents: String(gatewayPassThroughFeeCents),
      gatewayProvider: gatewayConfig?.gateway ?? "stripe",
      gatewayMode: gatewayConfig?.mode ?? "test",
      gatewayFeePercentBasisPoints: String(gatewayFeePercentBasisPoints),
      gatewayFeeFlatCents: String(gatewayFeeFlatCents)
    };
    if (body.guestEmail) {
      metadata.guestEmail = body.guestEmail;
    }
    metadata.idempotencyKey = effectiveIdempotencyKey;
    const threeDsPolicy = this.buildThreeDsPolicy(currency, gatewayConfig);
    const existing = await this.idempotency.start(effectiveIdempotencyKey, body, campgroundId, {
      endpoint: "public/payments/intents",
      requestBody: body,
      metadata: { reservationId: body.reservationId, threeDsPolicy },
      rateAction: "apply"
    });
    if (existing?.status === import_client18.IdempotencyStatus.succeeded && existing.responseJson) {
      return existing.responseJson;
    }
    if (existing?.status === import_client18.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common102.ConflictException({
        message: "Payment intent creation already in progress; retry with backoff",
        retryAfterMs: 500,
        reason: "inflight",
        idempotencyKey: effectiveIdempotencyKey
      });
    }
    try {
      const intent = await this.withGatewayFailover(
        async () => this.stripeService.createPaymentIntent(
          amountCents,
          currency,
          metadata,
          stripeAccountId,
          applicationFeeCents,
          body.captureMethod === "manual" ? "manual" : "automatic",
          this.getPaymentMethodTypes(capabilities),
          effectiveIdempotencyKey,
          threeDsPolicy
        )
      );
      const response = {
        id: intent.id,
        clientSecret: intent.client_secret,
        amountCents,
        currency,
        status: intent.status,
        fees: feeBreakdown,
        threeDsPolicy
      };
      await this.idempotency.complete(effectiveIdempotencyKey, response);
      return response;
    } catch (error) {
      await this.idempotency.fail(effectiveIdempotencyKey);
      throw error;
    }
  }
  async connectCampground(campgroundId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const campground = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: { id: true, email: true, stripeAccountId: true }
    });
    if (!campground) throw new import_common102.BadRequestException("Campground not found");
    let accountId = campground?.stripeAccountId;
    if (!accountId) {
      const account = await this.stripeService.createExpressAccount(campground.email || void 0, { campgroundId });
      accountId = account.id;
      await this.prisma.campground.update({
        where: { id: campgroundId },
        data: { stripeAccountId: accountId }
      });
    }
    const returnUrl = process.env.FRONTEND_URL ? `${process.env.FRONTEND_URL}/settings/payments/success` : "https://app.campreserv.com/settings/payments/success";
    const refreshUrl = process.env.FRONTEND_URL ? `${process.env.FRONTEND_URL}/settings/payments/error` : "https://app.campreserv.com/settings/payments/error";
    const link = await this.stripeService.createAccountOnboardingLink(accountId, returnUrl, refreshUrl);
    try {
      const capabilities = await this.stripeService.retrieveAccountCapabilities(accountId);
      await this.prisma.campground.update({
        where: { id: campgroundId },
        data: {
          stripeCapabilities: capabilities,
          stripeCapabilitiesFetchedAt: /* @__PURE__ */ new Date()
        }
      });
    } catch {
    }
    return { accountId, onboardingUrl: link.url };
  }
  /**
   * Determine 3DS policy based on currency/region and gateway config.
   * EU/UK currencies default to "any" while others stay "automatic".
   */
  buildThreeDsPolicy(currency, gatewayConfig) {
    const cur = currency?.toLowerCase?.() ?? "usd";
    const region = gatewayConfig?.additionalConfig?.region ?? gatewayConfig?.region ?? null;
    const euLikeCurrencies = ["eur", "gbp", "chf", "sek", "nok"];
    if (euLikeCurrencies.includes(cur) || region === "eu" || region === "uk") {
      return "any";
    }
    return "automatic";
  }
  /**
   * Stubbed secondary-gateway failover hook. Logs the failure and preserves the
   * original error so callers can backoff/retry or switch providers when wired.
   */
  async withGatewayFailover(fn) {
    try {
      return await fn();
    } catch (err) {
      this.logger.error(`Primary gateway failed: ${err?.message ?? err}`, err);
      this.logger.warn("Secondary gateway failover stub invoked (no secondary configured)");
      const fallback = new import_common102.ServiceUnavailableException({
        message: "Payment processor unavailable; retry with backoff or alternate gateway",
        reason: "gateway_unavailable"
      });
      fallback.cause = err;
      throw fallback;
    }
  }
  async updatePaymentSettings(campgroundId, body, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const campground = await this.prisma.campground.findUnique({ where: { id: campgroundId } });
    if (!campground) throw new import_common102.BadRequestException("Campground not found");
    const updated = await this.prisma.campground.update({
      where: { id: campgroundId },
      data: {
        applicationFeeFlatCents: body.applicationFeeFlatCents ?? campground.applicationFeeFlatCents,
        perBookingFeeCents: body.perBookingFeeCents ?? campground.perBookingFeeCents,
        monthlyFeeCents: body.monthlyFeeCents ?? campground.monthlyFeeCents,
        billingPlan: body.billingPlan ?? campground.billingPlan,
        feeMode: body.feeMode ?? campground.feeMode
      },
      select: {
        stripeAccountId: true,
        applicationFeeFlatCents: true,
        perBookingFeeCents: true,
        monthlyFeeCents: true,
        billingPlan: true,
        feeMode: true,
        stripeCapabilities: true,
        stripeCapabilitiesFetchedAt: true
      }
    });
    return updated;
  }
  async refreshCapabilities(campgroundId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const cg = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: {
        stripeAccountId: true,
        applicationFeeFlatCents: true,
        perBookingFeeCents: true,
        monthlyFeeCents: true,
        billingPlan: true,
        feeMode: true,
        stripeCapabilities: true,
        stripeCapabilitiesFetchedAt: true
      }
    });
    if (!cg?.stripeAccountId) {
      return {
        ...cg,
        stripeCapabilities: null,
        stripeCapabilitiesFetchedAt: null,
        connected: false,
        refreshed: false
      };
    }
    const refreshed = await this.refreshCapabilitiesIfNeeded({
      campgroundId,
      stripeAccountId: cg.stripeAccountId,
      currentCapabilities: cg.stripeCapabilities,
      fetchedAt: cg.stripeCapabilitiesFetchedAt,
      force: true
    });
    return {
      ...cg,
      stripeCapabilities: refreshed.capabilities ?? cg.stripeCapabilities,
      stripeCapabilitiesFetchedAt: refreshed.fetchedAt ?? cg.stripeCapabilitiesFetchedAt,
      connected: true,
      refreshed: refreshed.refreshed
    };
  }
  async getPaymentIntent(id, req) {
    try {
      const intent = await this.stripeService.retrievePaymentIntent(id);
      const campgroundId = intent.metadata?.campgroundId ?? null;
      this.ensureCampgroundMembership(req?.user, campgroundId);
      return {
        id: intent.id,
        status: intent.status,
        amountCents: intent.amount,
        amountReceivedCents: intent.amount_received,
        currency: intent.currency,
        metadata: intent.metadata,
        captureMethod: intent.capture_method,
        createdAt: new Date(intent.created * 1e3).toISOString()
      };
    } catch (error) {
      if (error.code === "resource_missing") {
        throw new import_common102.NotFoundException(`Payment intent ${id} not found`);
      }
      throw error;
    }
  }
  async capturePaymentIntent(id, body, req, idempotencyKey) {
    try {
      const current = await this.stripeService.retrievePaymentIntent(id);
      const campgroundId = current.metadata?.campgroundId ?? null;
      this.ensureCampgroundMembership(req?.user, campgroundId);
      if (idempotencyKey) {
        const existing = await this.idempotency.start(idempotencyKey, { id, ...body }, campgroundId);
        if (existing.status === import_client18.IdempotencyStatus.succeeded && existing.responseJson) {
          return existing.responseJson;
        }
      }
      const intent = await this.stripeService.capturePaymentIntent(id, body.amountCents, idempotencyKey);
      const receiptLines = this.buildReceiptLinesFromIntent(intent);
      const reservationId = intent.metadata?.reservationId;
      if (reservationId) {
        await this.reservations.recordPayment(reservationId, intent.amount_received, {
          transactionId: intent.id,
          paymentMethod: intent.payment_method_types?.[0] || "card",
          source: intent.metadata?.source || "staff_checkout",
          stripePaymentIntentId: intent.id,
          stripeChargeId: intent?.latest_charge,
          capturedAt: /* @__PURE__ */ new Date(),
          lineItems: receiptLines.lineItems,
          taxCents: receiptLines.taxCents,
          feeCents: receiptLines.feeCents,
          totalCents: receiptLines.totalCents,
          receiptKind: "payment",
          tenders: [
            {
              method: intent.payment_method_types?.[0] || "card",
              amountCents: intent.amount_received ?? intent.amount ?? 0,
              note: "capture"
            }
          ]
        });
      }
      const response = {
        id: intent.id,
        status: intent.status,
        amountCents: intent.amount,
        amountReceivedCents: intent.amount_received,
        currency: intent.currency,
        lineItems: receiptLines.lineItems,
        taxCents: receiptLines.taxCents,
        feeCents: receiptLines.feeCents
      };
      if (idempotencyKey) {
        await this.idempotency.complete(idempotencyKey, response);
      }
      return response;
    } catch (error) {
      if (idempotencyKey) {
        await this.idempotency.fail(idempotencyKey);
      }
      if (error.code === "resource_missing") {
        throw new import_common102.NotFoundException(`Payment intent ${id} not found`);
      }
      throw new import_common102.BadRequestException(error.message);
    }
  }
  async refundPaymentIntent(id, body, req, idempotencyKey) {
    try {
      const intent = await this.stripeService.retrievePaymentIntent(id);
      const campgroundId = intent.metadata?.campgroundId ?? null;
      this.ensureCampgroundMembership(req?.user, campgroundId);
      if (idempotencyKey) {
        const existing = await this.idempotency.start(idempotencyKey, { id, ...body }, campgroundId);
        if (existing.status === import_client18.IdempotencyStatus.succeeded && existing.responseJson) {
          return existing.responseJson;
        }
      }
      const refund = await this.stripeService.createRefund(id, body.amountCents, body.reason, idempotencyKey);
      const receiptLines = this.buildReceiptLinesFromIntent(intent);
      const reservationId = intent.metadata?.reservationId;
      if (reservationId) {
        await this.reservations.recordRefund(reservationId, refund.amount || 0, refund.id, {
          lineItems: receiptLines.lineItems,
          taxCents: receiptLines.taxCents,
          feeCents: receiptLines.feeCents,
          totalCents: refund.amount || receiptLines.totalCents,
          paymentMethod: intent.payment_method_types?.[0] || "card",
          source: intent.metadata?.source || "online",
          tenders: [
            {
              method: intent.payment_method_types?.[0] || "card",
              amountCents: refund.amount || 0,
              note: "stripe_refund"
            }
          ]
        });
      }
      const response = {
        id: refund.id,
        status: refund.status,
        amountCents: refund.amount,
        paymentIntentId: id,
        reason: refund.reason,
        lineItems: receiptLines.lineItems,
        taxCents: receiptLines.taxCents,
        feeCents: receiptLines.feeCents
      };
      if (idempotencyKey) {
        await this.idempotency.complete(idempotencyKey, response);
      }
      return response;
    } catch (error) {
      if (idempotencyKey) {
        await this.idempotency.fail(idempotencyKey);
      }
      if (error.code === "resource_missing") {
        throw new import_common102.NotFoundException(`Payment intent ${id} not found`);
      }
      throw new import_common102.BadRequestException(error.message);
    }
  }
  async handleWebhook(req, signature) {
    if (!signature) throw new import_common102.BadRequestException("Missing stripe-signature header");
    let event;
    try {
      event = this.stripeService.constructEventFromPayload(signature, req.rawBody);
    } catch (err) {
      throw new import_common102.BadRequestException(`Webhook Error: ${err.message}`);
    }
    if (event.type === "payment_intent.succeeded") {
      const paymentIntent = event.data.object;
      const reservationId = paymentIntent.metadata.reservationId;
      const amountCents = paymentIntent.amount;
      if (reservationId) {
        const toNumber = (v) => v === void 0 || v === null || Number.isNaN(Number(v)) ? 0 : Number(v);
        const lineItems = [
          { label: "Reservation charge", amountCents: toNumber(paymentIntent.metadata?.baseAmountCents ?? amountCents) }
        ];
        const platformFee = toNumber(paymentIntent.metadata?.platformPassThroughFeeCents ?? paymentIntent.metadata?.applicationFeeCents);
        const gatewayFee = toNumber(paymentIntent.metadata?.gatewayPassThroughFeeCents);
        if (platformFee > 0) lineItems.push({ label: "Platform fee", amountCents: platformFee });
        if (gatewayFee > 0) lineItems.push({ label: "Gateway fee", amountCents: gatewayFee });
        const taxCents = toNumber(paymentIntent.metadata?.taxCents);
        await this.reservations.recordPayment(reservationId, amountCents, {
          transactionId: paymentIntent.id,
          paymentMethod: paymentIntent.payment_method_types?.[0] || "card",
          source: paymentIntent.metadata.source || "online",
          stripePaymentIntentId: paymentIntent.id,
          stripeChargeId: paymentIntent.latest_charge,
          stripeBalanceTransactionId: paymentIntent.charges?.data?.[0]?.balance_transaction,
          applicationFeeCents: paymentIntent.application_fee_amount ?? void 0,
          methodType: paymentIntent.payment_method_types?.[0],
          capturedAt: paymentIntent.status === "succeeded" ? new Date(paymentIntent.created * 1e3) : void 0,
          lineItems,
          taxCents: taxCents || void 0,
          feeCents: platformFee + gatewayFee > 0 ? platformFee + gatewayFee : void 0,
          totalCents: amountCents,
          receiptKind: "payment"
        });
      }
    }
    if (event.type === "payment_intent.payment_failed") {
      const pi = event.data.object;
      const pmType = pi.payment_method_types?.[0];
      if (pmType === "us_bank_account") {
        console.warn(`[ACH] Payment failed for PI ${pi.id}: ${pi.last_payment_error?.message ?? "unknown"}`);
        await this.handleAchReturn(pi);
      }
    }
    if (event.type === "account.updated") {
      const acct = event.data.object;
      const acctId = acct.id;
      try {
        const capabilities = acct.capabilities;
        await this.prisma.campground.updateMany({
          where: { stripeAccountId: acctId },
          data: {
            stripeCapabilities: capabilities,
            stripeCapabilitiesFetchedAt: /* @__PURE__ */ new Date()
          }
        });
        await this.recon.sendAlert(`Stripe capabilities updated for ${acctId}: ${JSON.stringify(capabilities)}`);
      } catch (err) {
        console.warn(`Failed to update capabilities for account ${acctId}: ${err instanceof Error ? err.message : err}`);
      }
    }
    if (event.type === "payout.paid" || event.type === "payout.failed" || event.type === "payout.updated") {
      const payout = event.data.object;
      await this.recon.reconcilePayout(payout);
    }
    if (event.type === "charge.dispute.created" || event.type === "charge.dispute.updated" || event.type === "charge.dispute.closed") {
      const dispute = event.data.object;
      await this.recon.upsertDispute(dispute);
    }
    if (event.type === "charge.refunded") {
      const charge = event.data.object;
      const paymentIntentId = charge.payment_intent;
      if (paymentIntentId) {
        try {
          const intent = await this.stripeService.retrievePaymentIntent(paymentIntentId);
          const reservationId = intent.metadata?.reservationId;
          if (reservationId) {
            const receiptLines = this.buildReceiptLinesFromIntent(intent);
            await this.reservations.recordRefund(reservationId, charge.amount_refunded, charge.id, {
              lineItems: receiptLines.lineItems,
              taxCents: receiptLines.taxCents,
              feeCents: receiptLines.feeCents,
              totalCents: charge.amount_refunded,
              paymentMethod: intent.payment_method_types?.[0] || "card",
              source: intent.metadata?.source || "online",
              tenders: [
                { method: intent.payment_method_types?.[0] || "card", amountCents: charge.amount_refunded, note: "webhook_refund" }
              ]
            });
          }
        } catch {
          console.error("Failed to update reservation after refund webhook");
        }
      }
    }
    return { received: true };
  }
  async listPayouts(campgroundId, status, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const payouts = await this.prisma.payout.findMany({
      where: {
        campgroundId,
        status: status ? status : void 0
      },
      orderBy: { createdAt: "desc" },
      include: {
        lines: true
      }
    });
    return payouts;
  }
  async getPayout(campgroundId, payoutId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const payout = await this.prisma.payout.findFirst({
      where: { id: payoutId, campgroundId },
      include: { lines: true }
    });
    if (!payout) throw new import_common102.NotFoundException("Payout not found");
    return payout;
  }
  async getPayoutRecon(campgroundId, payoutId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    try {
      return await this.recon.computeReconSummary(payoutId, campgroundId);
    } catch (err) {
      throw new import_common102.NotFoundException(err.message);
    }
  }
  async exportPayoutCsv(campgroundId, payoutId, res, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const payout = await this.prisma.payout.findFirst({
      where: { id: payoutId, campgroundId },
      include: { lines: true }
    });
    if (!payout) throw new import_common102.NotFoundException("Payout not found");
    const headers = ["type", "amount_cents", "currency", "description", "reservation_id", "payment_intent_id", "charge_id", "balance_transaction_id", "created_at"];
    const rows = (payout.lines || []).map((l) => [
      l.type,
      l.amountCents,
      l.currency,
      l.description ?? "",
      l.reservationId ?? "",
      l.paymentIntentId ?? "",
      l.chargeId ?? "",
      l.balanceTransactionId ?? "",
      l.createdAt ?? ""
    ]);
    const csv = [headers.join(","), ...rows.map((r) => r.map((v) => `"${String(v).replace(/"/g, '""')}"`).join(","))].join("\n");
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename="payout-${payout.stripePayoutId}.csv"`);
    return res.send(csv);
  }
  async exportPayoutLedgerCsv(campgroundId, payoutId, res, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const payout = await this.prisma.payout.findFirst({
      where: { id: payoutId, campgroundId },
      include: { lines: true }
    });
    if (!payout) throw new import_common102.NotFoundException("Payout not found");
    const reservationIds = Array.from(new Set((payout.lines || []).map((l) => l.reservationId).filter(Boolean)));
    const ledgerEntries = reservationIds.length ? await this.prisma.ledgerEntry.findMany({ where: { reservationId: { in: reservationIds } } }) : [];
    const headers = ["id", "reservation_id", "gl_code", "account", "description", "amount_cents", "direction", "occurred_at"];
    const rows = ledgerEntries.map((e) => [
      e.id,
      e.reservationId ?? "",
      e.glCode ?? "",
      e.account ?? "",
      e.description ?? "",
      e.amountCents,
      e.direction,
      e.occurredAt?.toISOString?.() ?? ""
    ]);
    const csv = [headers.join(","), ...rows.map((r) => r.map((v) => `"${String(v).replace(/"/g, '""')}"`).join(","))].join("\n");
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename="payout-ledger-${payout.stripePayoutId}.csv"`);
    return res.send(csv);
  }
  async listDisputes(campgroundId, status, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const disputes = await this.prisma.dispute.findMany({
      where: {
        campgroundId,
        status: status ? status : void 0
      },
      orderBy: { createdAt: "desc" }
    });
    return disputes;
  }
  async getDispute(campgroundId, disputeId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const dispute = await this.prisma.dispute.findFirst({
      where: { id: disputeId, campgroundId }
    });
    if (!dispute) throw new import_common102.NotFoundException("Dispute not found");
    return dispute;
  }
  async exportDisputesCsv(campgroundId, status, res, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    const disputes = await this.prisma.dispute.findMany({
      where: { campgroundId, status: status ? status : void 0 }
    });
    const headers = ["stripe_dispute_id", "status", "amount_cents", "currency", "reason", "reservation_id", "charge_id", "payment_intent_id", "evidence_due_by"];
    const rows = disputes.map((d) => [
      d.stripeDisputeId,
      d.status,
      d.amountCents,
      d.currency,
      d.reason ?? "",
      d.reservationId ?? "",
      d.stripeChargeId ?? "",
      d.stripePaymentIntentId ?? "",
      d.evidenceDueBy ? d.evidenceDueBy.toISOString() : ""
    ]);
    const csv = [headers.join(","), ...rows.map((r) => r.map((v) => `"${String(v).replace(/"/g, '""')}"`).join(","))].join("\n");
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename="disputes-${campgroundId}.csv"`);
    return res.send(csv);
  }
  async disputeTemplates(campgroundId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    return [
      { id: "receipt", label: "Receipt / proof of payment" },
      { id: "terms", label: "Signed terms, policies, cancellation rules" },
      { id: "stay-proof", label: "Proof of stay/use (check-in logs, gate, photos)" },
      { id: "comms", label: "Message history with guest" },
      { id: "id", label: "ID/vehicle verification if collected" }
    ];
  }
  // ACH return handling: create refund ledger entry and record refund
  async handleAchReturn(paymentIntent) {
    const reservationId = paymentIntent.metadata?.reservationId;
    const amount = paymentIntent.amount_received ?? paymentIntent.amount ?? 0;
    if (!reservationId || amount <= 0) return;
    try {
      await this.reservations.recordRefund(reservationId, amount, `ACH return ${paymentIntent.last_payment_error?.code ?? ""}`);
      await this.prisma.ledgerEntry.create({
        data: {
          campgroundId: paymentIntent.metadata?.campgroundId ?? "",
          reservationId,
          glCode: "CHARGEBACK",
          account: "Chargebacks",
          description: `ACH return ${paymentIntent.id}`,
          amountCents: amount,
          direction: "debit",
          occurredAt: /* @__PURE__ */ new Date()
        }
      });
      await this.prisma.ledgerEntry.create({
        data: {
          campgroundId: paymentIntent.metadata?.campgroundId ?? "",
          reservationId,
          glCode: "CASH",
          account: "Cash",
          description: `ACH return ${paymentIntent.id} (offset)`,
          amountCents: amount,
          direction: "credit",
          occurredAt: /* @__PURE__ */ new Date()
        }
      });
    } catch (err) {
      console.warn(`[ACH] Failed to record ACH return for PI ${paymentIntent.id}: ${err instanceof Error ? err.message : err}`);
      await this.recon.sendAlert(`[ACH] Failed to record ACH return for PI ${paymentIntent.id}: ${err instanceof Error ? err.message : err}`);
    }
  }
};
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("payments/intents"),
  __decorateParam(0, (0, import_common102.Body)()),
  __decorateParam(1, (0, import_common102.Req)()),
  __decorateParam(2, (0, import_common102.Headers)("idempotency-key"))
], PaymentsController.prototype, "createIntent", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("payments/setup-intents"),
  __decorateParam(0, (0, import_common102.Body)()),
  __decorateParam(1, (0, import_common102.Req)())
], PaymentsController.prototype, "createSetupIntent", 1);
__decorateClass([
  (0, import_common102.Post)("public/payments/setup-intents"),
  __decorateParam(0, (0, import_common102.Body)())
], PaymentsController.prototype, "createPublicSetupIntent", 1);
__decorateClass([
  (0, import_common102.Post)("public/payments/intents"),
  __decorateParam(0, (0, import_common102.Body)()),
  __decorateParam(1, (0, import_common102.Headers)("idempotency-key"))
], PaymentsController.prototype, "createPublicIntent", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("campgrounds/:campgroundId/payments/connect"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Req)())
], PaymentsController.prototype, "connectCampground", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("campgrounds/:campgroundId/payments/settings"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Body)()),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "updatePaymentSettings", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("campgrounds/:campgroundId/payments/capabilities/refresh"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Req)())
], PaymentsController.prototype, "refreshCapabilities", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("payments/intents/:id"),
  __decorateParam(0, (0, import_common102.Param)("id")),
  __decorateParam(1, (0, import_common102.Req)())
], PaymentsController.prototype, "getPaymentIntent", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("payments/intents/:id/capture"),
  __decorateParam(0, (0, import_common102.Param)("id")),
  __decorateParam(1, (0, import_common102.Body)()),
  __decorateParam(2, (0, import_common102.Req)()),
  __decorateParam(3, (0, import_common102.Headers)("idempotency-key"))
], PaymentsController.prototype, "capturePaymentIntent", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Post)("payments/intents/:id/refund"),
  __decorateParam(0, (0, import_common102.Param)("id")),
  __decorateParam(1, (0, import_common102.Body)()),
  __decorateParam(2, (0, import_common102.Req)()),
  __decorateParam(3, (0, import_common102.Headers)("idempotency-key"))
], PaymentsController.prototype, "refundPaymentIntent", 1);
__decorateClass([
  (0, import_common102.Post)("payments/webhook"),
  __decorateParam(0, (0, import_common102.Req)()),
  __decorateParam(1, (0, import_common102.Headers)("stripe-signature"))
], PaymentsController.prototype, "handleWebhook", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/payouts"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Query)("status")),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "listPayouts", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/payouts/:payoutId"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Param)("payoutId")),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "getPayout", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/payouts/:payoutId/recon"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Param)("payoutId")),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "getPayoutRecon", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/payouts/:payoutId/export"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Param)("payoutId")),
  __decorateParam(2, (0, import_common102.Res)()),
  __decorateParam(3, (0, import_common102.Req)())
], PaymentsController.prototype, "exportPayoutCsv", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/payouts/:payoutId/ledger-export"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Param)("payoutId")),
  __decorateParam(2, (0, import_common102.Res)()),
  __decorateParam(3, (0, import_common102.Req)())
], PaymentsController.prototype, "exportPayoutLedgerCsv", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/disputes"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Query)("status")),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "listDisputes", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/disputes/:disputeId"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Param)("disputeId")),
  __decorateParam(2, (0, import_common102.Req)())
], PaymentsController.prototype, "getDispute", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/disputes/export"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Query)("status")),
  __decorateParam(2, (0, import_common102.Res)()),
  __decorateParam(3, (0, import_common102.Req)())
], PaymentsController.prototype, "exportDisputesCsv", 1);
__decorateClass([
  (0, import_common102.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client18.UserRole.owner, import_client18.UserRole.manager, import_client18.UserRole.finance),
  (0, import_common102.Get)("campgrounds/:campgroundId/disputes/templates"),
  __decorateParam(0, (0, import_common102.Param)("campgroundId")),
  __decorateParam(1, (0, import_common102.Req)())
], PaymentsController.prototype, "disputeTemplates", 1);
PaymentsController = __decorateClass([
  (0, import_common102.Controller)()
], PaymentsController);

// src/payments/stripe.service.ts
var import_common103 = require("@nestjs/common");
var import_stripe = __toESM(require("stripe"));
var StripeService = class {
  constructor() {
    this.apiVersion = "2025-11-17.clover";
    const secretKey = process.env.STRIPE_SECRET_KEY;
    this.configured = !!secretKey && !secretKey.includes("placeholder");
    if (!this.configured) {
      console.warn("STRIPE_SECRET_KEY is not set. Stripe calls will be stubbed.");
    }
    this.stripe = new import_stripe.default(secretKey || "sk_test_placeholder", {
      apiVersion: this.apiVersion
    });
  }
  isConfigured() {
    return this.configured;
  }
  assertConfigured(action) {
    if (!this.configured) {
      throw new Error(`Stripe is not configured; cannot ${action}. Set STRIPE_SECRET_KEY to enable payments.`);
    }
  }
  async createPaymentIntent(amountCents, currency, metadata, stripeAccountId, applicationFeeCents, captureMethod = "automatic", paymentMethodTypes, idempotencyKey, threeDsPolicy = "automatic") {
    this.assertConfigured("create payment intents");
    const requestOptions = {};
    if (idempotencyKey) {
      requestOptions.idempotencyKey = idempotencyKey;
    }
    return this.stripe.paymentIntents.create({
      amount: amountCents,
      currency,
      metadata,
      capture_method: captureMethod,
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: "always"
      },
      payment_method_options: {
        card: {
          request_three_d_secure: threeDsPolicy
        }
      },
      payment_method_types: paymentMethodTypes,
      application_fee_amount: applicationFeeCents,
      transfer_data: {
        destination: stripeAccountId
      }
    }, requestOptions);
  }
  async listBalanceTransactionsForPayout(payoutId, stripeAccountId) {
    this.assertConfigured("list balance transactions");
    return this.stripe.balanceTransactions.list(
      { payout: payoutId, limit: 100 },
      { stripeAccount: stripeAccountId }
    );
  }
  async listPayouts(stripeAccountId, sinceSeconds = 7 * 24 * 3600) {
    this.assertConfigured("list payouts");
    const now = Math.floor(Date.now() / 1e3);
    return this.stripe.payouts.list(
      {
        arrival_date: { gte: now - sinceSeconds },
        limit: 100
      },
      { stripeAccount: stripeAccountId }
    );
  }
  async createSetupIntent(stripeAccountId, metadata, paymentMethodTypes) {
    this.assertConfigured("create setup intents");
    return this.stripe.setupIntents.create(
      {
        usage: "off_session",
        payment_method_types: paymentMethodTypes,
        metadata
      },
      { stripeAccount: stripeAccountId }
    );
  }
  async retrieveAccountCapabilities(stripeAccountId) {
    if (!this.configured) {
      return void 0;
    }
    const mock = process.env.STRIPE_CAPABILITIES_MOCK;
    if (mock) {
      try {
        return JSON.parse(mock);
      } catch {
      }
    }
    const acct = await this.stripe.accounts.retrieve(stripeAccountId);
    return acct.capabilities;
  }
  constructEventFromPayload(signature, payload) {
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    if (!webhookSecret) {
      throw new Error("STRIPE_WEBHOOK_SECRET is not set");
    }
    return this.stripe.webhooks.constructEvent(payload, signature, webhookSecret);
  }
  /**
   * Retrieve the current status and details of a payment intent
   */
  async retrievePaymentIntent(paymentIntentId) {
    this.assertConfigured("retrieve payment intents");
    return this.stripe.paymentIntents.retrieve(paymentIntentId);
  }
  /**
   * Capture an authorized payment intent (used for deposit/hold flows)
   * @param paymentIntentId - The ID of the payment intent to capture
   * @param amountCents - Optional amount to capture (for partial captures)
   * @param idempotencyKey - Optional idempotency key for safe retries
   */
  async capturePaymentIntent(paymentIntentId, amountCents, idempotencyKey) {
    this.assertConfigured("capture payment intents");
    const captureParams = {};
    if (amountCents !== void 0) {
      captureParams.amount_to_capture = amountCents;
    }
    const requestOptions = {};
    if (idempotencyKey) {
      requestOptions.idempotencyKey = idempotencyKey;
    }
    return this.stripe.paymentIntents.capture(paymentIntentId, captureParams, requestOptions);
  }
  /**
   * Create a refund for a payment intent
   * @param paymentIntentId - The payment intent to refund
   * @param amountCents - Optional amount to refund (for partial refunds)
   * @param reason - Optional reason for the refund
   * @param idempotencyKey - Optional idempotency key for safe retries
   */
  async createRefund(paymentIntentId, amountCents, reason, idempotencyKey) {
    this.assertConfigured("create refunds");
    const refundParams = {
      payment_intent: paymentIntentId
    };
    if (amountCents !== void 0) {
      refundParams.amount = amountCents;
    }
    if (reason) {
      refundParams.reason = reason;
    }
    const requestOptions = {};
    if (idempotencyKey) {
      requestOptions.idempotencyKey = idempotencyKey;
    }
    return this.stripe.refunds.create(refundParams, requestOptions);
  }
  /**
   * Create a payment intent with authorization hold (capture_method: manual)
   * Used for deposit flows where payment is authorized but not captured immediately
   */
  // Legacy helper kept for backward compatibility (not used in connect flow)
  async createPaymentIntentWithHold(amountCents, currency, metadata) {
    this.assertConfigured("create payment intents with hold");
    return this.stripe.paymentIntents.create({
      amount: amountCents,
      currency,
      metadata,
      capture_method: "manual",
      automatic_payment_methods: {
        enabled: true
      }
    });
  }
  async createExpressAccount(email, metadata) {
    this.assertConfigured("create accounts");
    return this.stripe.accounts.create({
      type: "express",
      email,
      metadata,
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true }
      }
    });
  }
  async createAccountOnboardingLink(accountId, returnUrl, refreshUrl) {
    this.assertConfigured("create account onboarding links");
    return this.stripe.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_onboarding"
    });
  }
};
StripeService = __decorateClass([
  (0, import_common103.Injectable)()
], StripeService);

// src/payments/reconciliation.service.ts
var import_common104 = require("@nestjs/common");
var import_client19 = require("@prisma/client");
var import_node_fetch3 = __toESM(require("node-fetch"));
var PaymentsReconciliationService = class {
  constructor(prisma, stripeService, ledger) {
    this.prisma = prisma;
    this.stripeService = stripeService;
    this.ledger = ledger;
    this.logger = new import_common104.Logger(PaymentsReconciliationService.name);
  }
  async sendAlert(message) {
    const webhook = process.env.ALERT_WEBHOOK_URL;
    if (!webhook) {
      this.logger.warn(`Alert (no webhook configured): ${message}`);
      return;
    }
    try {
      await (0, import_node_fetch3.default)(webhook, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: message })
      });
    } catch (err) {
      this.logger.warn(`Failed to send alert: ${err instanceof Error ? err.message : err}`);
    }
  }
  async lookupCampgroundIdByStripeAccount(accountId) {
    if (!accountId) return "";
    const cg = await this.prisma.campground.findFirst({
      where: { stripeAccountId: accountId },
      select: { id: true }
    });
    return cg?.id ?? "";
  }
  async postDoubleEntry(opts) {
    const occurredAt = opts.occurredAt ?? /* @__PURE__ */ new Date();
    const debitId = await this.ledger.ensureAccount(opts.campgroundId, opts.glDebit.code, opts.glDebit.name, opts.glDebit.type);
    const creditId = await this.ledger.ensureAccount(opts.campgroundId, opts.glCredit.code, opts.glCredit.name, opts.glCredit.type);
    return this.ledger.postEntries({
      campgroundId: opts.campgroundId,
      reservationId: opts.reservationId ?? null,
      description: opts.description,
      occurredAt,
      sourceType: "payout_recon",
      sourceTxId: opts.sourceTxId ?? null,
      dedupeKey: `payout_recon:${opts.sourceTxId ?? ""}:${opts.description}:${opts.amountCents}`,
      lines: [
        {
          glAccountId: debitId,
          side: "debit",
          amountCents: opts.amountCents,
          memo: opts.description,
          glCode: opts.glDebit.code,
          accountName: opts.glDebit.name,
          reconciliationKey: opts.reconciliationKey ?? opts.sourceTxId ?? void 0
        },
        {
          glAccountId: creditId,
          side: "credit",
          amountCents: opts.amountCents,
          memo: `${opts.description} (offset)`,
          glCode: opts.glCredit.code,
          accountName: opts.glCredit.name,
          reconciliationKey: opts.reconciliationKey ?? opts.sourceTxId ?? void 0
        }
      ]
    });
  }
  async createPayoutLine(opts) {
    return this.prisma.payoutLine.create({
      data: {
        payoutId: opts.payoutId,
        type: opts.type,
        amountCents: opts.amount,
        currency: opts.currency || "usd",
        description: opts.description,
        reservationId: opts.reservationId || null,
        paymentIntentId: opts.paymentIntentId || null,
        chargeId: opts.chargeId || null,
        balanceTransactionId: opts.balanceTransactionId || null
      }
    });
  }
  mapReconLineType(tx) {
    const txType = tx.type;
    if (txType === "payout") return "payout";
    if (txType === "application_fee" || tx.reporting_category === "fee") return "fee";
    if (tx.reporting_category === "charge_dispute" || txType === "dispute") return "chargeback";
    if (txType === "reserve_transaction") return "reserve";
    if (txType === "adjustment") return "adjustment";
    return "other";
  }
  async createPayoutReconLine(opts) {
    return this.prisma.payoutReconLine.create({
      data: {
        payoutReconId: opts.payoutReconId,
        type: opts.type,
        status: "matched",
        sourceTxId: opts.sourceTxId ?? null,
        sourceTs: opts.sourceTs ?? null,
        amountCents: opts.amountCents,
        currency: opts.currency ?? "usd",
        glEntryId: opts.glEntryId ?? null,
        notes: opts.notes ?? null
      }
    });
  }
  async upsertPayoutReconEnvelope(payoutRecord, payout) {
    const payoutDate = payout.arrival_date ? new Date(payout.arrival_date * 1e3) : null;
    const expected = payout.amount ?? 0;
    const actual = (payout.amount ?? 0) - (payout.fee ?? 0);
    return this.prisma.payoutRecon.upsert({
      where: { id: payoutRecord.id },
      update: {
        provider: "stripe",
        status: "matched",
        expectedAmountCents: expected,
        actualAmountCents: actual,
        varianceCents: actual - expected,
        currency: payout.currency || "usd",
        payoutDate
      },
      create: {
        id: payoutRecord.id,
        campgroundId: payoutRecord.campgroundId,
        provider: "stripe",
        status: "matched",
        expectedAmountCents: expected,
        actualAmountCents: actual,
        varianceCents: actual - expected,
        currency: payout.currency || "usd",
        payoutDate
      }
    });
  }
  async upsertDispute(dispute) {
    const reservationId = dispute.metadata?.reservationId ?? null;
    const campgroundId = await this.lookupCampgroundIdByStripeAccount(dispute.account);
    return this.prisma.dispute.upsert({
      where: { stripeDisputeId: dispute.id },
      update: {
        amountCents: dispute.amount,
        status: dispute.status ?? "needs_response",
        reason: dispute.reason ?? null,
        evidenceDueBy: dispute.evidence_details?.due_by ? new Date(dispute.evidence_details.due_by * 1e3) : null,
        notes: dispute.evidence?.product_description ?? null
      },
      create: {
        stripeDisputeId: dispute.id,
        stripeChargeId: dispute.charge ?? null,
        stripePaymentIntentId: dispute.payment_intent ?? null,
        campgroundId,
        reservationId,
        payoutId: null,
        amountCents: dispute.amount,
        currency: dispute.currency || "usd",
        status: dispute.status ?? "needs_response",
        reason: dispute.reason ?? null,
        evidenceDueBy: dispute.evidence_details?.due_by ? new Date(dispute.evidence_details.due_by * 1e3) : null,
        notes: dispute.evidence?.product_description ?? null
      }
    });
  }
  async upsertPayoutFromStripe(payout) {
    const payoutRecord = await this.prisma.payout.upsert({
      where: { stripePayoutId: payout.id },
      update: {
        amountCents: payout.amount,
        feeCents: payout.fee,
        status: payout.status ?? "pending",
        arrivalDate: payout.arrival_date ? new Date(payout.arrival_date * 1e3) : null,
        paidAt: payout.status === "paid" && payout.arrival_date ? new Date(payout.arrival_date * 1e3) : null,
        statementDescriptor: payout.statement_descriptor ?? null
      },
      create: {
        stripePayoutId: payout.id,
        stripeAccountId: payout.destination || payout.stripe_account || "",
        campgroundId: await this.lookupCampgroundIdByStripeAccount(payout.destination || payout.stripe_account),
        amountCents: payout.amount,
        feeCents: payout.fee,
        currency: payout.currency || "usd",
        status: payout.status ?? "pending",
        arrivalDate: payout.arrival_date ? new Date(payout.arrival_date * 1e3) : null,
        paidAt: payout.status === "paid" && payout.arrival_date ? new Date(payout.arrival_date * 1e3) : null,
        statementDescriptor: payout.statement_descriptor ?? null
      }
    });
    return payoutRecord;
  }
  async ingestPayoutTransactions(payout, payoutRecord) {
    const stripeAccountId = payout.destination || payout.stripe_account;
    if (!stripeAccountId) return;
    const recon = await this.upsertPayoutReconEnvelope(payoutRecord, payout);
    const txns = await this.stripeService.listBalanceTransactionsForPayout(payout.id, stripeAccountId);
    for (const tx of txns.data) {
      const chargeId = tx.source;
      const payment = chargeId ? await this.prisma.payment.findFirst({
        where: { stripeChargeId: chargeId },
        select: { reservationId: true, campgroundId: true }
      }) : null;
      const reservationId = payment?.reservationId ?? null;
      const campgroundId = payment?.campgroundId ?? payoutRecord.campgroundId;
      await this.createPayoutLine({
        payoutId: payoutRecord.id,
        type: tx.type,
        amount: tx.amount,
        currency: tx.currency,
        description: `BTX ${tx.id} (${tx.type})`,
        reservationId,
        paymentIntentId: tx.payment_intent ?? null,
        chargeId,
        balanceTransactionId: tx.id
      });
      const createdAt = new Date(tx.created * 1e3);
      const amountAbs = Math.abs(tx.amount);
      let glEntryId;
      if (tx.fee && tx.fee > 0) {
        const feeLedger = await this.postDoubleEntry({
          campgroundId,
          reservationId,
          glDebit: { code: "STRIPE_FEES", name: "Stripe Fees", type: import_client19.GlAccountType.expense },
          glCredit: { code: "CASH", name: "Cash", type: import_client19.GlAccountType.asset },
          amountCents: tx.fee,
          description: `Stripe fee BTX ${tx.id}`,
          sourceTxId: tx.id,
          occurredAt: createdAt,
          reconciliationKey: tx.id
        });
        glEntryId = feeLedger?.entryIds?.[0] ?? glEntryId;
      }
      const txType = tx.type;
      if (tx.reporting_category === "charge_dispute" || txType === "dispute") {
        const cbLedger = await this.postDoubleEntry({
          campgroundId,
          reservationId,
          glDebit: { code: "CHARGEBACK", name: "Chargebacks", type: import_client19.GlAccountType.expense },
          glCredit: { code: "CASH", name: "Cash", type: import_client19.GlAccountType.asset },
          amountCents: amountAbs,
          description: `Chargeback BTX ${tx.id}`,
          sourceTxId: tx.id,
          occurredAt: createdAt,
          reconciliationKey: tx.id
        });
        glEntryId = glEntryId ?? cbLedger?.entryIds?.[0];
      }
      if (txType === "application_fee" || tx.reporting_category === "fee") {
        const platformLedger = await this.postDoubleEntry({
          campgroundId,
          reservationId,
          glDebit: { code: "PLATFORM_FEE", name: "Platform Fees", type: import_client19.GlAccountType.expense },
          glCredit: { code: "CASH", name: "Cash", type: import_client19.GlAccountType.asset },
          amountCents: amountAbs,
          description: `Platform fee BTX ${tx.id}`,
          sourceTxId: tx.id,
          occurredAt: createdAt,
          reconciliationKey: tx.id
        });
        glEntryId = glEntryId ?? platformLedger?.entryIds?.[0];
      }
      await this.createPayoutReconLine({
        payoutReconId: recon.id,
        type: this.mapReconLineType(tx),
        amountCents: tx.amount,
        currency: tx.currency,
        sourceTxId: tx.id,
        sourceTs: createdAt,
        glEntryId: glEntryId ?? null,
        notes: `BTX ${tx.id} (${tx.type})`
      });
    }
  }
  async reconcilePayout(payout) {
    const payoutRecord = await this.upsertPayoutFromStripe(payout);
    await this.ingestPayoutTransactions(payout, payoutRecord);
    await this.postNetCashMovement(payoutRecord);
    return this.computeReconSummary(payoutRecord.id, payoutRecord.campgroundId);
  }
  async computeReconSummary(payoutId, campgroundId) {
    const payout = await this.prisma.payout.findFirst({
      where: { id: payoutId, campgroundId },
      include: { lines: true }
    });
    if (!payout) throw new Error("Payout not found");
    const lineSum = (payout.lines || []).reduce((acc, l) => acc + l.amountCents, 0);
    const reservationIds = Array.from(new Set((payout.lines || []).map((l) => l.reservationId).filter(Boolean)));
    let ledgerNet = 0;
    if (reservationIds.length > 0) {
      const ledgerEntries = await this.prisma.ledgerEntry.findMany({
        where: { reservationId: { in: reservationIds } }
      });
      ledgerNet = ledgerEntries.reduce((acc, e) => acc + (e.direction === "credit" ? e.amountCents : -e.amountCents), 0);
    }
    const payoutNet = (payout.amountCents ?? 0) - (payout.feeCents ?? 0);
    const driftVsLines = payoutNet - lineSum;
    const driftVsLedger = payoutNet - ledgerNet;
    const driftThreshold = Number(process.env.PAYOUT_DRIFT_THRESHOLD_CENTS ?? 100);
    const status = Math.abs(driftVsLedger) === 0 && Math.abs(driftVsLines) === 0 ? "matched" : Math.abs(driftVsLedger) > driftThreshold ? "drift" : "pending";
    await this.prisma.payout.update({
      where: { id: payoutId },
      data: {
        reconStatus: status,
        reconDriftCents: driftVsLedger,
        reconLedgerNetCents: ledgerNet,
        reconLineSumCents: lineSum,
        reconAt: /* @__PURE__ */ new Date()
      }
    });
    if (Math.abs(driftVsLedger) > driftThreshold) {
      await this.sendAlert(
        `Payout drift detected: payout ${payout.stripePayoutId} camp ${campgroundId} drift_vs_ledger=${driftVsLedger} cents`
      );
    }
    return {
      payoutId,
      campgroundId,
      payoutAmountCents: payout.amountCents,
      payoutFeeCents: payout.feeCents ?? 0,
      payoutNetCents: payoutNet,
      lineSumCents: lineSum,
      ledgerNetCents: ledgerNet,
      driftVsLinesCents: driftVsLines,
      driftVsLedgerCents: driftVsLedger
    };
  }
  async postNetCashMovement(payoutRecord) {
    const net = (payoutRecord?.amountCents ?? 0) - (payoutRecord?.feeCents ?? 0);
    if (!payoutRecord?.campgroundId || net === 0) return;
    const externalRef = payoutRecord.stripePayoutId ?? payoutRecord.id;
    const occurredAt = payoutRecord.paidAt ?? payoutRecord.arrivalDate ?? /* @__PURE__ */ new Date();
    const existing = await this.prisma.ledgerEntry.findFirst({
      where: { externalRef, glCode: "BANK" },
      select: { id: true }
    });
    if (existing) return;
    await this.postDoubleEntry({
      campgroundId: payoutRecord.campgroundId,
      glDebit: { code: "BANK", name: "Operating Bank", type: import_client19.GlAccountType.asset },
      glCredit: { code: "CASH", name: "Cash", type: import_client19.GlAccountType.asset },
      amountCents: Math.abs(net),
      description: `Payout ${externalRef} transfer`,
      sourceTxId: externalRef,
      occurredAt,
      reconciliationKey: externalRef
    });
    await this.prisma.payout.update({
      where: { id: payoutRecord.id },
      data: { cashPostedAt: /* @__PURE__ */ new Date() }
    });
  }
  async reconcileRecentPayouts(stripeAccountId, sinceSeconds = 7 * 24 * 3600) {
    const payouts = await this.stripeService.listPayouts(stripeAccountId, sinceSeconds);
    const results = [];
    for (const p of payouts.data) {
      try {
        const summary = await this.reconcilePayout(p);
        if (Math.abs(summary.driftVsLedgerCents) > 0) {
          this.logger.warn(`Payout ${p.id} drift detected: ${summary.driftVsLedgerCents} cents`);
          await this.sendAlert(
            `Payout drift detected: payout ${p.id} drift_vs_ledger=${summary.driftVsLedgerCents} cents`
          );
        }
        results.push(summary);
      } catch (err) {
        this.logger.warn(`Failed recon for payout ${p.id}: ${err instanceof Error ? err.message : err}`);
      }
    }
    return results;
  }
};
PaymentsReconciliationService = __decorateClass([
  (0, import_common104.Injectable)()
], PaymentsReconciliationService);

// src/payments/payments.scheduler.ts
var import_common105 = require("@nestjs/common");
var import_schedule6 = require("@nestjs/schedule");
var PaymentsScheduler = class {
  // default 6h
  constructor(prisma, recon, queue, stripe) {
    this.prisma = prisma;
    this.recon = recon;
    this.queue = queue;
    this.stripe = stripe;
    this.logger = new import_common105.Logger(PaymentsScheduler.name);
    this.capabilitiesTtlMs = Number(process.env.STRIPE_CAPABILITIES_TTL_MS ?? 6 * 60 * 60 * 1e3);
  }
  // hourly
  async reconcilePayouts() {
    const accounts = await this.prisma.campground.findMany({
      where: { stripeAccountId: { not: null } },
      select: { stripeAccountId: true }
    });
    await Promise.all(
      accounts.map((cg) => {
        if (!cg.stripeAccountId) return Promise.resolve();
        return this.queue.enqueue(
          "payout-recon",
          () => this.recon.reconcileRecentPayouts(cg.stripeAccountId),
          { jobName: `recon-${cg.stripeAccountId}`, timeoutMs: 3e4, concurrency: 2 }
        ).catch((err) => {
          this.logger.warn(`Recon failed for account ${cg.stripeAccountId}: ${err instanceof Error ? err.message : err}`);
        });
      })
    );
  }
  // hourly, offset
  async alertDisputesDue() {
    const horizonHours = Number(process.env.DISPUTE_DUE_HOURS_ALERT ?? 48);
    const now = /* @__PURE__ */ new Date();
    const cutoff = new Date(now.getTime() + horizonHours * 60 * 60 * 1e3);
    const disputes = await this.prisma.dispute.findMany({
      where: {
        status: { notIn: ["won", "lost", "charge_refunded"] },
        evidenceDueBy: { lte: cutoff, gte: now }
      },
      select: { stripeDisputeId: true, campgroundId: true, evidenceDueBy: true }
    });
    for (const d of disputes) {
      await this.recon.sendAlert(
        `Dispute due soon: ${d.stripeDisputeId} camp ${d.campgroundId} due ${d.evidenceDueBy?.toISOString?.() ?? ""}`
      );
    }
  }
  // every 6 hours, staggered from payout recon
  async refreshStaleCapabilities() {
    if (!this.stripe.isConfigured()) {
      this.logger.log("Skipping capability refresh: Stripe keys not configured.");
      return;
    }
    const cutoff = new Date(Date.now() - this.capabilitiesTtlMs);
    const campgrounds = await this.prisma.campground.findMany({
      where: {
        stripeAccountId: { not: null },
        OR: [
          { stripeCapabilitiesFetchedAt: null },
          { stripeCapabilitiesFetchedAt: { lt: cutoff } }
        ]
      },
      select: { id: true, stripeAccountId: true }
    });
    for (const cg of campgrounds) {
      try {
        const capabilities = await this.stripe.retrieveAccountCapabilities(cg.stripeAccountId);
        if (!capabilities) continue;
        await this.prisma.campground.update({
          where: { id: cg.id },
          data: {
            stripeCapabilities: capabilities,
            stripeCapabilitiesFetchedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (err) {
        this.logger.warn(`Capability refresh failed for ${cg.id}: ${err?.message || err}`);
      }
    }
  }
};
__decorateClass([
  (0, import_schedule6.Cron)("0 * * * *")
], PaymentsScheduler.prototype, "reconcilePayouts", 1);
__decorateClass([
  (0, import_schedule6.Cron)("15 * * * *")
], PaymentsScheduler.prototype, "alertDisputesDue", 1);
__decorateClass([
  (0, import_schedule6.Cron)("40 */6 * * *")
], PaymentsScheduler.prototype, "refreshStaleCapabilities", 1);
PaymentsScheduler = __decorateClass([
  (0, import_common105.Injectable)()
], PaymentsScheduler);

// src/payments/gateway-config.service.ts
var import_common106 = require("@nestjs/common");

// src/payments/gateway-config.mapper.ts
var GatewayConfigMapper = {
  toView(record) {
    if (!record) return null;
    const percentBasisPoints = record.feePercentBasisPoints ?? record.feePreset?.percentBasisPoints ?? 0;
    const flatFeeCents = record.feeFlatCents ?? record.feePreset?.flatFeeCents ?? 0;
    return {
      id: record.id,
      campgroundId: record.campgroundId,
      gateway: record.gateway,
      mode: record.mode,
      feeMode: record.feeMode,
      feePercentBasisPoints: record.feePercentBasisPoints ?? null,
      feeFlatCents: record.feeFlatCents ?? null,
      feePresetId: record.feePresetId ?? null,
      feePresetLabel: record.feePreset?.label ?? null,
      effectiveFee: {
        percentBasisPoints,
        flatFeeCents
      },
      credentials: {
        publishableKeySecretId: record.publishableKeySecretId ?? null,
        secretKeySecretId: record.secretKeySecretId ?? null,
        merchantAccountIdSecretId: record.merchantAccountIdSecretId ?? null,
        webhookSecretId: record.webhookSecretId ?? null
      },
      hasProductionCredentials: Boolean(record.secretKeySecretId || record.merchantAccountIdSecretId),
      additionalConfig: record.additionalConfig ?? null
    };
  }
};

// src/payments/gateway-config.service.ts
var GatewayConfigService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
  }
  async getConfig(campgroundId) {
    const existing = await this.ensureConfig(campgroundId);
    return GatewayConfigMapper.toView(existing);
  }
  async upsertConfig(campgroundId, dto, actor) {
    const existing = await this.prisma.campgroundPaymentGatewayConfig.findUnique({
      where: { campgroundId },
      include: { feePreset: true }
    });
    const preset = await this.resolvePreset(dto.gateway, dto.mode, dto.feePresetId);
    this.ensureProdGuard(dto.mode, dto, existing);
    const nextData = {
      gateway: dto.gateway,
      mode: dto.mode,
      feeMode: dto.feeMode,
      feePercentBasisPoints: dto.feePercentBasisPoints ?? existing?.feePercentBasisPoints ?? null,
      feeFlatCents: dto.feeFlatCents ?? existing?.feeFlatCents ?? null,
      feePresetId: dto.feePresetId ?? existing?.feePresetId ?? preset?.id ?? null,
      publishableKeySecretId: dto.publishableKeySecretId ?? existing?.publishableKeySecretId ?? null,
      secretKeySecretId: dto.secretKeySecretId ?? existing?.secretKeySecretId ?? null,
      merchantAccountIdSecretId: dto.merchantAccountIdSecretId ?? existing?.merchantAccountIdSecretId ?? null,
      webhookSecretId: dto.webhookSecretId ?? existing?.webhookSecretId ?? null,
      additionalConfig: dto.additionalConfig ?? existing?.additionalConfig ?? null
    };
    if (existing && this.isSame(existing, nextData)) {
      return GatewayConfigMapper.toView(existing);
    }
    const saved = await this.prisma.campgroundPaymentGatewayConfig.upsert({
      where: { campgroundId },
      create: {
        campgroundId,
        ...nextData
      },
      update: {
        ...nextData
      },
      include: { feePreset: true }
    });
    await this.audit.record({
      campgroundId,
      actorId: actor?.userId ?? null,
      action: "payment_gateway_config.updated",
      entity: "payment_gateway_config",
      entityId: saved.id,
      before: GatewayConfigMapper.toView(existing) ?? void 0,
      after: GatewayConfigMapper.toView(saved) ?? void 0,
      ip: actor?.ip,
      userAgent: actor?.userAgent
    });
    return GatewayConfigMapper.toView(saved);
  }
  async ensureConfig(campgroundId) {
    const existing = await this.prisma.campgroundPaymentGatewayConfig.findUnique({
      where: { campgroundId },
      include: { feePreset: true }
    });
    if (existing) return existing;
    const preset = await this.resolvePreset("stripe", "test");
    return this.prisma.campgroundPaymentGatewayConfig.create({
      data: {
        campgroundId,
        gateway: "stripe",
        mode: "test",
        feeMode: "absorb",
        feePresetId: preset?.id ?? null
      },
      include: { feePreset: true }
    });
  }
  isSame(existing, candidate) {
    return existing.gateway === candidate.gateway && existing.mode === candidate.mode && existing.feeMode === candidate.feeMode && (existing.feePercentBasisPoints ?? null) === (candidate.feePercentBasisPoints ?? null) && (existing.feeFlatCents ?? null) === (candidate.feeFlatCents ?? null) && (existing.feePresetId ?? null) === (candidate.feePresetId ?? null) && (existing.publishableKeySecretId ?? null) === (candidate.publishableKeySecretId ?? null) && (existing.secretKeySecretId ?? null) === (candidate.secretKeySecretId ?? null) && (existing.merchantAccountIdSecretId ?? null) === (candidate.merchantAccountIdSecretId ?? null) && (existing.webhookSecretId ?? null) === (candidate.webhookSecretId ?? null) && JSON.stringify(existing.additionalConfig ?? null) === JSON.stringify(candidate.additionalConfig ?? null);
  }
  ensureProdGuard(mode, dto, existing) {
    if (mode !== "prod") return;
    const hasSecret = Boolean(
      dto.secretKeySecretId || dto.merchantAccountIdSecretId || existing?.secretKeySecretId || existing?.merchantAccountIdSecretId
    );
    if (!hasSecret) {
      throw new import_common106.BadRequestException("Production mode requires gateway credentials to be configured.");
    }
  }
  async resolvePreset(gateway, mode, presetId) {
    if (presetId) {
      const preset = await this.prisma.gatewayFeePreset.findUnique({ where: { id: presetId } });
      if (!preset) throw new import_common106.BadRequestException("feePresetId is invalid");
      if (preset.gateway !== gateway || preset.mode !== mode) {
        throw new import_common106.BadRequestException("feePresetId does not match gateway/mode");
      }
      return preset;
    }
    return this.prisma.gatewayFeePreset.findFirst({ where: { gateway, mode } });
  }
};
GatewayConfigService = __decorateClass([
  (0, import_common106.Injectable)()
], GatewayConfigService);

// src/payments/gateway-config.controller.ts
var import_common107 = require("@nestjs/common");
var import_client20 = require("@prisma/client");
var GatewayConfigController = class {
  constructor(gatewayConfig) {
    this.gatewayConfig = gatewayConfig;
  }
  ensureCampgroundMembership(user, campgroundId) {
    const memberships = user?.memberships?.map((m) => m.campgroundId) ?? [];
    if (!campgroundId || !memberships.includes(campgroundId)) {
      throw new import_common107.ForbiddenException("Forbidden by campground scope");
    }
  }
  async getGatewayConfig(campgroundId, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    return this.gatewayConfig.getConfig(campgroundId);
  }
  async upsertGatewayConfig(campgroundId, body, req) {
    this.ensureCampgroundMembership(req?.user, campgroundId);
    return this.gatewayConfig.upsertConfig(campgroundId, body, {
      userId: req?.user?.id ?? null,
      ip: req?.ip ?? null,
      userAgent: req?.headers?.["user-agent"] ?? null
    });
  }
};
__decorateClass([
  (0, import_common107.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "read" }),
  Roles(import_client20.UserRole.owner, import_client20.UserRole.manager, import_client20.UserRole.finance),
  (0, import_common107.Get)("campgrounds/:campgroundId/payment-gateway"),
  __decorateParam(0, (0, import_common107.Param)("campgroundId")),
  __decorateParam(1, (0, import_common107.Req)())
], GatewayConfigController.prototype, "getGatewayConfig", 1);
__decorateClass([
  (0, import_common107.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "payments", action: "write" }),
  Roles(import_client20.UserRole.owner, import_client20.UserRole.manager, import_client20.UserRole.finance),
  (0, import_common107.Put)("campgrounds/:campgroundId/payment-gateway"),
  __decorateParam(0, (0, import_common107.Param)("campgroundId")),
  __decorateParam(1, (0, import_common107.Body)()),
  __decorateParam(2, (0, import_common107.Req)())
], GatewayConfigController.prototype, "upsertGatewayConfig", 1);
GatewayConfigController = __decorateClass([
  (0, import_common107.Controller)()
], GatewayConfigController);

// src/payments/payments.module.ts
var PaymentsModule = class {
};
PaymentsModule = __decorateClass([
  (0, import_common108.Module)({
    imports: [ReservationsModule, PermissionsModule, AuditModule, LedgerModule],
    controllers: [PaymentsController, GatewayConfigController],
    providers: [StripeService, PrismaService, PaymentsReconciliationService, PaymentsScheduler, IdempotencyService, GatewayConfigService],
    exports: [StripeService, PaymentsReconciliationService, IdempotencyService, GatewayConfigService]
  })
], PaymentsModule);

// src/store/store.module.ts
var import_common112 = require("@nestjs/common");

// src/store/store.service.ts
var import_common109 = require("@nestjs/common");
var import_crypto12 = require("crypto");
var StoreService = class {
  constructor(prisma, emailService) {
    this.prisma = prisma;
    this.emailService = emailService;
    // In-memory log for stubbed refunds/exchanges (no payment processor hooked yet)
    this.orderAdjustments = /* @__PURE__ */ new Map();
  }
  // ==================== CATEGORIES ====================
  listCategories(campgroundId) {
    return this.prisma.productCategory.findMany({
      where: { campgroundId },
      orderBy: { sortOrder: "asc" },
      include: {
        _count: { select: { products: true } }
      }
    });
  }
  async updateOrderStatus(id, status, userId) {
    const data = { status };
    const now = /* @__PURE__ */ new Date();
    if (status === "ready") data.readyAt = now;
    if (status === "delivered") data.deliveredAt = now;
    if (status === "completed") {
      data.completedAt = now;
      if (userId) data.completedById = userId;
    }
    return this.prisma.storeOrder.update({ where: { id }, data });
  }
  createCategory(data) {
    return this.prisma.productCategory.create({ data });
  }
  updateCategory(id, data) {
    return this.prisma.productCategory.update({ where: { id }, data });
  }
  deleteCategory(id) {
    return this.prisma.productCategory.delete({ where: { id } });
  }
  // ==================== PRODUCTS ====================
  listProducts(campgroundId, categoryId) {
    return this.prisma.product.findMany({
      where: {
        campgroundId,
        ...categoryId ? { categoryId } : {}
      },
      orderBy: [{ sortOrder: "asc" }, { name: "asc" }],
      include: {
        category: { select: { id: true, name: true } }
      }
    });
  }
  getProduct(id) {
    return this.prisma.product.findUnique({
      where: { id },
      include: { category: true }
    });
  }
  createProduct(data) {
    return this.prisma.product.create({ data });
  }
  updateProduct(id, data) {
    return this.prisma.product.update({ where: { id }, data });
  }
  deleteProduct(id) {
    return this.prisma.product.delete({ where: { id } });
  }
  async setStock(id, stockQty, channel) {
    const product = await this.prisma.product.findUnique({ where: { id } });
    if (!product) throw new Error("Product not found");
    const next = Math.max(0, stockQty);
    if (channel && product.channelInventoryMode === "split") {
      if (channel === "online" || channel === "portal") {
        return this.prisma.product.update({ where: { id }, data: { onlineStockQty: next } });
      }
      return this.prisma.product.update({ where: { id }, data: { posStockQty: next } });
    }
    return this.prisma.product.update({
      where: { id },
      data: { stockQty: next }
    });
  }
  async adjustStock(id, adjustment, channel) {
    const product = await this.prisma.product.findUnique({ where: { id } });
    if (!product) throw new Error("Product not found");
    if (channel && product.channelInventoryMode === "split") {
      if (channel === "online" || channel === "portal") {
        const newQty3 = Math.max(0, (product.onlineStockQty ?? 0) + adjustment);
        return this.prisma.product.update({ where: { id }, data: { onlineStockQty: newQty3 } });
      }
      const newQty2 = Math.max(0, (product.posStockQty ?? 0) + adjustment);
      return this.prisma.product.update({ where: { id }, data: { posStockQty: newQty2 } });
    }
    const newQty = Math.max(0, product.stockQty + adjustment);
    return this.prisma.product.update({
      where: { id },
      data: { stockQty: newQty }
    });
  }
  async getLowStockProducts(campgroundId) {
    const products = await this.prisma.product.findMany({
      where: {
        campgroundId,
        trackInventory: true,
        lowStockAlert: { not: null }
      },
      include: { category: true }
    });
    return products.filter((p) => p.stockQty <= (p.lowStockAlert || 0));
  }
  // ==================== ADD-ONS ====================
  listAddOns(campgroundId) {
    return this.prisma.addOnService.findMany({
      where: { campgroundId },
      orderBy: [{ sortOrder: "asc" }, { name: "asc" }]
    });
  }
  createAddOn(data) {
    return this.prisma.addOnService.create({
      data: {
        ...data,
        pricingType: data.pricingType || "flat"
      }
    });
  }
  updateAddOn(id, data) {
    return this.prisma.addOnService.update({
      where: { id },
      data: {
        ...data,
        ...data.pricingType ? { pricingType: data.pricingType } : {}
      }
    });
  }
  deleteAddOn(id) {
    return this.prisma.addOnService.delete({ where: { id } });
  }
  // ==================== ORDERS ====================
  async findReservationForGuest(reservationId, guestId) {
    return this.prisma.reservation.findFirst({
      where: { id: reservationId, guestId },
      select: { id: true, campgroundId: true, site: { select: { siteNumber: true } } }
    });
  }
  async listOrders(campgroundId, options) {
    const orders = await this.prisma.storeOrder.findMany({
      where: {
        campgroundId,
        ...options?.status ? { status: options.status } : {},
        ...options?.reservationId ? { reservationId: options.reservationId } : {}
      },
      orderBy: { createdAt: "desc" },
      include: {
        items: true,
        reservation: {
          select: {
            id: true,
            site: { select: { siteNumber: true } },
            guest: { select: { primaryFirstName: true, primaryLastName: true } }
          }
        },
        guest: {
          select: { primaryFirstName: true, primaryLastName: true }
        },
        completedBy: {
          select: { id: true, firstName: true, lastName: true, email: true }
        }
      }
    });
    return orders.map((order) => this.attachAdjustments(order));
  }
  async listUnseenOrders(campgroundId) {
    return this.prisma.storeOrder.findMany({
      where: {
        campgroundId,
        status: "pending",
        seenAt: null
      },
      select: { id: true, createdAt: true, reservationId: true, siteNumber: true }
    });
  }
  async markOrderSeen(id) {
    return this.prisma.storeOrder.update({
      where: { id },
      data: { seenAt: /* @__PURE__ */ new Date() }
    });
  }
  async getOrderSummary(campgroundId, opts) {
    const where = { campgroundId };
    if (opts?.start || opts?.end) {
      where.createdAt = {
        ...opts?.start ? { gte: opts.start } : {},
        ...opts?.end ? { lte: opts.end } : {}
      };
    }
    const [byChannel, byFulfillment, byStatus] = await Promise.all([
      this.prisma.storeOrder.groupBy({
        by: ["channel"],
        where,
        _count: { _all: true },
        _sum: { totalCents: true }
      }),
      this.prisma.storeOrder.groupBy({
        by: ["fulfillmentType"],
        where,
        _count: { _all: true },
        _sum: { totalCents: true }
      }),
      this.prisma.storeOrder.groupBy({
        by: ["status"],
        where,
        _count: { _all: true },
        _sum: { totalCents: true }
      })
    ]);
    const prepSamples = await this.prisma.storeOrder.findMany({
      where,
      select: { createdAt: true, readyAt: true, prepTimeMinutes: true, fulfillmentType: true }
    });
    let plannedSum = 0;
    let plannedCount = 0;
    let actualSum = 0;
    let actualCount = 0;
    const perFulfillment = {};
    for (const o of prepSamples) {
      if (typeof o.prepTimeMinutes === "number") {
        plannedSum += o.prepTimeMinutes;
        plannedCount += 1;
        const key = o.fulfillmentType || "unknown";
        perFulfillment[key] = perFulfillment[key] || { plannedSum: 0, plannedCount: 0, actualSum: 0, actualCount: 0 };
        perFulfillment[key].plannedSum += o.prepTimeMinutes;
        perFulfillment[key].plannedCount += 1;
      }
      if (o.readyAt && o.createdAt) {
        const diffMs = new Date(o.readyAt).getTime() - new Date(o.createdAt).getTime();
        if (diffMs > 0) {
          actualSum += diffMs / 6e4;
          actualCount += 1;
          const key = o.fulfillmentType || "unknown";
          perFulfillment[key] = perFulfillment[key] || { plannedSum: 0, plannedCount: 0, actualSum: 0, actualCount: 0 };
          perFulfillment[key].actualSum += diffMs / 6e4;
          perFulfillment[key].actualCount += 1;
        }
      }
    }
    const averagesByFulfillment = Object.entries(perFulfillment).map(([fulfillmentType, stats]) => ({
      fulfillmentType,
      prepMinutesPlanned: stats.plannedCount ? stats.plannedSum / stats.plannedCount : null,
      prepMinutesActual: stats.actualCount ? stats.actualSum / stats.actualCount : null
    }));
    return {
      byChannel,
      byFulfillment,
      byStatus,
      averages: {
        prepMinutesPlanned: plannedCount ? plannedSum / plannedCount : null,
        prepMinutesActual: actualCount ? actualSum / actualCount : null
      },
      averagesByFulfillment
    };
  }
  resolveInventoryChannel(channel) {
    if (!channel) return "pos";
    if (channel === "online" || channel === "portal" || channel === "kiosk" || channel === "internal") return channel;
    return "pos";
  }
  resolveFulfillmentType(type) {
    if (type === "curbside" || type === "delivery" || type === "table_service" || type === "pickup") return type;
    return "pickup";
  }
  async adjustInventoryForChannel(product, channel, delta) {
    const mode = product.channelInventoryMode ?? "shared";
    if (!product.trackInventory) return;
    if (mode === "split") {
      if (channel === "online" || channel === "portal") {
        const next3 = Math.max(0, (product.onlineStockQty ?? 0) + delta);
        await this.prisma.product.update({ where: { id: product.id }, data: { onlineStockQty: next3 } });
        return;
      }
      const next2 = Math.max(0, (product.posStockQty ?? 0) + delta);
      await this.prisma.product.update({ where: { id: product.id }, data: { posStockQty: next2 } });
      return;
    }
    const next = Math.max(0, (product.stockQty ?? 0) + delta);
    await this.prisma.product.update({ where: { id: product.id }, data: { stockQty: next } });
  }
  async createOrder(data) {
    const campground = await this.prisma.campground.findUnique({
      where: { id: data.campgroundId },
      select: { storeOpenHour: true, storeCloseHour: true, email: true, name: true }
    });
    const now = /* @__PURE__ */ new Date();
    const openHour = campground?.storeOpenHour ?? Number(process.env.STORE_OPEN_HOUR ?? 8);
    const closeHour = campground?.storeCloseHour ?? Number(process.env.STORE_CLOSE_HOUR ?? 20);
    const isOpen = now.getHours() >= openHour && now.getHours() < closeHour;
    const productIds = data.items.filter((i) => i.productId).map((i) => i.productId);
    const addOnIds = data.items.filter((i) => i.addOnId).map((i) => i.addOnId);
    const [products, addOns] = await Promise.all([
      productIds.length > 0 ? this.prisma.product.findMany({ where: { id: { in: productIds } } }) : [],
      addOnIds.length > 0 ? this.prisma.addOnService.findMany({ where: { id: { in: addOnIds } } }) : []
    ]);
    const productMap = new Map(products.map((p) => [p.id, p]));
    const addOnMap = new Map(addOns.map((a) => [a.id, a]));
    let subtotalCents = 0;
    let disallowedAfterHours = false;
    const channel = this.resolveInventoryChannel(data.channel);
    const fulfillmentType = this.resolveFulfillmentType(data.fulfillmentType);
    const orderItems = data.items.map((item) => {
      let name = "";
      let unitCents = 0;
      let afterHoursAllowed = false;
      let availableQty = Infinity;
      if (item.productId) {
        const product = productMap.get(item.productId);
        if (product) {
          name = product.name;
          unitCents = product.priceCents;
          afterHoursAllowed = !!product.afterHoursAllowed;
          const mode = product.channelInventoryMode ?? "shared";
          if (mode === "split") {
            availableQty = channel === "online" || channel === "portal" ? Math.max(0, (product.onlineStockQty ?? 0) - (product.onlineBufferQty ?? 0)) : Math.max(0, product.posStockQty ?? 0);
          } else {
            availableQty = Math.max(0, product.stockQty ?? 0);
          }
          if (product.trackInventory && availableQty < item.qty) {
            throw new import_common109.ConflictException(`Not enough ${channel === "online" ? "online" : "in-store"} allotment for ${product.name}`);
          }
        }
      } else if (item.addOnId) {
        const addOn = addOnMap.get(item.addOnId);
        if (addOn) {
          name = addOn.name;
          unitCents = addOn.priceCents;
        }
      }
      const totalCents2 = unitCents * item.qty;
      subtotalCents += totalCents2;
      if (!isOpen && !afterHoursAllowed) {
        disallowedAfterHours = true;
      }
      return {
        productId: item.productId || null,
        addOnId: item.addOnId || null,
        name,
        qty: item.qty,
        unitCents,
        totalCents: totalCents2
      };
    });
    const taxCents = 0;
    const totalCents = subtotalCents + taxCents;
    if (!isOpen && disallowedAfterHours) {
      throw new import_common109.ConflictException("Store is closed. Only after-hours items are available.");
    }
    const order = await this.prisma.storeOrder.create({
      data: {
        campgroundId: data.campgroundId,
        reservationId: data.reservationId || null,
        guestId: data.guestId || null,
        siteNumber: data.siteNumber || null,
        channel,
        fulfillmentType,
        deliveryInstructions: data.deliveryInstructions || null,
        promisedAt: data.promisedAt ? new Date(data.promisedAt) : null,
        prepTimeMinutes: data.prepTimeMinutes ?? null,
        paymentMethod: data.paymentMethod || "card",
        notes: data.notes || null,
        subtotalCents,
        taxCents,
        totalCents,
        status: "pending",
        items: {
          create: orderItems
        }
      },
      include: { items: true }
    });
    this.notifyStaffNewOrder(order, campground?.email, campground?.name, campground?.orderWebhookUrl).catch(() => {
    });
    for (const item of data.items) {
      if (item.productId) {
        const product = productMap.get(item.productId);
        if (product?.trackInventory && !(product.afterHoursAllowed && !isOpen)) {
          await this.adjustInventoryForChannel(product, channel, -item.qty);
        }
      }
    }
    if (data.paymentMethod === "charge_to_site" && data.reservationId) {
      await this.prisma.ledgerEntry.create({
        data: {
          campgroundId: data.campgroundId,
          reservationId: data.reservationId,
          glCode: "STORE",
          account: "Store Charges",
          description: `Store order #${order.id.slice(-6)}`,
          amountCents: totalCents,
          direction: "debit"
        }
      });
      await this.prisma.reservation.update({
        where: { id: data.reservationId },
        data: {
          balanceAmount: { increment: totalCents },
          totalAmount: { increment: totalCents }
        }
      });
    }
    return order;
  }
  getOrder(id) {
    return this.prisma.storeOrder.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: { select: { imageUrl: true } }
          }
        },
        reservation: {
          select: {
            id: true,
            site: { select: { siteNumber: true, name: true } },
            guest: { select: { primaryFirstName: true, primaryLastName: true } }
          }
        }
      }
    }).then((order) => order ? this.attachAdjustments(order) : null);
  }
  getOrderAdjustments(orderId) {
    return this.orderAdjustments.get(orderId) ?? [];
  }
  attachAdjustments(order) {
    const adjustments = this.getOrderAdjustments(order.id);
    return { ...order, adjustments };
  }
  async recordRefundOrExchange(orderId, payload, user) {
    const order = await this.prisma.storeOrder.findUnique({
      where: { id: orderId },
      include: { items: true }
    });
    if (!order) {
      throw new Error("Order not found");
    }
    const selectedItems = payload.items && payload.items.length > 0 ? payload.items.map((item) => {
      const match = order.items.find((i) => i.id === item.itemId);
      return {
        itemId: item.itemId || match?.id || (0, import_crypto12.randomUUID)(),
        name: item.name || match?.name || "Line item",
        qty: item.qty ?? match?.qty ?? 0,
        amountCents: item.amountCents ?? match?.totalCents ?? 0
      };
    }) : order.items.map((i) => ({
      itemId: i.id,
      name: i.name,
      qty: i.qty,
      amountCents: i.totalCents ?? 0
    }));
    const amountCents = payload.amountCents ?? selectedItems.reduce((sum, i) => sum + (i.amountCents ?? 0), 0);
    const entry = {
      id: (0, import_crypto12.randomUUID)(),
      type: payload.type === "exchange" ? "exchange" : "refund",
      amountCents,
      note: payload.note || null,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      items: selectedItems,
      createdBy: user ? {
        id: user.id,
        name: `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.email
      } : void 0
    };
    const existing = this.orderAdjustments.get(orderId) ?? [];
    this.orderAdjustments.set(orderId, [entry, ...existing]);
    if (entry.type === "refund" && order.status !== "refunded") {
      await this.updateOrderStatus(orderId, "refunded", user?.id);
    }
    return entry;
  }
  async notifyStaffNewOrder(order, email, campgroundName, webhookUrl) {
    const title = `New Store Order ${order.id.slice(0, 8)}`;
    const total = `$${(order.totalCents / 100).toFixed(2)}`;
    const itemsList = order.items?.map((i) => `<li>${i.qty} x ${i.name} - $${(i.totalCents / 100).toFixed(2)}</li>`).join("") ?? "";
    const fulfillment = order.fulfillmentType ? String(order.fulfillmentType).replace("_", " ") : "pickup";
    const channel = order.channel ?? "pos";
    const instructions = order.deliveryInstructions ? `<p><strong>Instructions:</strong> ${order.deliveryInstructions}</p>` : "";
    const promised = order.promisedAt ? `<p><strong>Promised at:</strong> ${new Date(order.promisedAt).toLocaleString()}</p>` : "";
    if (email) {
      const html = `
              <h2>${campgroundName || "Campground"} - New Store Order</h2>
              <p><strong>Order ID:</strong> ${order.id}</p>
              <p><strong>Total:</strong> ${total}</p>
              <p><strong>Payment:</strong> ${order.paymentMethod || "charge_to_site"}</p>
              <p><strong>Channel:</strong> ${channel}</p>
              <p><strong>Fulfillment:</strong> ${fulfillment}</p>
              <p><strong>Site:</strong> ${order.siteNumber || "N/A"}</p>
              ${promised}
              ${instructions}
              <p><strong>Placed At:</strong> ${new Date(order.createdAt).toLocaleString()}</p>
              <p><strong>Items:</strong></p>
              <ul>${itemsList}</ul>
            `;
      await this.emailService.sendEmail({
        to: email,
        subject: title,
        html
      });
    }
    if (webhookUrl) {
      try {
        await fetch(webhookUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            type: "store.order.created",
            id: order.id,
            campgroundName,
            total: order.totalCents,
            siteNumber: order.siteNumber,
            paymentMethod: order.paymentMethod,
            channel,
            fulfillmentType: order.fulfillmentType,
            deliveryInstructions: order.deliveryInstructions,
            promisedAt: order.promisedAt,
            createdAt: order.createdAt,
            items: order.items?.map((i) => ({
              name: i.name,
              qty: i.qty,
              totalCents: i.totalCents
            }))
          })
        });
      } catch {
      }
    }
  }
};
StoreService = __decorateClass([
  (0, import_common109.Injectable)()
], StoreService);

// src/store/store.controller.ts
var import_common110 = require("@nestjs/common");
var import_passport4 = require("@nestjs/passport");
var import_common111 = require("@nestjs/common");
var StoreController = class {
  constructor(store) {
    this.store = store;
  }
  listCategories(campgroundId) {
    return this.store.listCategories(campgroundId);
  }
  createCategory(campgroundId, body) {
    return this.store.createCategory({ campgroundId, ...body });
  }
  updateCategory(id, body) {
    return this.store.updateCategory(id, body);
  }
  deleteCategory(id) {
    return this.store.deleteCategory(id);
  }
  listProducts(campgroundId, categoryId) {
    return this.store.listProducts(campgroundId, categoryId);
  }
  getProduct(id) {
    return this.store.getProduct(id);
  }
  createProduct(campgroundId, body) {
    return this.store.createProduct({ campgroundId, ...body });
  }
  updateStock(campgroundId, id, body) {
    if (typeof body.stockQty === "number") {
      return this.store.setStock(id, body.stockQty, body.channel);
    }
    const delta = typeof body.delta === "number" ? body.delta : 0;
    return this.store.adjustStock(id, delta, body.channel);
  }
  updateProduct(id, body) {
    return this.store.updateProduct(id, body);
  }
  deleteProduct(id) {
    return this.store.deleteProduct(id);
  }
  getLowStockProducts(campgroundId) {
    return this.store.getLowStockProducts(campgroundId);
  }
  listAddOns(campgroundId) {
    return this.store.listAddOns(campgroundId);
  }
  createAddOn(campgroundId, body) {
    return this.store.createAddOn({ campgroundId, ...body });
  }
  updateAddOn(id, body) {
    return this.store.updateAddOn(id, body);
  }
  deleteAddOn(id) {
    return this.store.deleteAddOn(id);
  }
  listOrders(campgroundId, status, reservationId) {
    return this.store.listOrders(campgroundId, { status, reservationId });
  }
  getSummary(campgroundId, start, end) {
    const startDate = start ? new Date(start) : void 0;
    const endDate = end ? new Date(end) : void 0;
    return this.store.getOrderSummary(campgroundId, { start: startDate, end: endDate });
  }
  getOrder(id) {
    return this.store.getOrder(id);
  }
  createOrder(campgroundId, body) {
    return this.store.createOrder({ campgroundId, ...body });
  }
  listProductsPortal(campgroundId, categoryId) {
    return this.store.listProducts(campgroundId, categoryId);
  }
  listAddOnsPortal(campgroundId) {
    return this.store.listAddOns(campgroundId);
  }
  async createOrderPortal(req, body) {
    const guest = req.user;
    if (!body.reservationId) {
      throw new Error("reservationId is required");
    }
    const reservation = await this.store.findReservationForGuest(body.reservationId, guest.id);
    if (!reservation) {
      throw new Error("Reservation not found for this guest");
    }
    return this.store.createOrder({
      campgroundId: reservation.campgroundId,
      reservationId: reservation.id,
      guestId: guest.id,
      siteNumber: reservation.site?.siteNumber ?? void 0,
      paymentMethod: "charge_to_site",
      channel: "portal",
      fulfillmentType: body.fulfillmentType ?? "delivery",
      ...body
    });
  }
  completeOrder(id, req) {
    const user = req.user;
    return this.store.updateOrderStatus(id, "completed", user?.id);
  }
  updateStatus(id, body, req) {
    const user = req.user;
    return this.store.updateOrderStatus(id, body.status, user?.id);
  }
  getOrderHistory(id) {
    return this.store.getOrderAdjustments(id);
  }
  recordRefundOrExchange(id, body, req) {
    const user = req.user;
    return this.store.recordRefundOrExchange(id, body, user);
  }
  listUnseen(campgroundId) {
    return this.store.listUnseenOrders(campgroundId);
  }
  markSeen(id) {
    return this.store.markOrderSeen(id);
  }
};
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/categories"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId"))
], StoreController.prototype, "listCategories", 1);
__decorateClass([
  (0, import_common110.Post)("campgrounds/:campgroundId/store/categories"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "createCategory", 1);
__decorateClass([
  (0, import_common110.Patch)("store/categories/:id"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "updateCategory", 1);
__decorateClass([
  (0, import_common110.Delete)("store/categories/:id"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "deleteCategory", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/products"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Query)("categoryId"))
], StoreController.prototype, "listProducts", 1);
__decorateClass([
  (0, import_common110.Get)("store/products/:id"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "getProduct", 1);
__decorateClass([
  (0, import_common110.Post)("campgrounds/:campgroundId/store/products"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "createProduct", 1);
__decorateClass([
  (0, import_common110.Patch)("campgrounds/:campgroundId/store/products/:id/stock"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Param)("id")),
  __decorateParam(2, (0, import_common110.Body)())
], StoreController.prototype, "updateStock", 1);
__decorateClass([
  (0, import_common110.Patch)("store/products/:id"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "updateProduct", 1);
__decorateClass([
  (0, import_common110.Delete)("store/products/:id"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "deleteProduct", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/products/low-stock"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId"))
], StoreController.prototype, "getLowStockProducts", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/addons"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId"))
], StoreController.prototype, "listAddOns", 1);
__decorateClass([
  (0, import_common110.Post)("campgrounds/:campgroundId/store/addons"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "createAddOn", 1);
__decorateClass([
  (0, import_common110.Patch)("store/addons/:id"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "updateAddOn", 1);
__decorateClass([
  (0, import_common110.Delete)("store/addons/:id"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "deleteAddOn", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/orders"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Query)("status")),
  __decorateParam(2, (0, import_common110.Query)("reservationId"))
], StoreController.prototype, "listOrders", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/orders/summary"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Query)("start")),
  __decorateParam(2, (0, import_common110.Query)("end"))
], StoreController.prototype, "getSummary", 1);
__decorateClass([
  (0, import_common110.Get)("store/orders/:id"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "getOrder", 1);
__decorateClass([
  (0, import_common110.Post)("campgrounds/:campgroundId/store/orders"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId")),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "createOrder", 1);
__decorateClass([
  (0, import_common110.UseGuards)((0, import_passport4.AuthGuard)("guest-jwt")),
  (0, import_common110.Get)("portal/store/products"),
  __decorateParam(0, (0, import_common110.Query)("campgroundId")),
  __decorateParam(1, (0, import_common110.Query)("categoryId"))
], StoreController.prototype, "listProductsPortal", 1);
__decorateClass([
  (0, import_common110.UseGuards)((0, import_passport4.AuthGuard)("guest-jwt")),
  (0, import_common110.Get)("portal/store/addons"),
  __decorateParam(0, (0, import_common110.Query)("campgroundId"))
], StoreController.prototype, "listAddOnsPortal", 1);
__decorateClass([
  (0, import_common110.UseGuards)((0, import_passport4.AuthGuard)("guest-jwt")),
  (0, import_common110.Post)("portal/store/orders"),
  __decorateParam(0, (0, import_common111.Req)()),
  __decorateParam(1, (0, import_common110.Body)())
], StoreController.prototype, "createOrderPortal", 1);
__decorateClass([
  (0, import_common110.Patch)("store/orders/:id/complete"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common111.Req)())
], StoreController.prototype, "completeOrder", 1);
__decorateClass([
  (0, import_common110.Patch)("store/orders/:id/status"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common110.Body)()),
  __decorateParam(2, (0, import_common111.Req)())
], StoreController.prototype, "updateStatus", 1);
__decorateClass([
  (0, import_common110.Get)("store/orders/:id/history"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "getOrderHistory", 1);
__decorateClass([
  (0, import_common110.Post)("store/orders/:id/refunds"),
  __decorateParam(0, (0, import_common110.Param)("id")),
  __decorateParam(1, (0, import_common110.Body)()),
  __decorateParam(2, (0, import_common111.Req)())
], StoreController.prototype, "recordRefundOrExchange", 1);
__decorateClass([
  (0, import_common110.Get)("campgrounds/:campgroundId/store/orders/unseen"),
  __decorateParam(0, (0, import_common110.Param)("campgroundId"))
], StoreController.prototype, "listUnseen", 1);
__decorateClass([
  (0, import_common110.Patch)("store/orders/:id/seen"),
  __decorateParam(0, (0, import_common110.Param)("id"))
], StoreController.prototype, "markSeen", 1);
StoreController = __decorateClass([
  (0, import_common110.UseGuards)(JwtAuthGuard),
  (0, import_common110.Controller)()
], StoreController);

// src/store/store.module.ts
var StoreModule = class {
};
StoreModule = __decorateClass([
  (0, import_common112.Module)({
    controllers: [StoreController],
    providers: [StoreService, PrismaService, EmailService],
    exports: [StoreService]
  })
], StoreModule);

// src/guest-auth/guest-auth.module.ts
var import_common116 = require("@nestjs/common");
var import_jwt3 = require("@nestjs/jwt");

// src/guest-auth/guest-auth.controller.ts
var import_common113 = require("@nestjs/common");
var import_passport5 = require("@nestjs/passport");
var GuestAuthController = class {
  constructor(guestAuthService) {
    this.guestAuthService = guestAuthService;
  }
  async sendMagicLink(email) {
    return this.guestAuthService.sendMagicLink(email);
  }
  async verifyToken(token) {
    return this.guestAuthService.verifyToken(token);
  }
  async getMe(req) {
    return this.guestAuthService.getMe(req.user.id);
  }
};
__decorateClass([
  (0, import_common113.Post)("magic-link"),
  __decorateParam(0, (0, import_common113.Body)("email"))
], GuestAuthController.prototype, "sendMagicLink", 1);
__decorateClass([
  (0, import_common113.Post)("verify"),
  __decorateParam(0, (0, import_common113.Body)("token"))
], GuestAuthController.prototype, "verifyToken", 1);
__decorateClass([
  (0, import_common113.Get)("me"),
  (0, import_common113.UseGuards)((0, import_passport5.AuthGuard)("guest-jwt")),
  __decorateParam(0, (0, import_common113.Request)())
], GuestAuthController.prototype, "getMe", 1);
GuestAuthController = __decorateClass([
  (0, import_common113.Controller)("guest-auth")
], GuestAuthController);

// src/guest-auth/guest-auth.service.ts
var import_common114 = require("@nestjs/common");
var import_crypto13 = require("crypto");
var GuestAuthService = class {
  constructor(prisma, jwtService, emailService) {
    this.prisma = prisma;
    this.jwtService = jwtService;
    this.emailService = emailService;
  }
  async sendMagicLink(email) {
    const normalizedEmail = email.toLowerCase().trim();
    let account = await this.prisma.guestAccount.findUnique({
      where: { email: normalizedEmail }
    });
    if (!account) {
      const guest = await this.prisma.guest.findFirst({
        where: { email: normalizedEmail },
        orderBy: { updatedAt: "desc" }
      });
      if (!guest) {
        return { message: "If an account exists, a magic link has been sent." };
      }
      account = await this.prisma.guestAccount.create({
        data: {
          email: normalizedEmail,
          guestId: guest.id
        }
      });
    }
    const token = (0, import_crypto13.randomBytes)(32).toString("hex");
    const expiry = /* @__PURE__ */ new Date();
    expiry.setMinutes(expiry.getMinutes() + 15);
    await this.prisma.guestAccount.update({
      where: { id: account.id },
      data: {
        magicLinkToken: token,
        tokenExpiry: expiry
      }
    });
    const baseUrl = (process.env.APP_BASE_URL || process.env.NEXT_PUBLIC_APP_BASE || "http://localhost:3000").replace(/\/+$/, "");
    const link = `${baseUrl}/portal/verify?token=${token}`;
    try {
      await this.emailService.sendEmail({
        to: normalizedEmail,
        subject: "Your guest portal link",
        html: `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 520px; margin: 0 auto; padding: 24px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px;">
                        <h2 style="margin: 0 0 12px 0; color: #0f172a;">Access your stay</h2>
                        <p style="margin: 0 0 16px 0; color: #475569;">Tap the button below to open your guest portal and view your reservation details.</p>
                        <a href="${link}" style="display: inline-block; padding: 12px 18px; background: #10b981; color: #fff; text-decoration: none; border-radius: 8px; font-weight: 600;">Open guest portal</a>
                        <p style="margin: 16px 0 0 0; color: #94a3b8; font-size: 12px;">This link expires in 15 minutes. If you didn\u2019t request it, you can ignore this email.</p>
                        <p style="margin: 8px 0 0 0; color: #94a3b8; font-size: 12px; word-break: break-all;">If the button doesn\u2019t work, copy and paste this URL: <br/><a href="${link}" style="color: #0ea5e9;">${link}</a></p>
                    </div>
                `
      });
    } catch (err) {
      console.log(`[MAGIC LINK] For ${normalizedEmail}: ${link}`);
    }
    return { message: "Magic link sent" };
  }
  async verifyToken(token) {
    const account = await this.prisma.guestAccount.findUnique({
      where: { magicLinkToken: token },
      include: { guest: true }
    });
    if (!account || !account.tokenExpiry || account.tokenExpiry < /* @__PURE__ */ new Date()) {
      throw new import_common114.UnauthorizedException("Invalid or expired token");
    }
    await this.prisma.guestAccount.update({
      where: { id: account.id },
      data: {
        magicLinkToken: null,
        tokenExpiry: null
      }
    });
    const jwt = this.jwtService.sign({
      sub: account.guestId,
      email: account.email
    });
    return {
      token: jwt,
      guest: {
        id: account.guest.id,
        firstName: account.guest.primaryFirstName,
        lastName: account.guest.primaryLastName,
        email: account.guest.email
      }
    };
  }
  async getMe(guestId) {
    const guest = await this.prisma.guest.findUnique({
      where: { id: guestId },
      include: {
        reservations: {
          include: {
            campground: {
              select: {
                name: true,
                slug: true,
                heroImageUrl: true,
                amenities: true,
                checkInTime: true,
                checkOutTime: true
              }
            },
            site: true
          },
          orderBy: { arrivalDate: "desc" }
        }
      }
    });
    if (!guest) {
      throw new import_common114.NotFoundException("Guest not found");
    }
    return guest;
  }
};
GuestAuthService = __decorateClass([
  (0, import_common114.Injectable)()
], GuestAuthService);

// src/guest-auth/strategies/guest-jwt.strategy.ts
var import_common115 = require("@nestjs/common");
var import_passport6 = require("@nestjs/passport");
var import_passport_jwt2 = require("passport-jwt");
var GuestJwtStrategy = class extends (0, import_passport6.PassportStrategy)(import_passport_jwt2.Strategy, "guest-jwt") {
  constructor(config2, prisma) {
    super({
      jwtFromRequest: import_passport_jwt2.ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: config2.get("JWT_SECRET") || "dev-secret-change-me"
    });
    this.config = config2;
    this.prisma = prisma;
  }
  async validate(payload) {
    const guest = await this.prisma.guest.findUnique({
      where: { id: payload.sub }
    });
    if (!guest) {
      throw new import_common115.UnauthorizedException();
    }
    return guest;
  }
};
GuestJwtStrategy = __decorateClass([
  (0, import_common115.Injectable)()
], GuestJwtStrategy);

// src/guest-auth/guest-auth.module.ts
var GuestAuthModule = class {
};
GuestAuthModule = __decorateClass([
  (0, import_common116.Module)({
    imports: [
      PrismaModule,
      EmailModule,
      import_jwt3.JwtModule.register({
        secret: process.env.JWT_SECRET || "secret",
        signOptions: { expiresIn: "7d" }
      })
    ],
    controllers: [GuestAuthController],
    providers: [GuestAuthService, GuestJwtStrategy],
    exports: [GuestAuthService]
  })
], GuestAuthModule);

// src/blackouts/blackouts.module.ts
var import_common119 = require("@nestjs/common");

// src/blackouts/blackouts.service.ts
var import_common117 = require("@nestjs/common");
var BlackoutsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  parseDates(startDate, endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    if (isNaN(start.valueOf()) || isNaN(end.valueOf())) {
      throw new import_common117.BadRequestException("Invalid start or end date");
    }
    if (end <= start) {
      throw new import_common117.BadRequestException("End date must be after start date");
    }
    return { start, end };
  }
  async validateCampgroundAndSite(campgroundId, siteId) {
    const campground = await this.prisma.campground.findUnique({ where: { id: campgroundId }, select: { id: true } });
    if (!campground) {
      throw new import_common117.NotFoundException("Campground not found");
    }
    if (!siteId) return null;
    const site = await this.prisma.site.findUnique({
      where: { id: siteId },
      select: { id: true, campgroundId: true }
    });
    if (!site || site.campgroundId !== campgroundId) {
      throw new import_common117.BadRequestException("Site not found for this campground");
    }
    return site.id;
  }
  async assertNoOverlap(campgroundId, start, end, siteId, excludeId) {
    const overlapCount = await this.prisma.blackoutDate.count({
      where: {
        campgroundId,
        id: excludeId ? { not: excludeId } : void 0,
        startDate: { lt: end },
        endDate: { gt: start },
        ...siteId ? { OR: [{ siteId }, { siteId: null }] } : {}
        // park-wide should check any existing blackout
      }
    });
    if (overlapCount > 0) {
      throw new import_common117.BadRequestException("Blackout dates overlap an existing blackout");
    }
  }
  async create(data) {
    const { start, end } = this.parseDates(data.startDate, data.endDate);
    const siteId = await this.validateCampgroundAndSite(data.campgroundId, data.siteId || null);
    await this.assertNoOverlap(data.campgroundId, start, end, siteId, void 0);
    return this.prisma.blackoutDate.create({
      data: {
        campgroundId: data.campgroundId,
        siteId: siteId || null,
        startDate: start,
        endDate: end,
        reason: data.reason
      }
    });
  }
  async findAll(campgroundId) {
    return this.prisma.blackoutDate.findMany({
      where: { campgroundId },
      include: { site: true },
      orderBy: { startDate: "asc" }
    });
  }
  async findOne(id) {
    const blackout = await this.prisma.blackoutDate.findUnique({
      where: { id },
      include: { site: true }
    });
    if (!blackout) throw new import_common117.NotFoundException("Blackout date not found");
    return blackout;
  }
  async update(id, data) {
    const existing = await this.findOne(id);
    const start = data.startDate ? new Date(data.startDate) : existing.startDate;
    const end = data.endDate ? new Date(data.endDate) : existing.endDate;
    if (isNaN(start.valueOf()) || isNaN(end.valueOf())) {
      throw new import_common117.BadRequestException("Invalid start or end date");
    }
    if (end <= start) {
      throw new import_common117.BadRequestException("End date must be after start date");
    }
    const siteId = await this.validateCampgroundAndSite(existing.campgroundId, data.siteId ?? existing.siteId);
    await this.assertNoOverlap(existing.campgroundId, start, end, siteId ?? existing.siteId, id);
    return this.prisma.blackoutDate.update({
      where: { id },
      data: {
        startDate: start,
        endDate: end,
        reason: data.reason ?? existing.reason,
        siteId: siteId ?? null
      }
    });
  }
  async remove(id) {
    return this.prisma.blackoutDate.delete({ where: { id } });
  }
};
BlackoutsService = __decorateClass([
  (0, import_common117.Injectable)()
], BlackoutsService);

// src/blackouts/blackouts.controller.ts
var import_common118 = require("@nestjs/common");
var BlackoutsController = class {
  constructor(blackoutsService) {
    this.blackoutsService = blackoutsService;
  }
  create(createBlackoutDateDto) {
    return this.blackoutsService.create(createBlackoutDateDto);
  }
  findAll(campgroundId) {
    return this.blackoutsService.findAll(campgroundId);
  }
  findOne(id) {
    return this.blackoutsService.findOne(id);
  }
  update(id, updateBlackoutDateDto) {
    return this.blackoutsService.update(id, updateBlackoutDateDto);
  }
  remove(id) {
    return this.blackoutsService.remove(id);
  }
};
__decorateClass([
  (0, import_common118.Post)(),
  __decorateParam(0, (0, import_common118.Body)())
], BlackoutsController.prototype, "create", 1);
__decorateClass([
  (0, import_common118.Get)("campgrounds/:campgroundId"),
  __decorateParam(0, (0, import_common118.Param)("campgroundId"))
], BlackoutsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common118.Get)(":id"),
  __decorateParam(0, (0, import_common118.Param)("id"))
], BlackoutsController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common118.Patch)(":id"),
  __decorateParam(0, (0, import_common118.Param)("id")),
  __decorateParam(1, (0, import_common118.Body)())
], BlackoutsController.prototype, "update", 1);
__decorateClass([
  (0, import_common118.Delete)(":id"),
  __decorateParam(0, (0, import_common118.Param)("id"))
], BlackoutsController.prototype, "remove", 1);
BlackoutsController = __decorateClass([
  (0, import_common118.UseGuards)(JwtAuthGuard),
  (0, import_common118.Controller)("blackouts")
], BlackoutsController);

// src/blackouts/blackouts.module.ts
var BlackoutsModule = class {
};
BlackoutsModule = __decorateClass([
  (0, import_common119.Module)({
    imports: [PrismaModule],
    controllers: [BlackoutsController],
    providers: [BlackoutsService],
    exports: [BlackoutsService]
  })
], BlackoutsModule);

// src/promotions/promotions.module.ts
var import_common121 = require("@nestjs/common");

// src/promotions/promotions.controller.ts
var import_common120 = require("@nestjs/common");
var PromotionsController = class {
  constructor(promotionsService) {
    this.promotionsService = promotionsService;
  }
  create(createPromotionDto) {
    return this.promotionsService.create(createPromotionDto);
  }
  findAll(campgroundId) {
    return this.promotionsService.findAll(campgroundId);
  }
  findOne(id) {
    return this.promotionsService.findOne(id);
  }
  update(id, updatePromotionDto) {
    return this.promotionsService.update(id, updatePromotionDto);
  }
  remove(id) {
    return this.promotionsService.remove(id);
  }
  validate(validatePromotionDto) {
    return this.promotionsService.validate(validatePromotionDto);
  }
};
__decorateClass([
  (0, import_common120.Post)(),
  __decorateParam(0, (0, import_common120.Body)())
], PromotionsController.prototype, "create", 1);
__decorateClass([
  (0, import_common120.Get)("campgrounds/:campgroundId"),
  __decorateParam(0, (0, import_common120.Param)("campgroundId"))
], PromotionsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common120.Get)(":id"),
  __decorateParam(0, (0, import_common120.Param)("id"))
], PromotionsController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common120.Patch)(":id"),
  __decorateParam(0, (0, import_common120.Param)("id")),
  __decorateParam(1, (0, import_common120.Body)())
], PromotionsController.prototype, "update", 1);
__decorateClass([
  (0, import_common120.Delete)(":id"),
  __decorateParam(0, (0, import_common120.Param)("id"))
], PromotionsController.prototype, "remove", 1);
__decorateClass([
  (0, import_common120.Post)("validate"),
  __decorateParam(0, (0, import_common120.Body)())
], PromotionsController.prototype, "validate", 1);
PromotionsController = __decorateClass([
  (0, import_common120.UseGuards)(JwtAuthGuard),
  (0, import_common120.Controller)("promotions")
], PromotionsController);

// src/promotions/promotions.module.ts
var PromotionsModule = class {
};
PromotionsModule = __decorateClass([
  (0, import_common121.Module)({
    imports: [PrismaModule],
    controllers: [PromotionsController],
    providers: [PromotionsService],
    exports: [PromotionsService]
  })
], PromotionsModule);

// src/public-reservations/public-reservations.module.ts
var import_common130 = require("@nestjs/common");

// src/public-reservations/public-reservations.controller.ts
var import_common122 = require("@nestjs/common");
var PublicReservationsController = class {
  constructor(service) {
    this.service = service;
  }
  getAvailability(slug, arrivalDate, departureDate, rigType, rigLength, needsAccessible) {
    const needsAccessibleBool = needsAccessible === "true" || needsAccessible === "1";
    return this.service.getAvailability(slug, arrivalDate, departureDate, rigType, rigLength, needsAccessibleBool);
  }
  getQuote(slug, dto) {
    return this.service.getQuote(slug, dto);
  }
  createReservation(dto) {
    return this.service.createReservation(dto);
  }
  abandonCart(body) {
    return this.service.abandonCart(body);
  }
  joinWaitlist(dto) {
    return this.service.createPublicWaitlistEntry(dto);
  }
  kioskCheckIn(id, body) {
    return this.service.kioskCheckIn(id, body.upsellTotalCents || 0);
  }
  getReservation(id) {
    return this.service.getReservation(id);
  }
};
__decorateClass([
  (0, import_common122.Get)("campgrounds/:slug/availability"),
  __decorateParam(0, (0, import_common122.Param)("slug")),
  __decorateParam(1, (0, import_common122.Query)("arrivalDate")),
  __decorateParam(2, (0, import_common122.Query)("departureDate")),
  __decorateParam(3, (0, import_common122.Query)("rigType")),
  __decorateParam(4, (0, import_common122.Query)("rigLength")),
  __decorateParam(5, (0, import_common122.Query)("needsAccessible"))
], PublicReservationsController.prototype, "getAvailability", 1);
__decorateClass([
  (0, import_common122.Post)("campgrounds/:slug/quote"),
  __decorateParam(0, (0, import_common122.Param)("slug")),
  __decorateParam(1, (0, import_common122.Body)())
], PublicReservationsController.prototype, "getQuote", 1);
__decorateClass([
  (0, import_common122.Post)("reservations"),
  __decorateParam(0, (0, import_common122.Body)())
], PublicReservationsController.prototype, "createReservation", 1);
__decorateClass([
  (0, import_common122.Post)("reservations/abandon"),
  __decorateParam(0, (0, import_common122.Body)())
], PublicReservationsController.prototype, "abandonCart", 1);
__decorateClass([
  (0, import_common122.Post)("waitlist"),
  __decorateParam(0, (0, import_common122.Body)())
], PublicReservationsController.prototype, "joinWaitlist", 1);
__decorateClass([
  (0, import_common122.Post)("reservations/:id/kiosk-checkin"),
  __decorateParam(0, (0, import_common122.Param)("id")),
  __decorateParam(1, (0, import_common122.Body)())
], PublicReservationsController.prototype, "kioskCheckIn", 1);
__decorateClass([
  (0, import_common122.Get)("reservations/:id"),
  __decorateParam(0, (0, import_common122.Param)("id"))
], PublicReservationsController.prototype, "getReservation", 1);
PublicReservationsController = __decorateClass([
  (0, import_common122.Controller)("public")
], PublicReservationsController);

// src/public-reservations/public-reservations.service.ts
var import_common123 = require("@nestjs/common");
var import_client21 = require("@prisma/client");

// src/pricing-v2/discount-engine.ts
var DEFAULT_MAX_FRACTION = 0.4;
function effectiveValue(base, discount) {
  if (discount.kind === "percent_off") {
    return discount.value / 100 * base;
  }
  return Math.min(discount.value, base);
}
function resolveDiscounts(baseAmount, candidates, options = {}) {
  const maxFraction = options.maxDiscountFraction ?? DEFAULT_MAX_FRACTION;
  const nonStackable = candidates.filter((c) => c.stackingRule === "non_stackable");
  const stackable = candidates.filter((c) => c.stackingRule === "stackable");
  const bestNonStackable = nonStackable.map((c) => ({ candidate: c, value: effectiveValue(baseAmount, c) })).sort((a, b) => {
    if (b.value !== a.value) return b.value - a.value;
    return a.candidate.priority - b.candidate.priority;
  })[0];
  const applied = [];
  const rejected = [];
  let total = 0;
  if (bestNonStackable) {
    applied.push({
      id: bestNonStackable.candidate.id,
      sourceType: bestNonStackable.candidate.sourceType,
      appliedAmount: roundCurrency(bestNonStackable.value)
    });
    total += bestNonStackable.value;
    nonStackable.filter((c) => c.id !== bestNonStackable.candidate.id).forEach((c) => rejected.push({ id: c.id, reason: "non_stackable_best_value_selected_elsewhere" }));
  }
  for (const cand of stackable) {
    const val = effectiveValue(baseAmount, cand);
    applied.push({
      id: cand.id,
      sourceType: cand.sourceType,
      appliedAmount: roundCurrency(val)
    });
    total += val;
  }
  const maxAllowed = baseAmount * maxFraction;
  let capped = false;
  if (total > maxAllowed) {
    capped = true;
    const scale = maxAllowed / total;
    applied.forEach((d) => d.appliedAmount = roundCurrency(d.appliedAmount * scale));
    total = applied.reduce((sum, d) => sum + d.appliedAmount, 0);
  } else {
    total = applied.reduce((sum, d) => sum + d.appliedAmount, 0);
  }
  return {
    applied,
    rejected,
    totalDiscount: roundCurrency(total),
    capped
  };
}
function roundCurrency(value) {
  return Math.round((value + Number.EPSILON) * 100) / 100;
}

// src/public-reservations/public-reservations.service.ts
var PublicReservationsService = class {
  constructor(prisma, locks, promotionsService, emailService, abandonedCarts, memberships, signatures, accessControl) {
    this.prisma = prisma;
    this.locks = locks;
    this.promotionsService = promotionsService;
    this.emailService = emailService;
    this.abandonedCarts = abandonedCarts;
    this.memberships = memberships;
    this.signatures = signatures;
    this.accessControl = accessControl;
  }
  async hasSignedWaiver(reservationId, guestId) {
    const [signedSignature, signedArtifact, digitalWaiver] = await Promise.all([
      this.prisma.signatureRequest.findFirst?.({
        where: { reservationId, documentType: "waiver", status: "signed" }
      }),
      this.prisma.signatureArtifact.findFirst?.({
        where: { reservationId, pdfUrl: { not: null } }
      }),
      this.prisma.digitalWaiver.findFirst?.({
        where: {
          OR: [{ reservationId }, { reservationId: null, guestId }],
          status: "signed"
        }
      })
    ]);
    return Boolean(signedSignature || signedArtifact || digitalWaiver);
  }
  async hasVerifiedId(reservationId, guestId) {
    const now = /* @__PURE__ */ new Date();
    const match = await this.prisma.idVerification.findFirst?.({
      where: {
        OR: [
          { reservationId, status: "verified" },
          { guestId, status: "verified", expiresAt: { gt: now } }
        ]
      }
    });
    return Boolean(match);
  }
  /**
   * Join waitlist publicly (creates guest if needed)
   */
  async createPublicWaitlistEntry(dto) {
    const arrival = new Date(dto.arrivalDate);
    const departure = new Date(dto.departureDate);
    if (isNaN(arrival.getTime()) || isNaN(departure.getTime()) || arrival >= departure) {
      throw new import_common123.BadRequestException("Invalid dates");
    }
    let guest = await this.prisma.guest.findUnique({
      where: { email: dto.email }
    });
    if (!guest) {
      guest = await this.prisma.guest.create({
        data: {
          email: dto.email,
          primaryFirstName: dto.firstName,
          primaryLastName: dto.lastName,
          phone: dto.phone || ""
          // Minimal guest record
        }
      });
    }
    return this.prisma.waitlistEntry.create({
      data: {
        campgroundId: dto.campgroundId,
        guestId: guest.id,
        siteId: dto.siteId,
        siteTypeId: dto.siteClassId,
        // Map siteClassId to siteTypeId
        arrivalDate: arrival,
        departureDate: departure,
        status: "active",
        type: "regular"
      }
    });
  }
  async enqueueAbandonedCartPlaybooks(campgroundId, guestId, reservationId) {
    const playbooks = await this.prisma.communicationPlaybook.findMany({
      where: { campgroundId, type: "abandoned_cart", enabled: true, templateId: { not: null } }
    });
    for (const pb of playbooks) {
      const tpl = await this.prisma.communicationTemplate.findFirst({
        where: { id: pb.templateId, status: "approved" }
      });
      if (!tpl) continue;
      const scheduledAt = /* @__PURE__ */ new Date();
      if (pb.offsetMinutes && Number.isFinite(pb.offsetMinutes)) {
        scheduledAt.setMinutes(scheduledAt.getMinutes() + pb.offsetMinutes);
      }
      await this.prisma.communicationPlaybookJob.create({
        data: {
          playbookId: pb.id,
          campgroundId,
          reservationId: reservationId ?? null,
          guestId: guestId ?? null,
          status: "pending",
          scheduledAt
        }
      });
    }
  }
  // ... existing code ...
  computeNights(arrival, departure) {
    const ms = departure.getTime() - arrival.getTime();
    if (!Number.isFinite(ms) || ms <= 0) return 1;
    return Math.max(1, Math.round(ms / (1e3 * 60 * 60 * 24)));
  }
  computeDepositRequired(rule, totalCents, nights, depositPercentage) {
    const normalized = (rule || "none").toLowerCase();
    if (normalized === "full") return totalCents;
    if (normalized === "half" || normalized === "percentage_50") return Math.ceil(totalCents / 2);
    if (normalized === "first_night" || normalized === "first_night_fees") return Math.ceil(totalCents / nights);
    if (normalized === "percentage") {
      const pct = depositPercentage ?? 0;
      if (pct <= 0) return 0;
      return Math.ceil(totalCents * (pct / 100));
    }
    return 0;
  }
  computePaymentStatus(total, paid) {
    if (!total || total <= 0) return "unpaid";
    if (paid >= total) return "paid";
    if (paid > 0) return "partial";
    return "unpaid";
  }
  async resolveReferralProgram(campgroundId, referralCode, referralProgramId, basisCents) {
    if (!referralCode && !referralProgramId) {
      return { program: null, discountCents: 0, type: null, value: 0, source: null, channel: null };
    }
    const program = await this.prisma.referralProgram.findFirst({
      where: {
        campgroundId,
        isActive: true,
        OR: [
          referralProgramId ? { id: referralProgramId } : void 0,
          referralCode ? { code: referralCode } : void 0,
          referralCode ? { linkSlug: referralCode } : void 0
        ].filter(Boolean)
      }
    });
    if (!program) {
      throw new import_common123.BadRequestException("Invalid or inactive referral code");
    }
    const type = program.incentiveType;
    const value = program.incentiveValue ?? 0;
    const basis = Math.max(0, basisCents ?? 0);
    let discountCents = 0;
    if (type === import_client21.ReferralIncentiveType.percent_discount) {
      discountCents = Math.min(basis, Math.floor(basis * (value / 100)));
    } else {
      discountCents = Math.min(basis, Math.max(0, value));
    }
    return {
      program,
      discountCents,
      type,
      value,
      source: program.source ?? null,
      channel: program.channel ?? null
    };
  }
  /**
   * Compute taxes for a given campground and taxable base (cents).
   * Applies exemption rules (type: 'exemption') if eligible; otherwise sums active tax rates (type: 'tax').
   */
  async computeTaxes(campgroundId, taxableCents, nights, waiverSigned) {
    const exemptions = await this.prisma.taxRule.findMany({
      where: { campgroundId, type: "exemption", isActive: true }
    });
    let waiverRequired = false;
    let waiverText = null;
    for (const rule of exemptions) {
      const meetsMin = rule.minNights ? nights >= rule.minNights : true;
      const meetsMax = rule.maxNights ? nights <= rule.maxNights : true;
      if (!meetsMin || !meetsMax) continue;
      if (rule.requiresWaiver && !waiverSigned) {
        waiverRequired = true;
        waiverText = rule.waiverText ?? null;
        continue;
      }
      return { taxesCents: 0, waiverRequired: false, waiverText: null, exemptionApplied: true };
    }
    const taxRules = await this.prisma.taxRule.findMany({
      where: { campgroundId, type: "tax", isActive: true }
    });
    const inclusiveRules = taxRules.filter((r) => Boolean(r.inclusive));
    const exclusiveRules = taxRules.filter((r) => !Boolean(r.inclusive));
    let taxesCents = 0;
    let inclusiveTaxesCents = 0;
    let baseForExclusive = taxableCents;
    if (inclusiveRules.length) {
      const totalInclusiveRate = inclusiveRules.reduce(
        (sum, r) => sum + Number(r.rate || 0),
        0
      );
      if (totalInclusiveRate > 0) {
        const net = taxableCents / (1 + totalInclusiveRate);
        const inclusiveTax = taxableCents - net;
        inclusiveTaxesCents = Math.round(inclusiveTax);
        taxesCents += inclusiveTaxesCents;
        baseForExclusive = net;
      }
    }
    for (const rule of exclusiveRules) {
      if (!rule.rate || Number(rule.rate) <= 0) continue;
      taxesCents += Math.round(baseForExclusive * Number(rule.rate));
    }
    return { taxesCents, inclusiveTaxesCents, waiverRequired, waiverText, exemptionApplied: false };
  }
  /**
   * Get available sites for a campground by slug
   */
  isRigCompatible(site, rigType, rigLength) {
    if (!rigType && !rigLength) return true;
    const normalizedType = (rigType || "").toLowerCase();
    if (["tent", "cabin", "car", "walkin", "walk-in"].includes(normalizedType)) return true;
    if (site.siteType !== "rv") return false;
    const maxLength = site.rigMaxLength ?? site.siteClassRigMaxLength ?? null;
    if (rigLength && maxLength && rigLength > maxLength) return false;
    return true;
  }
  async getAvailability(slug, arrivalDate, departureDate, rigType, rigLength, needsAccessible) {
    const campground = await this.prisma.campground.findUnique({
      where: { slug },
      select: { id: true, isPublished: true, isBookable: true, isExternal: true, nonBookableReason: true }
    });
    if (!campground || !campground.isPublished && !campground.isExternal) {
      throw new import_common123.NotFoundException("Campground not found");
    }
    if (!campground.isBookable || campground.isExternal) {
      throw new import_common123.BadRequestException(campground.nonBookableReason || "This campground is view-only.");
    }
    if (!arrivalDate || !departureDate) {
      throw new import_common123.BadRequestException("arrivalDate and departureDate are required");
    }
    const arrival = new Date(arrivalDate);
    const departure = new Date(departureDate);
    if (isNaN(arrival.valueOf()) || isNaN(departure.valueOf())) {
      throw new import_common123.BadRequestException("Invalid dates");
    }
    if (departure <= arrival) {
      throw new import_common123.BadRequestException("departureDate must be after arrivalDate");
    }
    const allSites = await this.prisma.site.findMany({
      where: {
        campgroundId: campground.id,
        isActive: true
      },
      include: {
        siteClass: {
          select: {
            id: true,
            name: true,
            defaultRate: true,
            siteType: true,
            maxOccupancy: true,
            hookupsPower: true,
            hookupsWater: true,
            hookupsSewer: true,
            petFriendly: true,
            description: true,
            rigMaxLength: true,
            accessible: true
          }
        }
      },
      orderBy: { name: "asc" }
    });
    const conflictingReservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId: campground.id,
        status: { not: import_client21.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure }
      },
      select: { siteId: true }
    });
    const conflictingSiteIds = new Set(conflictingReservations.map((r) => r.siteId));
    const now = /* @__PURE__ */ new Date();
    const holds = await this.prisma.siteHold.findMany({
      where: {
        campgroundId: campground.id,
        status: "active",
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }],
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival }
      },
      select: { siteId: true }
    });
    const holdSiteIds = new Set(holds.map((h) => h.siteId));
    const blackouts = await this.prisma.blackoutDate.findMany({
      where: {
        campgroundId: campground.id,
        startDate: { lt: departure },
        endDate: { gt: arrival }
      },
      select: { siteId: true }
    });
    const maintenanceTickets = await this.prisma.maintenanceTicket.findMany({
      where: {
        campgroundId: campground.id,
        isBlocking: true,
        status: { not: "closed" }
      },
      select: { siteId: true }
    });
    const blackedOutSiteIds = /* @__PURE__ */ new Set();
    const maintenanceSiteIds = /* @__PURE__ */ new Set();
    let campgroundBlackedOut = false;
    for (const b of blackouts) {
      if (b.siteId) {
        blackedOutSiteIds.add(b.siteId);
      } else {
        campgroundBlackedOut = true;
      }
    }
    for (const m of maintenanceTickets) {
      if (m.siteId) {
        maintenanceSiteIds.add(m.siteId);
      }
    }
    const rigLengthNum = rigLength ? Number(rigLength) : null;
    const sitesWithStatus = allSites.map((site) => {
      let status = "available";
      const accessibleFlag = Boolean(site.accessible || site.siteClass?.accessible);
      if (campgroundBlackedOut) {
        status = "locked";
      } else if (maintenanceSiteIds.has(site.id)) {
        status = "maintenance";
      } else if (blackedOutSiteIds.has(site.id)) {
        status = "locked";
      } else if (conflictingSiteIds.has(site.id)) {
        status = "booked";
      } else if (!this.isRigCompatible(
        {
          siteType: site.siteType || site.siteClass?.siteType || "rv",
          rigMaxLength: site.rigMaxLength,
          siteClassRigMaxLength: site?.siteClass?.rigMaxLength ?? null
        },
        rigType,
        Number.isFinite(rigLengthNum) ? rigLengthNum : null
      )) {
        status = "locked";
      } else if (needsAccessible && !accessibleFlag) {
        status = "locked";
      } else if (holdSiteIds.has(site.id)) {
        status = "locked";
      }
      return {
        id: site.id,
        name: site.name,
        siteNumber: site.siteNumber,
        siteType: site.siteType,
        maxOccupancy: site.maxOccupancy,
        rigMaxLength: site.rigMaxLength,
        accessible: accessibleFlag,
        siteClass: site.siteClass,
        status
      };
    });
    return sitesWithStatus;
  }
  /**
   * Get price quote for a site
   */
  async getQuote(slug, dto) {
    const campground = await this.prisma.campground.findUnique({
      where: { slug },
      select: { id: true, isPublished: true, isBookable: true, isExternal: true, nonBookableReason: true }
    });
    if (!campground || !campground.isPublished && !campground.isExternal) {
      throw new import_common123.NotFoundException("Campground not found");
    }
    if (!campground.isBookable || campground.isExternal) {
      throw new import_common123.BadRequestException(campground.nonBookableReason || "This campground is view-only.");
    }
    const arrival = new Date(dto.arrivalDate);
    const departure = new Date(dto.departureDate);
    const nights = this.computeNights(arrival, departure);
    const site = await this.prisma.site.findUnique({
      where: { id: dto.siteId },
      include: { siteClass: true }
    });
    if (!site || site.campgroundId !== campground.id) {
      throw new import_common123.NotFoundException("Site not found");
    }
    const baseRate = site.siteClass?.defaultRate ?? 0;
    const rules = await this.prisma.pricingRule.findMany({
      where: {
        campgroundId: campground.id,
        isActive: true,
        OR: [{ siteClassId: null }, { siteClassId: site.siteClassId }]
      }
    });
    let total = 0;
    let baseSubtotal = 0;
    let rulesDelta = 0;
    for (let i = 0; i < nights; i++) {
      const day = new Date(arrival);
      day.setDate(day.getDate() + i);
      const dow = day.getDay();
      let nightly = baseRate;
      let nightlyDelta = 0;
      for (const rule of rules) {
        if (rule.minNights && nights < rule.minNights) continue;
        if (rule.startDate && day < rule.startDate) continue;
        if (rule.endDate && day > rule.endDate) continue;
        if (rule.dayOfWeek !== null && rule.dayOfWeek !== void 0 && rule.dayOfWeek !== dow) continue;
        if (rule.flatAdjust) nightlyDelta += rule.flatAdjust;
        if (rule.percentAdjust) nightlyDelta += Math.round(nightly * Number(rule.percentAdjust));
      }
      nightly += nightlyDelta;
      baseSubtotal += baseRate;
      rulesDelta += nightlyDelta;
      total += nightly;
    }
    const candidates = [];
    let promotionId = null;
    if (dto.promoCode) {
      const validation = await this.promotionsService.validate({
        campgroundId: campground.id,
        code: dto.promoCode,
        subtotal: total
      });
      promotionId = validation.promotionId;
      candidates.push(
        validation.type === "percentage" ? {
          id: validation.promotionId,
          sourceType: "promo",
          stackingRule: "non_stackable",
          priority: 200,
          kind: "percent_off",
          value: validation.value
        } : {
          id: validation.promotionId,
          sourceType: "promo",
          stackingRule: "non_stackable",
          priority: 200,
          kind: "amount_off",
          value: validation.discountCents
        }
      );
    }
    if (dto.membershipId) {
      const membership = await this.memberships.getActiveMembershipById(dto.membershipId);
      if (membership && membership.membershipType?.discountPercent && membership.membershipType.isActive) {
        candidates.push({
          id: membership.id,
          sourceType: "membership",
          stackingRule: "non_stackable",
          priority: 150,
          kind: "percent_off",
          value: membership.membershipType.discountPercent
        });
      }
    }
    const resolved = resolveDiscounts(total, candidates);
    let discountCents = resolved.totalDiscount;
    const discountCapped = resolved.capped;
    const appliedDiscounts = resolved.applied.map((d) => {
      const candidate = candidates.find((c) => c.id === d.id);
      return {
        id: d.id,
        type: candidate?.sourceType ?? "unknown",
        amountCents: d.appliedAmount,
        capped: resolved.capped
      };
    });
    const rejectedDiscounts = resolved.rejected.map((r) => ({
      id: r.id,
      reason: r.reason
    }));
    const referral = await this.resolveReferralProgram(
      campground.id,
      dto.referralCode,
      void 0,
      Math.max(0, total - discountCents)
    );
    if (referral.program) {
      discountCents += referral.discountCents;
      appliedDiscounts.push({
        id: referral.program.id,
        type: "referral",
        amountCents: referral.discountCents,
        capped: false
      });
    }
    const totalAfterDiscount = Math.max(0, total - discountCents);
    const taxResult = await this.computeTaxes(
      campground.id,
      totalAfterDiscount,
      nights,
      dto.taxWaiverSigned ?? false
    );
    const totalWithTaxes = taxResult.inclusiveTaxesCents && taxResult.inclusiveTaxesCents > 0 ? totalAfterDiscount + (taxResult.taxesCents - taxResult.inclusiveTaxesCents) : totalAfterDiscount + taxResult.taxesCents;
    return {
      nights,
      baseSubtotalCents: baseSubtotal,
      rulesDeltaCents: rulesDelta,
      totalCents: total,
      discountCents,
      discountCapped,
      promotionId,
      appliedDiscounts,
      rejectedDiscounts,
      totalAfterDiscountCents: totalAfterDiscount,
      taxesCents: taxResult.taxesCents,
      totalWithTaxesCents: totalWithTaxes,
      perNightCents: Math.round(totalWithTaxes / nights),
      taxWaiverRequired: taxResult.waiverRequired,
      taxWaiverText: taxResult.waiverText,
      taxExemptionApplied: taxResult.exemptionApplied,
      referralProgramId: referral.program?.id ?? null,
      referralDiscountCents: referral.discountCents ?? 0,
      referralIncentiveType: referral.type ?? null,
      referralIncentiveValue: referral.discountCents ?? 0,
      referralSource: referral.source ?? null,
      referralChannel: referral.channel ?? null
    };
  }
  /**
   * Create a public reservation with inline guest info
   */
  async createReservation(dto) {
    const campground = await this.prisma.campground.findUnique({
      where: { slug: dto.campgroundSlug },
      select: {
        id: true,
        isPublished: true,
        isBookable: true,
        isExternal: true,
        nonBookableReason: true,
        depositRule: true,
        depositPercentage: true
      }
    });
    if (!campground || !campground.isPublished && !campground.isExternal) {
      throw new import_common123.NotFoundException("Campground not found");
    }
    if (!campground.isBookable || campground.isExternal) {
      throw new import_common123.BadRequestException(campground.nonBookableReason || "This campground is view-only.");
    }
    const arrival = new Date(dto.arrivalDate);
    const departure = new Date(dto.departureDate);
    if (isNaN(arrival.valueOf()) || isNaN(departure.valueOf())) {
      throw new import_common123.BadRequestException("Invalid dates");
    }
    if (departure <= arrival) {
      throw new import_common123.BadRequestException("departureDate must be after arrivalDate");
    }
    let siteId = dto.siteId;
    const requestedRigLength = dto.equipment?.length !== void 0 && dto.equipment?.length !== null ? Number(dto.equipment.length) : null;
    if (!siteId && dto.siteClassId) {
      const availableSite = await this.findAvailableSiteInClass(
        campground.id,
        dto.siteClassId,
        arrival,
        departure,
        dto.equipment?.type,
        requestedRigLength,
        dto.needsAccessible
      );
      if (!availableSite) {
        throw new import_common123.ConflictException("No available sites in the selected class for these dates");
      }
      siteId = availableSite;
    }
    if (!siteId) {
      throw new import_common123.BadRequestException("Either siteId or siteClassId must be provided");
    }
    const site = await this.prisma.site.findUnique({
      where: { id: siteId },
      include: { siteClass: true }
    });
    if (!site || site.campgroundId !== campground.id) {
      throw new import_common123.NotFoundException("Site not found");
    }
    const rigCompatible = this.isRigCompatible(
      {
        siteType: site.siteType || site.siteClass?.siteType || "rv",
        rigMaxLength: site.rigMaxLength,
        siteClassRigMaxLength: site.siteClass?.rigMaxLength ?? null
      },
      dto.equipment?.type,
      requestedRigLength
    );
    if (!rigCompatible) {
      throw new import_common123.BadRequestException(
        site.siteType !== "rv" ? "Selected site does not support this equipment type" : `Rig length exceeds maximum for this site (${site.rigMaxLength ?? site.siteClass?.rigMaxLength ?? "unknown"} ft)`
      );
    }
    if (dto.needsAccessible && !(site.accessible || site.siteClass?.accessible)) {
      throw new import_common123.BadRequestException("Accessible site required; please choose an ADA-accessible site.");
    }
    let quote = await this.getQuote(dto.campgroundSlug, {
      siteId,
      arrivalDate: dto.arrivalDate,
      departureDate: dto.departureDate,
      promoCode: dto.promoCode,
      membershipId: dto.membershipId,
      taxWaiverSigned: dto.taxWaiverSigned,
      referralCode: dto.referralCode,
      stayReasonPreset: dto.stayReasonPreset,
      stayReasonOther: dto.stayReasonOther
    });
    const subtotal = quote.totalCents;
    const discountCents = quote.discountCents ?? 0;
    const promotionId = quote.promotionId ?? null;
    const taxesCents = quote.taxesCents ?? 0;
    const totalAfterDiscount = quote.totalAfterDiscountCents ?? Math.max(0, subtotal - discountCents);
    const totalAmount = quote.totalWithTaxesCents ?? totalAfterDiscount + taxesCents;
    const referralProgramId = quote.referralProgramId ?? null;
    const referralDiscountCents = quote.referralDiscountCents ?? 0;
    const referralIncentiveType = quote.referralIncentiveType ?? null;
    const referralIncentiveValue = quote.referralIncentiveValue ?? referralDiscountCents ?? 0;
    const referralSource = quote.referralSource ?? dto.referralSource ?? null;
    const referralChannel = quote.referralChannel ?? dto.referralChannel ?? null;
    const now = /* @__PURE__ */ new Date();
    const leadTimeDays = Math.floor(
      (arrival.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)
    );
    return await this.locks.withLocks([siteId], async () => {
      try {
        if (dto.holdId) {
          const hold = await this.prisma.siteHold.findUnique({ where: { id: dto.holdId } });
          const now2 = /* @__PURE__ */ new Date();
          if (!hold) {
            throw new import_common123.NotFoundException("Hold not found");
          }
          if (hold.status !== "active" || hold.expiresAt && hold.expiresAt <= now2) {
            throw new import_common123.ConflictException("Hold is not active");
          }
          if (hold.siteId !== siteId || hold.campgroundId !== campground.id) {
            throw new import_common123.ConflictException("Hold does not match site/campground");
          }
          if (!(hold.arrivalDate <= arrival && hold.departureDate >= departure)) {
            throw new import_common123.ConflictException("Hold does not cover requested dates");
          }
        }
        const conflictCount = await this.prisma.reservation.count({
          where: {
            siteId,
            status: { not: import_client21.ReservationStatus.cancelled },
            departureDate: { gt: arrival },
            arrivalDate: { lt: departure }
          }
        });
        if (conflictCount > 0) {
          throw new import_common123.ConflictException("Site is no longer available for the selected dates");
        }
        const blackoutCount = await this.prisma.blackoutDate.count({
          where: {
            campgroundId: campground.id,
            OR: [{ siteId }, { siteId: null }],
            startDate: { lt: departure },
            endDate: { gt: arrival }
          }
        });
        if (blackoutCount > 0) {
          throw new import_common123.ConflictException("Site is blacked out for maintenance");
        }
        const maintenanceCount = await this.prisma.maintenanceTicket.count({
          where: {
            siteId,
            isBlocking: true,
            status: { not: "closed" }
          }
        });
        if (maintenanceCount > 0) {
          throw new import_common123.ConflictException("Site is under maintenance");
        }
        let guest = await this.prisma.guest.findUnique({
          where: { email: dto.guest.email }
        });
        if (!guest) {
          guest = await this.prisma.guest.create({
            data: {
              primaryFirstName: dto.guest.firstName,
              primaryLastName: dto.guest.lastName,
              email: dto.guest.email,
              phone: dto.guest.phone,
              postalCode: dto.guest.zipCode
            }
          });
        } else {
          if (!guest.postalCode && dto.guest.zipCode) {
            await this.prisma.guest.update({
              where: { id: guest.id },
              data: { postalCode: dto.guest.zipCode }
            });
          }
        }
        if (!dto.membershipId) {
          const activeMembership = await this.memberships.getActiveMembershipByGuest(guest.id);
          if (activeMembership) {
            quote = await this.getQuote(dto.campgroundSlug, {
              siteId,
              arrivalDate: dto.arrivalDate,
              departureDate: dto.departureDate,
              promoCode: dto.promoCode,
              membershipId: activeMembership.id,
              taxWaiverSigned: dto.taxWaiverSigned,
              referralCode: dto.referralCode,
              stayReasonPreset: dto.stayReasonPreset,
              stayReasonOther: dto.stayReasonOther
            });
          }
        }
        const depositAmount = this.computeDepositRequired(
          campground.depositRule,
          quote.totalWithTaxesCents ?? totalAmount,
          quote.nights,
          campground.depositPercentage
        );
        const reservation = await this.prisma.reservation.create({
          data: {
            campgroundId: campground.id,
            siteId,
            guestId: guest.id,
            arrivalDate: arrival,
            departureDate: departure,
            adults: dto.adults,
            children: dto.children ?? 0,
            status: import_client21.ReservationStatus.pending,
            totalAmount,
            paidAmount: 0,
            balanceAmount: totalAmount,
            depositAmount,
            depositDueDate: /* @__PURE__ */ new Date(),
            paymentStatus: "unpaid",
            baseSubtotal: quote.baseSubtotalCents,
            feesAmount: 0,
            taxesAmount: taxesCents,
            discountsAmount: discountCents > 0 ? discountCents : quote.rulesDeltaCents < 0 ? -quote.rulesDeltaCents : 0,
            promoCode: dto.promoCode || null,
            referralProgramId,
            referralCode: dto.referralCode || null,
            referralSource,
            referralChannel,
            referralIncentiveType,
            referralIncentiveValue,
            source: "online",
            bookedAt: now,
            leadTimeDays,
            additionalGuests: dto.additionalGuests ? JSON.parse(JSON.stringify(dto.additionalGuests)) : null,
            childrenDetails: dto.childrenDetails ? JSON.parse(JSON.stringify(dto.childrenDetails)) : null,
            taxWaiverSigned: dto.taxWaiverSigned || false,
            taxWaiverDate: dto.taxWaiverSigned ? /* @__PURE__ */ new Date() : null,
            stayReasonPreset: dto.stayReasonPreset ?? null,
            stayReasonOther: dto.stayReasonOther ?? null,
            rigType: dto.equipment?.type,
            rigLength: dto.equipment?.length,
            vehiclePlate: dto.equipment?.plateNumber,
            vehicleState: dto.equipment?.plateState
          },
          include: {
            site: true,
            guest: true,
            campground: {
              select: {
                name: true,
                slug: true,
                cancellationPolicyType: true,
                cancellationWindowHours: true,
                cancellationFeeType: true,
                cancellationFeeFlatCents: true,
                cancellationFeePercent: true,
                cancellationNotes: true
              }
            }
          }
        });
        const playbooks = await this.prisma.communicationPlaybook.findMany({
          where: {
            campgroundId: campground.id,
            type: "abandoned_cart",
            enabled: true,
            templateId: { not: null }
          }
        });
        for (const pb of playbooks) {
          const tpl = await this.prisma.communicationTemplate.findFirst({
            where: { id: pb.templateId, status: "approved" }
          });
          if (!tpl) continue;
          const scheduledAt = /* @__PURE__ */ new Date();
          if (pb.offsetMinutes && Number.isFinite(pb.offsetMinutes)) {
            scheduledAt.setMinutes(scheduledAt.getMinutes() + pb.offsetMinutes);
          }
          await this.prisma.communicationPlaybookJob.create({
            data: {
              playbookId: pb.id,
              campgroundId: reservation.campgroundId,
              reservationId: reservation.id,
              guestId: reservation.guestId,
              status: "pending",
              scheduledAt
            }
          });
        }
        if (dto.equipment) {
          await this.prisma.guestEquipment.create({
            data: {
              guestId: guest.id,
              type: dto.equipment.type,
              length: dto.equipment.length,
              plateNumber: dto.equipment.plateNumber,
              plateState: dto.equipment.plateState,
              make: dto.equipment.make,
              model: dto.equipment.model
            }
          });
        }
        if (promotionId) {
          await this.promotionsService.incrementUsage(promotionId);
        }
        const cg = reservation.campground;
        const policyLines = [];
        if (cg.cancellationPolicyType) {
          policyLines.push(`Policy: ${cg.cancellationPolicyType}`);
        }
        if (cg.cancellationWindowHours) {
          policyLines.push(`Window: cancel ${cg.cancellationWindowHours}h before arrival`);
        }
        if (cg.cancellationFeeType === "flat" && cg.cancellationFeeFlatCents) {
          policyLines.push(`Fee: $${(cg.cancellationFeeFlatCents / 100).toFixed(2)}`);
        } else if (cg.cancellationFeeType === "percent" && cg.cancellationFeePercent) {
          policyLines.push(`Fee: ${cg.cancellationFeePercent}%`);
        } else if (cg.cancellationFeeType === "first_night") {
          policyLines.push("Fee: first night");
        }
        if (cg.cancellationNotes) {
          policyLines.push(cg.cancellationNotes);
        }
        const policyBlock = policyLines.length ? `<p><strong>Cancellation</strong><br/>${policyLines.join("<br/>")}</p>` : "";
        await this.emailService.sendEmail({
          to: reservation.guest.email,
          subject: `Reservation Confirmed: ${reservation.campground.name}`,
          html: `
    <h1>Reservation Confirmed</h1>
    <p>Dear ${reservation.guest.primaryFirstName},</p>
    <p>Your reservation at ${reservation.campground.name} has been confirmed.</p>
    <p><strong>Site:</strong> ${reservation.site.siteNumber}</p>
    <p><strong>Arrival:</strong> ${reservation.arrivalDate.toISOString().split("T")[0]}</p>
    <p><strong>Departure:</strong> ${reservation.departureDate.toISOString().split("T")[0]}</p>
    ${policyBlock}
    <p>Thank you for booking with us!</p>
                    `
        });
        if (dto.holdId) {
          await this.prisma.siteHold.update({
            where: { id: dto.holdId },
            data: { status: "released", expiresAt: /* @__PURE__ */ new Date() }
          });
        }
        return {
          ...reservation,
          appliedDiscounts: quote.appliedDiscounts ?? [],
          rejectedDiscounts: quote.rejectedDiscounts ?? [],
          discountCapped: quote.discountCapped ?? false
        };
      } catch (error) {
        console.error("Error creating reservation:", error);
        throw new import_common123.BadRequestException(`Failed to create reservation: ${error.message} `);
      }
    });
  }
  /**
   * Record an abandoned cart signal
   */
  async abandonCart(payload) {
    if (!payload.campgroundId) throw new import_common123.BadRequestException("campgroundId required");
    let guestId = null;
    if (payload.email) {
      const existing = await this.prisma.guest.findFirst({ where: { email: payload.email } });
      if (existing) guestId = existing.id;
      else {
        const guest = await this.prisma.guest.create({
          data: {
            email: payload.email,
            phone: payload.phone || "",
            primaryFirstName: "Guest",
            primaryLastName: "Abandoned"
          }
        });
        guestId = guest.id;
      }
    }
    const queued = this.abandonedCarts.record({
      campgroundId: payload.campgroundId,
      email: payload.email,
      phone: payload.phone,
      abandonedAt: payload.abandonedAt
    });
    await this.enqueueAbandonedCartPlaybooks(payload.campgroundId, guestId, null);
    return { ok: true, queued };
  }
  /**
   * Find an available site in a given site class
   */
  async findAvailableSiteInClass(campgroundId, siteClassId, arrival, departure, rigType, rigLength, needsAccessible) {
    const sites = await this.prisma.site.findMany({
      where: {
        campgroundId,
        siteClassId,
        isActive: true
      },
      select: {
        id: true,
        siteType: true,
        rigMaxLength: true,
        accessible: true,
        siteClass: {
          select: {
            rigMaxLength: true,
            accessible: true,
            siteType: true
          }
        }
      }
    });
    const conflictingReservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        siteId: { in: sites.map((s) => s.id) },
        status: { not: import_client21.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure }
      },
      select: { siteId: true }
    });
    const conflictingSiteIds = new Set(conflictingReservations.map((r) => r.siteId));
    for (const site of sites) {
      if (conflictingSiteIds.has(site.id)) continue;
      if (!this.isRigCompatible(
        {
          siteType: site.siteType || site.siteClass?.siteType || "rv",
          rigMaxLength: site.rigMaxLength,
          siteClassRigMaxLength: site.siteClass?.rigMaxLength ?? null
        },
        rigType,
        rigLength ?? null
      )) {
        continue;
      }
      const accessibleFlag = Boolean(site.accessible || site.siteClass?.accessible);
      if (needsAccessible && !accessibleFlag) {
        continue;
      }
      if (!conflictingSiteIds.has(site.id)) {
        return site.id;
      }
    }
    return null;
  }
  async kioskCheckIn(id, upsellTotalCents) {
    console.log(`[Kiosk] Check -in request for ${id}, upsell: ${upsellTotalCents} `);
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        guest: true,
        campground: { select: { name: true } },
        site: { select: { siteNumber: true } }
      }
    });
    if (!reservation) {
      console.error(`[Kiosk] Reservation ${id} not found`);
      throw new import_common123.NotFoundException("Reservation not found");
    }
    console.log(`[Kiosk] Found reservation: ${reservation.status}, Total: ${reservation.totalAmount}, Paid: ${reservation.paidAmount} `);
    if (reservation.status === import_client21.ReservationStatus.checked_in) {
      console.warn(`[Kiosk] Reservation ${id} already checked in `);
      throw new import_common123.ConflictException("Reservation is already checked in");
    }
    if (reservation.idVerificationRequired) {
      const verified = await this.hasVerifiedId(reservation.id, reservation.guestId);
      if (!verified) {
        throw new import_common123.ConflictException({ reason: "id_verification_required" });
      }
    }
    if (reservation.waiverRequired) {
      const signed = await this.hasSignedWaiver(reservation.id, reservation.guestId);
      if (!signed) {
        const signatureResult = await this.signatures.autoSendForReservation(reservation);
        throw new import_common123.ConflictException({
          reason: "waiver_required",
          signingUrl: signatureResult?.signingUrl
        });
      }
    }
    const newTotal = reservation.totalAmount + upsellTotalCents;
    const balanceDue = newTotal - (reservation.paidAmount || 0);
    console.log(`[Kiosk] New Total: ${newTotal}, Balance Due: ${balanceDue} `);
    try {
      const updated = await this.prisma.reservation.update({
        where: { id },
        data: {
          status: import_client21.ReservationStatus.checked_in,
          checkInAt: /* @__PURE__ */ new Date(),
          feesAmount: { increment: upsellTotalCents },
          totalAmount: newTotal,
          paidAmount: newTotal,
          // Assume full payment successful
          // Add a note about the upsell/kiosk check-in
          notes: reservation.notes ? `${reservation.notes} 
[Kiosk] Checked in.Upsell: $${(upsellTotalCents / 100).toFixed(2)}. Charged card on file.` : `[Kiosk] Checked in.Upsell: $${(upsellTotalCents / 100).toFixed(2)}. Charged card on file.`
        }
      });
      console.log(`[Kiosk] Check -in successful for ${id}`);
      if (balanceDue > 0) {
        try {
          await this.emailService.sendPaymentReceipt({
            guestEmail: reservation.guest.email,
            guestName: `${reservation.guest.primaryFirstName} ${reservation.guest.primaryLastName} `,
            campgroundName: reservation.campground.name,
            amountCents: balanceDue,
            paymentMethod: "Card on file",
            reservationId: reservation.id,
            siteNumber: reservation.site?.siteNumber,
            arrivalDate: reservation.arrivalDate,
            departureDate: reservation.departureDate,
            source: "kiosk"
          });
        } catch (emailError) {
          console.error("[Kiosk] Failed to send payment receipt email:", emailError);
        }
      }
      try {
        await this.accessControl.autoGrantForReservation(id);
      } catch (err) {
        console.error(`[Kiosk] Access grant failed for ${id}: `, err);
      }
      return updated;
    } catch (e) {
      console.error(`[Kiosk] Update failed for ${id}: `, e);
      throw e;
    }
  }
  async getReservation(id) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id },
      include: {
        guest: {
          select: { primaryFirstName: true, primaryLastName: true }
        },
        campground: {
          select: { name: true, slug: true, city: true, state: true, timezone: true }
        },
        site: {
          include: {
            siteClass: {
              select: { name: true, photos: true }
            }
          }
        }
      }
    });
    if (!reservation) {
      throw new import_common123.NotFoundException("Reservation not found");
    }
    let discountsInfo = { appliedDiscounts: [], rejectedDiscounts: [], discountCapped: false };
    try {
      const membership = await this.memberships.getActiveMembershipByGuest(reservation.guestId);
      const dateOnly = (d) => d.toISOString().split("T")[0];
      const quote = await this.getQuote(reservation.campground.slug, {
        siteId: reservation.siteId,
        arrivalDate: dateOnly(reservation.arrivalDate),
        departureDate: dateOnly(reservation.departureDate),
        promoCode: reservation.promoCode ?? void 0,
        membershipId: membership?.id,
        taxWaiverSigned: reservation.taxWaiverSigned ?? false
      });
      discountsInfo = {
        appliedDiscounts: quote.appliedDiscounts ?? [],
        rejectedDiscounts: quote.rejectedDiscounts ?? [],
        discountCapped: quote.discountCapped ?? false
      };
    } catch (error) {
      console.warn("Failed to recompute reservation discounts", error);
    }
    return { ...reservation, ...discountsInfo };
  }
};
PublicReservationsService = __decorateClass([
  (0, import_common123.Injectable)()
], PublicReservationsService);

// src/abandoned-cart/abandoned-cart.module.ts
var import_common126 = require("@nestjs/common");

// src/abandoned-cart/abandoned-cart.service.ts
var import_common124 = require("@nestjs/common");
var import_crypto14 = require("crypto");
var AbandonedCartService = class {
  constructor() {
    this.queue = [];
    this.MAX_ENTRIES = 200;
  }
  normalizeTimestamp(value) {
    const d = value ? new Date(value) : /* @__PURE__ */ new Date();
    return Number.isFinite(d.valueOf()) ? d.toISOString() : (/* @__PURE__ */ new Date()).toISOString();
  }
  deriveChannel(email, phone) {
    if (email) return "email";
    if (phone) return "sms";
    return "unknown";
  }
  record(payload) {
    const abandonedAt = this.normalizeTimestamp(payload.abandonedAt);
    const lastActivityAt = abandonedAt;
    const channel = this.deriveChannel(payload.email, payload.phone);
    const existing = this.queue.find(
      (entry2) => entry2.campgroundId === payload.campgroundId && (payload.email && entry2.email === payload.email || payload.phone && entry2.phone === payload.phone)
    );
    if (existing) {
      existing.lastActivityAt = this.normalizeTimestamp();
      existing.abandonedAt = existing.abandonedAt || abandonedAt;
      existing.email = existing.email || payload.email || null;
      existing.phone = existing.phone || payload.phone || null;
      existing.channel = existing.channel === "unknown" ? channel : existing.channel;
      existing.status = "queued";
      return existing;
    }
    const entry = {
      id: (0, import_crypto14.randomUUID)(),
      campgroundId: payload.campgroundId,
      email: payload.email ?? null,
      phone: payload.phone ?? null,
      channel,
      abandonedAt,
      lastActivityAt,
      status: "queued",
      notes: null
    };
    this.queue.unshift(entry);
    if (this.queue.length > this.MAX_ENTRIES) {
      this.queue = this.queue.slice(0, this.MAX_ENTRIES);
    }
    return entry;
  }
  list(campgroundId) {
    const filtered = campgroundId ? this.queue.filter((q) => q.campgroundId === campgroundId) : this.queue;
    return filtered.sort((a, b) => b.lastActivityAt.localeCompare(a.lastActivityAt));
  }
  markContacted(id, note) {
    const entry = this.queue.find((q) => q.id === id);
    if (!entry) return null;
    entry.status = "contacted";
    entry.lastActivityAt = this.normalizeTimestamp();
    entry.notes = note ?? entry.notes ?? null;
    return entry;
  }
};
AbandonedCartService = __decorateClass([
  (0, import_common124.Injectable)()
], AbandonedCartService);

// src/abandoned-cart/abandoned-cart.controller.ts
var import_common125 = require("@nestjs/common");
var AbandonedCartController = class {
  constructor(abandonedCarts) {
    this.abandonedCarts = abandonedCarts;
  }
  list(campgroundId) {
    if (!campgroundId) throw new import_common125.BadRequestException("campgroundId is required");
    return this.abandonedCarts.list(campgroundId);
  }
  queue(body) {
    if (!body.campgroundId) throw new import_common125.BadRequestException("campgroundId is required");
    return this.abandonedCarts.record({
      campgroundId: body.campgroundId,
      email: body.email,
      phone: body.phone,
      abandonedAt: body.abandonedAt
    });
  }
  markContacted(id, body) {
    const updated = this.abandonedCarts.markContacted(id, body?.note);
    if (!updated) {
      throw new import_common125.NotFoundException("Abandoned cart not found");
    }
    return updated;
  }
};
__decorateClass([
  (0, import_common125.UseGuards)(JwtAuthGuard),
  (0, import_common125.Get)("abandoned-carts"),
  __decorateParam(0, (0, import_common125.Query)("campgroundId"))
], AbandonedCartController.prototype, "list", 1);
__decorateClass([
  (0, import_common125.UseGuards)(JwtAuthGuard),
  (0, import_common125.Post)("abandoned-carts/queue"),
  __decorateParam(0, (0, import_common125.Body)())
], AbandonedCartController.prototype, "queue", 1);
__decorateClass([
  (0, import_common125.UseGuards)(JwtAuthGuard),
  (0, import_common125.Post)("abandoned-carts/:id/contact"),
  __decorateParam(0, (0, import_common125.Param)("id")),
  __decorateParam(1, (0, import_common125.Body)())
], AbandonedCartController.prototype, "markContacted", 1);
AbandonedCartController = __decorateClass([
  (0, import_common125.Controller)()
], AbandonedCartController);

// src/abandoned-cart/abandoned-cart.module.ts
var AbandonedCartModule = class {
};
AbandonedCartModule = __decorateClass([
  (0, import_common126.Module)({
    imports: [],
    controllers: [AbandonedCartController],
    providers: [AbandonedCartService],
    exports: [AbandonedCartService]
  })
], AbandonedCartModule);

// src/memberships/memberships.module.ts
var import_common129 = require("@nestjs/common");

// src/memberships/memberships.service.ts
var import_common127 = require("@nestjs/common");
var import_date_fns = require("date-fns");
var MembershipsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  // Membership Types
  async createType(campgroundId, data) {
    return this.prisma.membershipType.create({
      data: {
        ...data,
        campgroundId
      }
    });
  }
  async findAllTypes(campgroundId) {
    return this.prisma.membershipType.findMany({
      where: { campgroundId },
      orderBy: { price: "asc" }
    });
  }
  async updateType(id, data) {
    return this.prisma.membershipType.update({
      where: { id },
      data
    });
  }
  async deleteType(id) {
    return this.prisma.membershipType.delete({
      where: { id }
    });
  }
  // Guest Memberships
  async purchaseMembership(guestId, membershipTypeId) {
    const type = await this.prisma.membershipType.findUnique({ where: { id: membershipTypeId } });
    if (!type) throw new import_common127.NotFoundException("Membership type not found");
    const startDate = /* @__PURE__ */ new Date();
    const endDate = (0, import_date_fns.addDays)(startDate, type.durationDays);
    return this.prisma.guestMembership.create({
      data: {
        guestId,
        membershipTypeId,
        startDate,
        endDate,
        purchaseAmount: type.price,
        status: "active"
      }
    });
  }
  async getActiveMembershipByGuest(guestId) {
    const now = /* @__PURE__ */ new Date();
    return this.prisma.guestMembership.findFirst({
      where: {
        guestId,
        status: "active",
        endDate: { gt: now }
      },
      include: { membershipType: true },
      orderBy: { endDate: "desc" }
    });
  }
  async getActiveMembershipById(membershipId) {
    const now = /* @__PURE__ */ new Date();
    return this.prisma.guestMembership.findFirst({
      where: {
        id: membershipId,
        status: "active",
        endDate: { gt: now }
      },
      include: { membershipType: true }
    });
  }
  async getGuestMemberships(guestId) {
    return this.prisma.guestMembership.findMany({
      where: { guestId },
      include: { membershipType: true },
      orderBy: { startDate: "desc" }
    });
  }
};
MembershipsService = __decorateClass([
  (0, import_common127.Injectable)()
], MembershipsService);

// src/memberships/memberships.controller.ts
var import_common128 = require("@nestjs/common");
var MembershipsController = class {
  constructor(membershipsService) {
    this.membershipsService = membershipsService;
  }
  createType(createTypeDto) {
    const { campgroundId, ...data } = createTypeDto;
    return this.membershipsService.createType(campgroundId, data);
  }
  findAllTypes(campgroundId) {
    return this.membershipsService.findAllTypes(campgroundId);
  }
  updateType(id, updateTypeDto) {
    return this.membershipsService.updateType(id, updateTypeDto);
  }
  deleteType(id) {
    return this.membershipsService.deleteType(id);
  }
  purchase(purchaseDto) {
    return this.membershipsService.purchaseMembership(purchaseDto.guestId, purchaseDto.membershipTypeId);
  }
  getGuestMemberships(guestId) {
    return this.membershipsService.getGuestMemberships(guestId);
  }
};
__decorateClass([
  (0, import_common128.Post)("types"),
  __decorateParam(0, (0, import_common128.Body)())
], MembershipsController.prototype, "createType", 1);
__decorateClass([
  (0, import_common128.Get)("types"),
  __decorateParam(0, (0, import_common128.Query)("campgroundId"))
], MembershipsController.prototype, "findAllTypes", 1);
__decorateClass([
  (0, import_common128.Patch)("types/:id"),
  __decorateParam(0, (0, import_common128.Param)("id")),
  __decorateParam(1, (0, import_common128.Body)())
], MembershipsController.prototype, "updateType", 1);
__decorateClass([
  (0, import_common128.Delete)("types/:id"),
  __decorateParam(0, (0, import_common128.Param)("id"))
], MembershipsController.prototype, "deleteType", 1);
__decorateClass([
  (0, import_common128.Post)("purchase"),
  __decorateParam(0, (0, import_common128.Body)())
], MembershipsController.prototype, "purchase", 1);
__decorateClass([
  (0, import_common128.Get)("guest/:guestId"),
  __decorateParam(0, (0, import_common128.Param)("guestId"))
], MembershipsController.prototype, "getGuestMemberships", 1);
MembershipsController = __decorateClass([
  (0, import_common128.UseGuards)(JwtAuthGuard),
  (0, import_common128.Controller)("memberships")
], MembershipsController);

// src/memberships/memberships.module.ts
var MembershipsModule = class {
};
MembershipsModule = __decorateClass([
  (0, import_common129.Module)({
    controllers: [MembershipsController],
    providers: [MembershipsService, PrismaService],
    exports: [MembershipsService]
  })
], MembershipsModule);

// src/public-reservations/public-reservations.module.ts
var PublicReservationsModule = class {
};
PublicReservationsModule = __decorateClass([
  (0, import_common130.Module)({
    imports: [PrismaModule, RedisModule, PromotionsModule, AbandonedCartModule, MembershipsModule, SignaturesModule, AccessControlModule],
    controllers: [PublicReservationsController],
    providers: [PublicReservationsService]
  })
], PublicReservationsModule);

// src/messages/messages.module.ts
var import_common133 = require("@nestjs/common");

// src/messages/messages.controller.ts
var import_common131 = require("@nestjs/common");
var import_passport7 = require("@nestjs/passport");
var MessagesController = class {
  constructor(messagesService) {
    this.messagesService = messagesService;
  }
  async listMessages(reservationId) {
    return this.messagesService.listByReservation(reservationId);
  }
  async createMessage(reservationId, body) {
    return this.messagesService.create(reservationId, body);
  }
  async markAsRead(reservationId, senderType) {
    return this.messagesService.markAllAsReadForReservation(reservationId, senderType);
  }
  async getUnreadCount(campgroundId) {
    return this.messagesService.getUnreadCount(campgroundId);
  }
  async listGuestMessages(reservationId, req) {
    return this.messagesService.listByReservation(reservationId);
  }
  async createGuestMessage(reservationId, body, req) {
    const guestId = req.user.id;
    return this.messagesService.create(reservationId, {
      ...body,
      guestId,
      senderType: "guest"
    });
  }
};
__decorateClass([
  (0, import_common131.Get)("reservations/:id/messages"),
  __decorateParam(0, (0, import_common131.Param)("id"))
], MessagesController.prototype, "listMessages", 1);
__decorateClass([
  (0, import_common131.Post)("reservations/:id/messages"),
  __decorateParam(0, (0, import_common131.Param)("id")),
  __decorateParam(1, (0, import_common131.Body)())
], MessagesController.prototype, "createMessage", 1);
__decorateClass([
  (0, import_common131.Patch)("reservations/:id/messages/read"),
  __decorateParam(0, (0, import_common131.Param)("id")),
  __decorateParam(1, (0, import_common131.Body)("senderType"))
], MessagesController.prototype, "markAsRead", 1);
__decorateClass([
  (0, import_common131.Get)("campgrounds/:campgroundId/messages/unread-count"),
  __decorateParam(0, (0, import_common131.Param)("campgroundId"))
], MessagesController.prototype, "getUnreadCount", 1);
__decorateClass([
  (0, import_common131.Get)("portal/reservations/:id/messages"),
  (0, import_common131.UseGuards)((0, import_passport7.AuthGuard)("guest-jwt")),
  __decorateParam(0, (0, import_common131.Param)("id")),
  __decorateParam(1, (0, import_common131.Request)())
], MessagesController.prototype, "listGuestMessages", 1);
__decorateClass([
  (0, import_common131.Post)("portal/reservations/:id/messages"),
  (0, import_common131.UseGuards)((0, import_passport7.AuthGuard)("guest-jwt")),
  __decorateParam(0, (0, import_common131.Param)("id")),
  __decorateParam(1, (0, import_common131.Body)()),
  __decorateParam(2, (0, import_common131.Request)())
], MessagesController.prototype, "createGuestMessage", 1);
MessagesController = __decorateClass([
  (0, import_common131.Controller)()
], MessagesController);

// src/messages/messages.service.ts
var import_common132 = require("@nestjs/common");
var MessagesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async listByReservation(reservationId) {
    return this.prisma.message.findMany({
      where: { reservationId },
      orderBy: { createdAt: "asc" },
      include: {
        guest: {
          select: {
            id: true,
            primaryFirstName: true,
            primaryLastName: true
          }
        }
      }
    });
  }
  async create(reservationId, data) {
    const reservation = await this.prisma.reservation.findUniqueOrThrow({
      where: { id: reservationId },
      select: { campgroundId: true, guestId: true }
    });
    return this.prisma.message.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId,
        guestId: data.guestId,
        senderType: data.senderType,
        content: data.content
      },
      include: {
        guest: {
          select: {
            id: true,
            primaryFirstName: true,
            primaryLastName: true
          }
        }
      }
    });
  }
  async markAsRead(messageId) {
    return this.prisma.message.update({
      where: { id: messageId },
      data: { readAt: /* @__PURE__ */ new Date() }
    });
  }
  async markAllAsReadForReservation(reservationId, senderType) {
    const oppositeType = senderType === "guest" ? "staff" : "guest";
    return this.prisma.message.updateMany({
      where: {
        reservationId,
        senderType: oppositeType,
        readAt: null
      },
      data: { readAt: /* @__PURE__ */ new Date() }
    });
  }
  async getUnreadCount(campgroundId) {
    const count = await this.prisma.message.count({
      where: {
        campgroundId,
        senderType: "guest",
        readAt: null
      }
    });
    return { unreadCount: count };
  }
  async getUnreadCountForReservation(reservationId) {
    const count = await this.prisma.message.count({
      where: {
        reservationId,
        senderType: "guest",
        readAt: null
      }
    });
    return { unreadCount: count };
  }
};
MessagesService = __decorateClass([
  (0, import_common132.Injectable)()
], MessagesService);

// src/messages/messages.module.ts
var MessagesModule = class {
};
MessagesModule = __decorateClass([
  (0, import_common133.Module)({
    imports: [PrismaModule],
    controllers: [MessagesController],
    providers: [MessagesService],
    exports: [MessagesService]
  })
], MessagesModule);

// src/events/events.module.ts
var import_common137 = require("@nestjs/common");

// src/events/events.controller.ts
var import_common135 = require("@nestjs/common");
var import_shared2 = require("@campreserv/shared");

// src/pipes/zod-validation.pipe.ts
var import_common134 = require("@nestjs/common");
var ZodValidationPipe = class {
  constructor(schema) {
    this.schema = schema;
  }
  transform(value, metadata) {
    try {
      return this.schema.parse(value);
    } catch (error) {
      throw new import_common134.BadRequestException("Validation failed");
    }
  }
};

// src/events/events.controller.ts
var import_passport8 = require("@nestjs/passport");
var EventsController = class {
  constructor(eventsService) {
    this.eventsService = eventsService;
  }
  async create(createEventDto) {
    const cleaned = {
      ...createEventDto,
      parentEventId: createEventDto.parentEventId || void 0,
      recurrenceEndDate: createEventDto.recurrenceEndDate || void 0,
      recurrenceDays: createEventDto.recurrenceDays || void 0
    };
    return this.eventsService.create(cleaned);
  }
  async findAll(campgroundId, start, end) {
    return this.eventsService.findAll(campgroundId, start, end);
  }
  async findOne(id) {
    return this.eventsService.findOne(id);
  }
  async update(id, updateEventDto) {
    return this.eventsService.update(id, updateEventDto);
  }
  async remove(id) {
    return this.eventsService.remove(id);
  }
  async listPublic(campgroundId, start, end) {
    return this.eventsService.findAll(campgroundId, start, end);
  }
};
__decorateClass([
  (0, import_common135.UseGuards)(JwtAuthGuard),
  (0, import_common135.Post)(),
  __decorateParam(0, (0, import_common135.Body)(new ZodValidationPipe(import_shared2.CreateEventSchema)))
], EventsController.prototype, "create", 1);
__decorateClass([
  (0, import_common135.UseGuards)(JwtAuthGuard),
  (0, import_common135.Get)(),
  __decorateParam(0, (0, import_common135.Query)("campgroundId")),
  __decorateParam(1, (0, import_common135.Query)("start")),
  __decorateParam(2, (0, import_common135.Query)("end"))
], EventsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common135.UseGuards)(JwtAuthGuard),
  (0, import_common135.Get)(":id"),
  __decorateParam(0, (0, import_common135.Param)("id"))
], EventsController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common135.UseGuards)(JwtAuthGuard),
  (0, import_common135.Patch)(":id"),
  __decorateParam(0, (0, import_common135.Param)("id")),
  __decorateParam(1, (0, import_common135.Body)())
], EventsController.prototype, "update", 1);
__decorateClass([
  (0, import_common135.UseGuards)(JwtAuthGuard),
  (0, import_common135.Delete)(":id"),
  __decorateParam(0, (0, import_common135.Param)("id"))
], EventsController.prototype, "remove", 1);
__decorateClass([
  (0, import_common135.UseGuards)((0, import_passport8.AuthGuard)("guest-jwt")),
  (0, import_common135.Get)("public/list"),
  __decorateParam(0, (0, import_common135.Query)("campgroundId")),
  __decorateParam(1, (0, import_common135.Query)("start")),
  __decorateParam(2, (0, import_common135.Query)("end"))
], EventsController.prototype, "listPublic", 1);
EventsController = __decorateClass([
  (0, import_common135.Controller)("events")
], EventsController);

// src/events/events.service.ts
var import_common136 = require("@nestjs/common");
var EventsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(data) {
    return this.prisma.event.create({
      data: {
        ...data,
        startDate: new Date(data.startDate),
        endDate: data.endDate ? new Date(data.endDate) : null,
        recurrenceEndDate: data.recurrenceEndDate ? new Date(data.recurrenceEndDate) : null,
        recurrenceDays: data.recurrenceDays ?? []
      }
    });
  }
  async findAll(campgroundId, start, end) {
    const where = { campgroundId };
    if (start && end) {
      where.startDate = {
        gte: new Date(start),
        lte: new Date(end)
      };
    }
    return this.prisma.event.findMany({
      where,
      include: {
        children: {
          where: { isCancelled: false },
          orderBy: { startDate: "asc" }
        }
      },
      orderBy: { startDate: "asc" }
    });
  }
  // Get all events for a holiday/themed weekend
  async findByParent(parentEventId) {
    return this.prisma.event.findMany({
      where: { parentEventId },
      orderBy: { startDate: "asc" }
    });
  }
  // Get public events with expanded recurring instances
  async findPublic(campgroundId, start, end) {
    const events = await this.prisma.event.findMany({
      where: {
        campgroundId,
        isPublished: true,
        isCancelled: false,
        OR: [
          // Non-recurring events in range
          {
            isRecurring: false,
            startDate: { gte: start, lte: end }
          },
          // Recurring events that overlap the range
          {
            isRecurring: true,
            startDate: { lte: end },
            OR: [
              { recurrenceEndDate: null },
              { recurrenceEndDate: { gte: start } }
            ]
          }
        ]
      },
      include: {
        children: {
          where: { isPublished: true, isCancelled: false },
          orderBy: { startDate: "asc" }
        }
      },
      orderBy: { startDate: "asc" }
    });
    const result = [];
    for (const event of events) {
      if (event.isRecurring && event.recurrenceDays.length > 0) {
        const instances = this.generateRecurringInstances(event, start, end);
        result.push(...instances);
      } else {
        result.push(event);
      }
    }
    return result.sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
  }
  // Generate individual instances for recurring events
  generateRecurringInstances(event, start, end) {
    const instances = [];
    const recurrenceEnd = event.recurrenceEndDate ? new Date(event.recurrenceEndDate) : end;
    const effectiveEnd = recurrenceEnd < end ? recurrenceEnd : end;
    const current = new Date(start);
    while (current <= effectiveEnd) {
      const dayOfWeek = current.getDay();
      if (event.recurrenceDays.includes(dayOfWeek)) {
        instances.push({
          ...event,
          id: `${event.id}_${current.toISOString().split("T")[0]}`,
          originalEventId: event.id,
          startDate: new Date(current),
          endDate: event.endDate ? new Date(current.getTime() + (new Date(event.endDate).getTime() - new Date(event.startDate).getTime())) : null,
          isRecurringInstance: true
        });
      }
      current.setDate(current.getDate() + 1);
    }
    return instances;
  }
  // Helper to format recurrence as human-readable string
  getRecurrenceDescription(recurrenceDays) {
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const shortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    if (recurrenceDays.length === 0) return "";
    if (recurrenceDays.length === 7) return "Daily";
    if (recurrenceDays.length === 2 && recurrenceDays.includes(0) && recurrenceDays.includes(6)) return "Weekends";
    if (recurrenceDays.length === 5 && !recurrenceDays.includes(0) && !recurrenceDays.includes(6)) return "Weekdays";
    if (recurrenceDays.length === 1) return `Every ${dayNames[recurrenceDays[0]]}`;
    return recurrenceDays.map((d) => shortDays[d]).join(", ");
  }
  async findOne(id) {
    const event = await this.prisma.event.findUnique({
      where: { id },
      include: {
        children: { orderBy: { startDate: "asc" } },
        parent: true
      }
    });
    if (!event) throw new import_common136.NotFoundException(`Event with ID ${id} not found`);
    return event;
  }
  async update(id, data) {
    const updateData = { ...data };
    if (data.startDate) updateData.startDate = new Date(data.startDate);
    if (data.endDate) updateData.endDate = new Date(data.endDate);
    if (data.recurrenceEndDate) updateData.recurrenceEndDate = new Date(data.recurrenceEndDate);
    if (data.recurrenceEndDate === null) updateData.recurrenceEndDate = null;
    return this.prisma.event.update({
      where: { id },
      data: updateData
    });
  }
  async remove(id) {
    return this.prisma.event.delete({ where: { id } });
  }
};
EventsService = __decorateClass([
  (0, import_common136.Injectable)()
], EventsService);

// src/events/events.module.ts
var EventsModule = class {
};
EventsModule = __decorateClass([
  (0, import_common137.Module)({
    imports: [PrismaModule],
    controllers: [EventsController],
    providers: [EventsService],
    exports: [EventsService]
  })
], EventsModule);

// src/internal-messages/internal-messages.module.ts
var import_common140 = require("@nestjs/common");

// src/internal-messages/internal-messages.service.ts
var import_common138 = require("@nestjs/common");
var InternalMessagesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(content, senderId, conversationId) {
    return this.prisma.internalMessage.create({
      data: {
        content,
        senderId,
        conversationId
      },
      include: {
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
  }
  async findAll(conversationId, limit = 50) {
    const messages = await this.prisma.internalMessage.findMany({
      where: { conversationId },
      take: limit,
      orderBy: {
        createdAt: "desc"
      },
      select: {
        id: true,
        content: true,
        senderId: true,
        createdAt: true,
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    return messages.reverse();
  }
};
InternalMessagesService = __decorateClass([
  (0, import_common138.Injectable)()
], InternalMessagesService);

// src/internal-messages/internal-messages.controller.ts
var import_common139 = require("@nestjs/common");
var InternalMessagesController = class {
  constructor(internalMessagesService) {
    this.internalMessagesService = internalMessagesService;
  }
  create(req, body) {
    return this.internalMessagesService.create(body.content, req.user.id, body.conversationId);
  }
  findAll(conversationId, limit) {
    return this.internalMessagesService.findAll(conversationId, limit ? parseInt(limit, 10) : void 0);
  }
};
__decorateClass([
  (0, import_common139.Post)(),
  __decorateParam(0, (0, import_common139.Request)()),
  __decorateParam(1, (0, import_common139.Body)())
], InternalMessagesController.prototype, "create", 1);
__decorateClass([
  (0, import_common139.Get)(),
  __decorateParam(0, (0, import_common139.Query)("conversationId")),
  __decorateParam(1, (0, import_common139.Query)("limit"))
], InternalMessagesController.prototype, "findAll", 1);
InternalMessagesController = __decorateClass([
  (0, import_common139.Controller)("internal-messages"),
  (0, import_common139.UseGuards)(JwtAuthGuard)
], InternalMessagesController);

// src/internal-messages/internal-messages.module.ts
var InternalMessagesModule = class {
};
InternalMessagesModule = __decorateClass([
  (0, import_common140.Module)({
    controllers: [InternalMessagesController],
    providers: [InternalMessagesService, PrismaService]
  })
], InternalMessagesModule);

// src/guest-equipment/guest-equipment.module.ts
var import_common143 = require("@nestjs/common");

// src/guest-equipment/guest-equipment.service.ts
var import_common141 = require("@nestjs/common");
var GuestEquipmentService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(guestId, data) {
    return this.prisma.guestEquipment.create({
      data: {
        guestId,
        ...data
      }
    });
  }
  async findAll(guestId) {
    return this.prisma.guestEquipment.findMany({
      where: { guestId },
      orderBy: { createdAt: "desc" }
    });
  }
  async update(id, data) {
    return this.prisma.guestEquipment.update({
      where: { id },
      data
    });
  }
  async remove(id) {
    return this.prisma.guestEquipment.delete({
      where: { id }
    });
  }
};
GuestEquipmentService = __decorateClass([
  (0, import_common141.Injectable)()
], GuestEquipmentService);

// src/guest-equipment/guest-equipment.controller.ts
var import_common142 = require("@nestjs/common");
var GuestEquipmentController = class {
  constructor(guestEquipmentService) {
    this.guestEquipmentService = guestEquipmentService;
  }
  create(guestId, body) {
    return this.guestEquipmentService.create(guestId, body);
  }
  findAll(guestId) {
    return this.guestEquipmentService.findAll(guestId);
  }
  update(id, body) {
    return this.guestEquipmentService.update(id, body);
  }
  remove(id) {
    return this.guestEquipmentService.remove(id);
  }
};
__decorateClass([
  (0, import_common142.Post)(":guestId/equipment"),
  __decorateParam(0, (0, import_common142.Param)("guestId")),
  __decorateParam(1, (0, import_common142.Body)())
], GuestEquipmentController.prototype, "create", 1);
__decorateClass([
  (0, import_common142.Get)(":guestId/equipment"),
  __decorateParam(0, (0, import_common142.Param)("guestId"))
], GuestEquipmentController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common142.Patch)("equipment/:id"),
  __decorateParam(0, (0, import_common142.Param)("id")),
  __decorateParam(1, (0, import_common142.Body)())
], GuestEquipmentController.prototype, "update", 1);
__decorateClass([
  (0, import_common142.Delete)("equipment/:id"),
  __decorateParam(0, (0, import_common142.Param)("id"))
], GuestEquipmentController.prototype, "remove", 1);
GuestEquipmentController = __decorateClass([
  (0, import_common142.UseGuards)(JwtAuthGuard),
  (0, import_common142.Controller)("guests")
], GuestEquipmentController);

// src/guest-equipment/guest-equipment.module.ts
var GuestEquipmentModule = class {
};
GuestEquipmentModule = __decorateClass([
  (0, import_common143.Module)({
    imports: [PrismaModule],
    controllers: [GuestEquipmentController],
    providers: [GuestEquipmentService],
    exports: [GuestEquipmentService]
  })
], GuestEquipmentModule);

// src/repeat-charges/repeat-charges.module.ts
var import_common146 = require("@nestjs/common");

// src/repeat-charges/repeat-charges.service.ts
var import_common144 = require("@nestjs/common");
var import_client22 = require("@prisma/client");
var import_date_fns2 = require("date-fns");
var RepeatChargesService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async generateCharges(reservationId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      include: {
        seasonalRate: true,
        repeatCharges: true
      }
    });
    if (!reservation) throw new import_common144.NotFoundException("Reservation not found");
    if (!reservation.seasonalRate) throw new import_common144.BadRequestException("Reservation is not linked to a seasonal rate");
    const { paymentSchedule, amount, offseasonAmount, offseasonInterval } = reservation.seasonalRate;
    const arrival = new Date(reservation.arrivalDate);
    const departure = new Date(reservation.departureDate);
    if (reservation.repeatCharges.length > 0) {
      return reservation.repeatCharges;
    }
    const charges = [];
    let currentDate = new Date(arrival);
    if (paymentSchedule === import_client22.PaymentSchedule.monthly) {
      while (currentDate < departure) {
        charges.push({
          dueDate: new Date(currentDate),
          amount
          // Monthly rate
        });
        currentDate = (0, import_date_fns2.addMonths)(currentDate, 1);
      }
    } else if (paymentSchedule === import_client22.PaymentSchedule.weekly) {
      while (currentDate < departure) {
        charges.push({
          dueDate: new Date(currentDate),
          amount
          // Weekly rate
        });
        currentDate = (0, import_date_fns2.addWeeks)(currentDate, 1);
      }
    } else if (paymentSchedule === import_client22.PaymentSchedule.offseason_installments) {
      const interval = offseasonInterval || 1;
      const installmentAmount = offseasonAmount || amount;
      while (currentDate < departure) {
        charges.push({
          dueDate: new Date(currentDate),
          amount: installmentAmount
        });
        currentDate = (0, import_date_fns2.addMonths)(currentDate, interval);
      }
    }
    const createdCharges = [];
    for (const charge of charges) {
      const created = await this.prisma.repeatCharge.create({
        data: {
          reservationId,
          dueDate: charge.dueDate,
          amount: charge.amount,
          status: import_client22.ChargeStatus.pending
        }
      });
      createdCharges.push(created);
    }
    return createdCharges;
  }
  async getCharges(reservationId) {
    return this.prisma.repeatCharge.findMany({
      where: { reservationId },
      orderBy: { dueDate: "asc" }
    });
  }
  async getAllCharges(campgroundId) {
    return this.prisma.repeatCharge.findMany({
      where: {
        reservation: {
          campgroundId
        }
      },
      include: {
        reservation: {
          include: {
            guest: true,
            site: true
          }
        }
      },
      orderBy: { dueDate: "asc" }
    });
  }
  async processCharge(chargeId) {
    const charge = await this.prisma.repeatCharge.findUnique({
      where: { id: chargeId },
      include: { reservation: true }
    });
    if (!charge) throw new import_common144.NotFoundException("Charge not found");
    if (charge.status === import_client22.ChargeStatus.paid) throw new import_common144.BadRequestException("Charge already paid");
    const updated = await this.prisma.repeatCharge.update({
      where: { id: chargeId },
      data: {
        status: import_client22.ChargeStatus.paid,
        paidAt: /* @__PURE__ */ new Date()
      }
    });
    await this.prisma.payment.create({
      data: {
        campgroundId: charge.reservation.campgroundId,
        reservationId: charge.reservationId,
        amountCents: charge.amount,
        method: "card",
        // stored card
        direction: "charge",
        note: `Repeat charge for ${charge.dueDate.toISOString().split("T")[0]}`
      }
    });
    await this.prisma.reservation.update({
      where: { id: charge.reservationId },
      data: {
        paidAmount: { increment: charge.amount }
      }
    });
    return updated;
  }
};
RepeatChargesService = __decorateClass([
  (0, import_common144.Injectable)()
], RepeatChargesService);

// src/repeat-charges/repeat-charges.controller.ts
var import_common145 = require("@nestjs/common");
var RepeatChargesController = class {
  constructor(repeatChargesService) {
    this.repeatChargesService = repeatChargesService;
  }
  findAll(campgroundId) {
    return this.repeatChargesService.getAllCharges(campgroundId);
  }
  generate(id) {
    return this.repeatChargesService.generateCharges(id);
  }
  process(id) {
    return this.repeatChargesService.processCharge(id);
  }
};
__decorateClass([
  (0, import_common145.Get)(),
  __decorateParam(0, (0, import_common145.Query)("campgroundId"))
], RepeatChargesController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common145.Post)("reservation/:id/generate"),
  __decorateParam(0, (0, import_common145.Param)("id"))
], RepeatChargesController.prototype, "generate", 1);
__decorateClass([
  (0, import_common145.Post)(":id/process"),
  __decorateParam(0, (0, import_common145.Param)("id"))
], RepeatChargesController.prototype, "process", 1);
RepeatChargesController = __decorateClass([
  (0, import_common145.UseGuards)(JwtAuthGuard),
  (0, import_common145.Controller)("repeat-charges")
], RepeatChargesController);

// src/repeat-charges/repeat-charges.module.ts
var RepeatChargesModule = class {
};
RepeatChargesModule = __decorateClass([
  (0, import_common146.Module)({
    imports: [ReservationsModule, SeasonalRatesModule],
    controllers: [RepeatChargesController],
    providers: [RepeatChargesService, PrismaService],
    exports: [RepeatChargesService]
  })
], RepeatChargesModule);

// src/activities/activities.module.ts
var import_common149 = require("@nestjs/common");

// src/activities/activities.service.ts
var import_common147 = require("@nestjs/common");
var ActivitiesService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.capacityStore = {
      "demo-activity": {
        capacity: 20,
        booked: 18,
        waitlistEnabled: true,
        waitlist: [
          { id: "wl-1", guestName: "Jordan Creek", partySize: 2, contact: "jordan@example.com", addedAt: (/* @__PURE__ */ new Date()).toISOString() }
        ],
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  }
  ensureCapacityRecord(activityId) {
    if (!this.capacityStore[activityId]) {
      this.capacityStore[activityId] = {
        capacity: 16,
        booked: 8,
        waitlistEnabled: true,
        waitlist: [],
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    return this.capacityStore[activityId];
  }
  toSnapshot(activityId, record) {
    const remaining = Math.max(record.capacity - record.booked, 0);
    const overageAmount = Math.max(record.booked - record.capacity, 0);
    return {
      activityId,
      capacity: record.capacity,
      booked: record.booked,
      remaining,
      waitlistEnabled: record.waitlistEnabled,
      waitlistCount: record.waitlist.length,
      overage: overageAmount > 0,
      overageAmount,
      lastUpdated: record.lastUpdated
    };
  }
  async getCapacitySnapshot(activityId) {
    const record = this.ensureCapacityRecord(activityId);
    return this.toSnapshot(activityId, record);
  }
  async updateCapacitySettings(activityId, payload) {
    const record = this.ensureCapacityRecord(activityId);
    if (payload.capacity !== void 0) {
      if (payload.capacity < 1) throw new import_common147.BadRequestException("Capacity must be at least 1");
      record.capacity = payload.capacity;
    }
    if (payload.booked !== void 0) {
      record.booked = Math.max(0, payload.booked);
    }
    if (payload.waitlistEnabled !== void 0) {
      record.waitlistEnabled = payload.waitlistEnabled;
    }
    record.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    return this.toSnapshot(activityId, record);
  }
  async addWaitlistEntry(activityId, entry) {
    const record = this.ensureCapacityRecord(activityId);
    if (!record.waitlistEnabled) {
      throw new import_common147.BadRequestException("Waitlist is disabled for this activity");
    }
    const newEntry = {
      id: `wl-${Date.now()}`,
      guestName: entry.guestName,
      partySize: Math.max(1, entry.partySize || 1),
      contact: entry.contact,
      addedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    record.waitlist.unshift(newEntry);
    record.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    return { entry: newEntry, snapshot: this.toSnapshot(activityId, record) };
  }
  trackBookingImpact(activityId, quantity) {
    const record = this.ensureCapacityRecord(activityId);
    record.booked += quantity;
    record.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
  }
  trackCancellationImpact(activityId, quantity) {
    const record = this.ensureCapacityRecord(activityId);
    record.booked = Math.max(0, record.booked - quantity);
    record.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
  }
  // Activities
  async createActivity(campgroundId, data) {
    return this.prisma.activity.create({
      data: {
        ...data,
        campgroundId
      }
    });
  }
  async findAllActivities(campgroundId) {
    return this.prisma.activity.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" }
    });
  }
  async findActivity(id) {
    const activity = await this.prisma.activity.findUnique({
      where: { id },
      include: { sessions: true }
    });
    if (!activity) throw new import_common147.NotFoundException("Activity not found");
    return activity;
  }
  async updateActivity(id, data) {
    return this.prisma.activity.update({
      where: { id },
      data
    });
  }
  async deleteActivity(id) {
    return this.prisma.activity.delete({
      where: { id }
    });
  }
  // Sessions
  async createSession(activityId, data) {
    const activity = await this.prisma.activity.findUnique({ where: { id: activityId } });
    if (!activity) throw new import_common147.NotFoundException("Activity not found");
    return this.prisma.activitySession.create({
      data: {
        ...data,
        activityId,
        capacity: data.capacity || activity.capacity
      }
    });
  }
  async findSessions(activityId) {
    return this.prisma.activitySession.findMany({
      where: { activityId },
      orderBy: { startTime: "asc" },
      include: { bookings: true }
    });
  }
  // Bookings
  async createBooking(sessionId, guestId, quantity, reservationId) {
    const session = await this.prisma.activitySession.findUnique({
      where: { id: sessionId },
      include: { activity: true }
    });
    if (!session) throw new import_common147.NotFoundException("Session not found");
    if (session.bookedCount + quantity > session.capacity) {
      throw new import_common147.BadRequestException("Session capacity exceeded");
    }
    const totalAmount = session.activity.price * quantity;
    const [booking, updatedSession] = await this.prisma.$transaction([
      this.prisma.activityBooking.create({
        data: {
          sessionId,
          guestId,
          reservationId,
          quantity,
          totalAmount
        }
      }),
      this.prisma.activitySession.update({
        where: { id: sessionId },
        data: { bookedCount: { increment: quantity } }
      })
    ]);
    this.trackBookingImpact(session.activityId, quantity);
    return booking;
  }
  async cancelBooking(id) {
    const booking = await this.prisma.activityBooking.findUnique({ where: { id } });
    if (!booking) throw new import_common147.NotFoundException("Booking not found");
    const session = await this.prisma.activitySession.findUnique({ where: { id: booking.sessionId } });
    const [cancelledBooking] = await this.prisma.$transaction([
      this.prisma.activityBooking.update({
        where: { id },
        data: { status: "cancelled" }
      }),
      this.prisma.activitySession.update({
        where: { id: booking.sessionId },
        data: { bookedCount: { decrement: booking.quantity } }
      })
    ]);
    if (session) {
      this.trackCancellationImpact(session.activityId, booking.quantity);
    }
    return cancelledBooking;
  }
};
ActivitiesService = __decorateClass([
  (0, import_common147.Injectable)()
], ActivitiesService);

// src/activities/activities.controller.ts
var import_common148 = require("@nestjs/common");
var ActivitiesController = class {
  constructor(activitiesService) {
    this.activitiesService = activitiesService;
  }
  create(createActivityDto) {
    const { campgroundId, ...data } = createActivityDto;
    return this.activitiesService.createActivity(campgroundId, data);
  }
  findAll(campgroundId) {
    return this.activitiesService.findAllActivities(campgroundId);
  }
  findOne(id) {
    return this.activitiesService.findActivity(id);
  }
  getCapacity(id) {
    return this.activitiesService.getCapacitySnapshot(id);
  }
  updateCapacity(id, dto) {
    return this.activitiesService.updateCapacitySettings(id, dto);
  }
  addWaitlist(id, dto) {
    return this.activitiesService.addWaitlistEntry(id, dto);
  }
  update(id, updateActivityDto) {
    return this.activitiesService.updateActivity(id, updateActivityDto);
  }
  remove(id) {
    return this.activitiesService.deleteActivity(id);
  }
  createSession(id, createSessionDto) {
    return this.activitiesService.createSession(id, createSessionDto);
  }
  findSessions(id) {
    return this.activitiesService.findSessions(id);
  }
  createBooking(sessionId, bookingDto) {
    return this.activitiesService.createBooking(
      sessionId,
      bookingDto.guestId,
      bookingDto.quantity,
      bookingDto.reservationId
    );
  }
  cancelBooking(id) {
    return this.activitiesService.cancelBooking(id);
  }
};
__decorateClass([
  (0, import_common148.Post)(),
  __decorateParam(0, (0, import_common148.Body)())
], ActivitiesController.prototype, "create", 1);
__decorateClass([
  (0, import_common148.Get)(),
  __decorateParam(0, (0, import_common148.Query)("campgroundId"))
], ActivitiesController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common148.Get)(":id"),
  __decorateParam(0, (0, import_common148.Param)("id"))
], ActivitiesController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common148.Get)(":id/capacity"),
  __decorateParam(0, (0, import_common148.Param)("id"))
], ActivitiesController.prototype, "getCapacity", 1);
__decorateClass([
  (0, import_common148.Patch)(":id/capacity"),
  __decorateParam(0, (0, import_common148.Param)("id")),
  __decorateParam(1, (0, import_common148.Body)())
], ActivitiesController.prototype, "updateCapacity", 1);
__decorateClass([
  (0, import_common148.Post)(":id/waitlist"),
  __decorateParam(0, (0, import_common148.Param)("id")),
  __decorateParam(1, (0, import_common148.Body)())
], ActivitiesController.prototype, "addWaitlist", 1);
__decorateClass([
  (0, import_common148.Patch)(":id"),
  __decorateParam(0, (0, import_common148.Param)("id")),
  __decorateParam(1, (0, import_common148.Body)())
], ActivitiesController.prototype, "update", 1);
__decorateClass([
  (0, import_common148.Delete)(":id"),
  __decorateParam(0, (0, import_common148.Param)("id"))
], ActivitiesController.prototype, "remove", 1);
__decorateClass([
  (0, import_common148.Post)(":id/sessions"),
  __decorateParam(0, (0, import_common148.Param)("id")),
  __decorateParam(1, (0, import_common148.Body)())
], ActivitiesController.prototype, "createSession", 1);
__decorateClass([
  (0, import_common148.Get)(":id/sessions"),
  __decorateParam(0, (0, import_common148.Param)("id"))
], ActivitiesController.prototype, "findSessions", 1);
__decorateClass([
  (0, import_common148.Post)("sessions/:id/book"),
  __decorateParam(0, (0, import_common148.Param)("id")),
  __decorateParam(1, (0, import_common148.Body)())
], ActivitiesController.prototype, "createBooking", 1);
__decorateClass([
  (0, import_common148.Post)("bookings/:id/cancel"),
  __decorateParam(0, (0, import_common148.Param)("id"))
], ActivitiesController.prototype, "cancelBooking", 1);
ActivitiesController = __decorateClass([
  (0, import_common148.UseGuards)(JwtAuthGuard),
  (0, import_common148.Controller)("activities")
], ActivitiesController);

// src/activities/activities.module.ts
var ActivitiesModule = class {
};
ActivitiesModule = __decorateClass([
  (0, import_common149.Module)({
    controllers: [ActivitiesController],
    providers: [ActivitiesService, PrismaService],
    exports: [ActivitiesService]
  })
], ActivitiesModule);

// src/operations/operations.module.ts
var import_common152 = require("@nestjs/common");

// src/operations/operations.service.ts
var import_common150 = require("@nestjs/common");
var import_client23 = require("@prisma/client");
var OperationsService = class {
  constructor(prisma, gamification) {
    this.prisma = prisma;
    this.gamification = gamification;
  }
  async findAllTasks(campgroundId, type, status) {
    return this.prisma.operationalTask.findMany({
      where: {
        campgroundId,
        ...type && { type },
        ...status && { status }
      },
      include: { site: true },
      orderBy: { createdAt: "desc" }
    });
  }
  async createTask(campgroundId, data, user) {
    this.ensureCampgroundAccess(user, campgroundId);
    return this.prisma.operationalTask.create({
      data: {
        ...data,
        campgroundId
      }
    });
  }
  async updateTask(id, data, user) {
    const existing = await this.prisma.operationalTask.findUnique({ where: { id } });
    if (!existing) {
      throw new import_common150.ForbiddenException("Task not found");
    }
    this.ensureCampgroundAccess(user, existing.campgroundId);
    const updated = await this.prisma.operationalTask.update({
      where: { id },
      data
    });
    const statusTarget = data.status;
    const becameCompleted = !!existing && !!statusTarget && ["completed", "verified"].includes(statusTarget) && existing.status !== statusTarget;
    const becameOnTime = becameCompleted && existing?.dueDate ? new Date(existing.dueDate).getTime() >= Date.now() : false;
    if (becameCompleted && updated.assignedTo) {
      await this.gamification.recordEvent({
        campgroundId: updated.campgroundId,
        userId: updated.assignedTo,
        membershipId: void 0,
        category: import_client23.GamificationEventCategory.task,
        reason: `Task completed: ${updated.title}`,
        sourceType: "operational_task",
        sourceId: updated.id,
        eventKey: `task:${updated.id}:completed`
      });
      if (becameOnTime) {
        await this.gamification.recordEvent({
          campgroundId: updated.campgroundId,
          userId: updated.assignedTo,
          membershipId: void 0,
          category: import_client23.GamificationEventCategory.on_time_assignment,
          reason: `On-time: ${updated.title}`,
          sourceType: "operational_task",
          sourceId: updated.id,
          eventKey: `task:${updated.id}:on_time`
        });
      }
    }
    return updated;
  }
  async updateSiteHousekeeping(siteId, status, user) {
    const site = await this.prisma.site.findUnique({
      where: { id: siteId },
      select: { campgroundId: true }
    });
    if (!site) {
      throw new import_common150.ForbiddenException("Site not found");
    }
    this.ensureCampgroundAccess(user, site.campgroundId);
    return this.prisma.site.update({
      where: { id: siteId },
      data: { housekeepingStatus: status }
    });
  }
  async getHousekeepingStats(campgroundId) {
    const sites = await this.prisma.site.findMany({
      where: { campgroundId },
      select: { housekeepingStatus: true }
    });
    return {
      clean: sites.filter((s) => s.housekeepingStatus === "clean").length,
      dirty: sites.filter((s) => s.housekeepingStatus === "dirty").length,
      inspecting: sites.filter((s) => s.housekeepingStatus === "inspecting").length,
      total: sites.length
    };
  }
  async getAutoTasking(campgroundId) {
    return [
      {
        trigger: "checkout",
        task: "Inspect and clean site after guest departs",
        status: "active",
        dueMinutes: 45,
        owner: "Housekeeping lead",
        playbook: "Departure SOP"
      },
      {
        trigger: "early_checkin_paid",
        task: "Prep site for early arrival",
        status: "active",
        dueMinutes: 30,
        owner: "Front desk",
        playbook: "Arrival SOP"
      },
      {
        trigger: "maintenance_overdue",
        task: "Escalate overdue maintenance tickets",
        status: "active",
        dueMinutes: 60,
        owner: "Ops supervisor",
        playbook: "Maintenance escalation"
      }
    ];
  }
  async triggerAutoTask(campgroundId, trigger, user) {
    this.ensureCampgroundAccess(user, campgroundId);
    return {
      triggered: true,
      trigger,
      created: [
        {
          id: "auto-1",
          title: `Auto task for ${trigger}`,
          status: "pending",
          priority: "high",
          dueAt: new Date(Date.now() + 45 * 60 * 1e3).toISOString(),
          owner: "Ops queue"
        }
      ]
    };
  }
  async listChecklists(campgroundId) {
    return [
      {
        id: "chk-1",
        name: "Arrival checklist",
        steps: ["Verify ID", "Confirm payment", "Site walkthrough"],
        status: "active",
        owner: "Front desk",
        dueMinutes: 20
      },
      {
        id: "chk-2",
        name: "Departure checklist",
        steps: ["Inspect site", "Reset power/water", "Log issues"],
        status: "active",
        owner: "Housekeeping",
        dueMinutes: 30
      },
      {
        id: "chk-3",
        name: "Maintenance triage",
        steps: ["Confirm issue", "Assign tech", "Set ETA", "Update guest"],
        status: "active",
        owner: "Ops supervisor",
        dueMinutes: 60
      }
    ];
  }
  async listReorders(campgroundId) {
    return [
      {
        id: "reo-1",
        item: "Cleaning supplies",
        qty: 12,
        threshold: 10,
        status: "needs_order",
        vendor: "Janitorial Co.",
        reorderQty: 30
      },
      {
        id: "reo-2",
        item: "Propane canisters",
        qty: 8,
        threshold: 15,
        status: "needs_order",
        vendor: "Propane Plus",
        reorderQty: 20
      },
      {
        id: "reo-3",
        item: "Pool test strips",
        qty: 40,
        threshold: 25,
        status: "ok",
        vendor: "WaterSafe",
        reorderQty: 80
      }
    ];
  }
  async listSuggestions(campgroundId) {
    return [
      {
        id: "ops-1",
        suggestion: "Bundle housekeeping tasks by loop to cut travel time",
        impact: "medium",
        action: "Group tasks",
        status: "new"
      },
      {
        id: "ops-2",
        suggestion: "Auto-assign maintenance overdue tickets to on-call",
        impact: "high",
        action: "Enable auto-assign",
        status: "new"
      },
      {
        id: "ops-3",
        suggestion: "Schedule inventory reorders weekly to avoid rush shipping",
        impact: "low",
        action: "Schedule reorders",
        status: "new"
      }
    ];
  }
  async getOpsHealth(campgroundId) {
    const [reorders, checklists] = await Promise.all([
      this.listReorders(campgroundId),
      this.listChecklists(campgroundId)
    ]);
    const pendingReorders = reorders.filter((r) => r.status === "needs_order");
    const completionRate = checklists.length ? Math.min(1, checklists.length / (checklists.length + pendingReorders.length)) : 0.75;
    const now = Date.now();
    const recentAutoRuns = [
      {
        trigger: "checkout",
        status: "success",
        createdTasks: 2,
        durationMs: 1200,
        at: new Date(now - 5 * 60 * 1e3).toISOString()
      },
      {
        trigger: "maintenance_overdue",
        status: "success",
        createdTasks: 1,
        durationMs: 1800,
        at: new Date(now - 20 * 60 * 1e3).toISOString()
      },
      {
        trigger: "early_checkin_paid",
        status: "queued",
        createdTasks: 0,
        durationMs: 0,
        at: new Date(now - 45 * 60 * 1e3).toISOString()
      }
    ];
    return {
      campgroundId,
      capturedAt: new Date(now).toISOString(),
      autoTasking: {
        recentRuns: recentAutoRuns,
        tasksCreatedLast24h: 12
      },
      checklists: {
        completionRate,
        active: checklists.length,
        overdue: Math.max(0, Math.round(checklists.length * 0.1))
      },
      reorders: {
        pending: pendingReorders.length,
        items: pendingReorders
      }
    };
  }
  async sendOpsHealthAlert(campgroundId, channel = "webhook", target = "ops-alerts", message = "Test alert from ops health", user) {
    this.ensureCampgroundAccess(user, campgroundId);
    const payload = {
      campgroundId,
      channel,
      target,
      message,
      at: (/* @__PURE__ */ new Date()).toISOString()
    };
    console.log("[ops-health-alert]", payload);
    return { sent: true, ...payload };
  }
  ensureCampgroundAccess(user, campgroundId) {
    if (!campgroundId) {
      throw new import_common150.ForbiddenException("Campground scope required");
    }
    const allowed = Array.isArray(user?.memberships) && user.memberships.some((m) => m.campgroundId === campgroundId);
    if (!allowed) {
      throw new import_common150.ForbiddenException("Forbidden by campground scope");
    }
  }
};
OperationsService = __decorateClass([
  (0, import_common150.Injectable)()
], OperationsService);

// src/operations/operations.controller.ts
var import_common151 = require("@nestjs/common");
var OperationsController = class {
  constructor(operationsService) {
    this.operationsService = operationsService;
  }
  findAllTasks(campgroundId, type, status) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.findAllTasks(campgroundId, type, status);
  }
  createTask(createTaskDto, req) {
    const { campgroundId, ...data } = createTaskDto;
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.createTask(campgroundId, data, req?.user);
  }
  updateTask(id, updateTaskDto, req) {
    return this.operationsService.updateTask(id, updateTaskDto, req?.user);
  }
  updateSiteHousekeeping(id, status, req) {
    return this.operationsService.updateSiteHousekeeping(id, status, req?.user);
  }
  getHousekeepingStats(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.getHousekeepingStats(campgroundId);
  }
  getAutoTasking(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.getAutoTasking(campgroundId);
  }
  triggerAutoTask(body, req) {
    if (!body.campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.triggerAutoTask(body.campgroundId, body.trigger, req?.user);
  }
  listChecklists(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.listChecklists(campgroundId);
  }
  listReorders(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.listReorders(campgroundId);
  }
  listSuggestions(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.listSuggestions(campgroundId);
  }
  getOpsHealth(campgroundId) {
    if (!campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.getOpsHealth(campgroundId);
  }
  sendOpsHealthAlert(body, req) {
    if (!body.campgroundId) throw new import_common151.ForbiddenException("campgroundId is required");
    return this.operationsService.sendOpsHealthAlert(
      body.campgroundId,
      body.channel,
      body.target,
      body.message,
      req?.user
    );
  }
};
__decorateClass([
  (0, import_common151.Get)("tasks"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId")),
  __decorateParam(1, (0, import_common151.Query)("type")),
  __decorateParam(2, (0, import_common151.Query)("status"))
], OperationsController.prototype, "findAllTasks", 1);
__decorateClass([
  RequireScope({ resource: "operations", action: "write" }),
  (0, import_common151.Post)("tasks"),
  __decorateParam(0, (0, import_common151.Body)()),
  __decorateParam(1, (0, import_common151.Req)())
], OperationsController.prototype, "createTask", 1);
__decorateClass([
  RequireScope({ resource: "operations", action: "write" }),
  (0, import_common151.Patch)("tasks/:id"),
  __decorateParam(0, (0, import_common151.Param)("id")),
  __decorateParam(1, (0, import_common151.Body)()),
  __decorateParam(2, (0, import_common151.Req)())
], OperationsController.prototype, "updateTask", 1);
__decorateClass([
  RequireScope({ resource: "operations", action: "write" }),
  (0, import_common151.Patch)("sites/:id/housekeeping"),
  __decorateParam(0, (0, import_common151.Param)("id")),
  __decorateParam(1, (0, import_common151.Body)("status")),
  __decorateParam(2, (0, import_common151.Req)())
], OperationsController.prototype, "updateSiteHousekeeping", 1);
__decorateClass([
  (0, import_common151.Get)("stats/housekeeping"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "getHousekeepingStats", 1);
__decorateClass([
  (0, import_common151.Get)("auto-tasking"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "getAutoTasking", 1);
__decorateClass([
  RequireScope({ resource: "operations", action: "write" }),
  (0, import_common151.Post)("auto-tasking/trigger"),
  __decorateParam(0, (0, import_common151.Body)()),
  __decorateParam(1, (0, import_common151.Req)())
], OperationsController.prototype, "triggerAutoTask", 1);
__decorateClass([
  (0, import_common151.Get)("checklists"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "listChecklists", 1);
__decorateClass([
  (0, import_common151.Get)("reorders"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "listReorders", 1);
__decorateClass([
  (0, import_common151.Get)("copilot/suggestions"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "listSuggestions", 1);
__decorateClass([
  (0, import_common151.Get)("ops-health"),
  __decorateParam(0, (0, import_common151.Query)("campgroundId"))
], OperationsController.prototype, "getOpsHealth", 1);
__decorateClass([
  RequireScope({ resource: "operations", action: "write" }),
  (0, import_common151.Post)("ops-health/alert"),
  __decorateParam(0, (0, import_common151.Body)()),
  __decorateParam(1, (0, import_common151.Req)())
], OperationsController.prototype, "sendOpsHealthAlert", 1);
OperationsController = __decorateClass([
  (0, import_common151.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "operations", action: "read" }),
  (0, import_common151.Controller)("operations")
], OperationsController);

// src/operations/operations.module.ts
var OperationsModule = class {
};
OperationsModule = __decorateClass([
  (0, import_common152.Module)({
    imports: [PrismaModule, GamificationModule, PermissionsModule],
    controllers: [OperationsController],
    providers: [OperationsService],
    exports: [OperationsService]
  })
], OperationsModule);

// src/incidents/incidents.module.ts
var import_common155 = require("@nestjs/common");

// src/incidents/incidents.service.ts
var import_common153 = require("@nestjs/common");
var import_client24 = require("@prisma/client");
var IncidentsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async list(campgroundId) {
    return this.prisma.incident.findMany({
      where: { campgroundId },
      include: { tasks: true, evidence: true },
      orderBy: { createdAt: "desc" }
    });
  }
  async create(dto) {
    return this.prisma.incident.create({
      data: {
        campgroundId: dto.campgroundId,
        reservationId: dto.reservationId ?? null,
        guestId: dto.guestId ?? null,
        type: dto.type,
        severity: dto.severity,
        notes: dto.notes,
        photos: dto.photos ?? null,
        witnesses: dto.witnesses ?? null,
        occurredAt: dto.occurredAt ? new Date(dto.occurredAt) : null
      }
    });
  }
  async update(id, dto) {
    await this.ensureIncident(id);
    const closedAt = dto.status && [import_client24.IncidentStatus.closed, import_client24.IncidentStatus.resolved].includes(dto.status) ? /* @__PURE__ */ new Date() : void 0;
    return this.prisma.incident.update({
      where: { id },
      data: {
        ...dto,
        photos: dto.photos ?? void 0,
        witnesses: dto.witnesses ?? void 0,
        occurredAt: dto.occurredAt ? new Date(dto.occurredAt) : void 0,
        closedAt
      }
    });
  }
  async close(id, dto) {
    const incident = await this.ensureIncident(id);
    const updatedNotes = dto.resolutionNotes ? [incident.notes, `Resolution: ${dto.resolutionNotes}`].filter(Boolean).join("\n") : incident.notes;
    return this.prisma.incident.update({
      where: { id },
      data: {
        status: import_client24.IncidentStatus.closed,
        closedAt: /* @__PURE__ */ new Date(),
        claimId: dto.claimId ?? incident.claimId,
        notes: updatedNotes ?? void 0
      }
    });
  }
  async addEvidence(incidentId, dto) {
    await this.ensureIncident(incidentId);
    return this.prisma.incidentEvidence.create({
      data: {
        incidentId,
        type: dto.type ?? import_client24.EvidenceType.photo,
        url: dto.url,
        storageKey: dto.storageKey,
        description: dto.description,
        uploadedBy: dto.uploadedBy,
        metadata: dto.url ? { source: "direct_url" } : void 0
      }
    });
  }
  async linkClaim(id, dto) {
    await this.ensureIncident(id);
    return this.prisma.incident.update({
      where: { id },
      data: {
        claimId: dto.claimId,
        metadata: {
          ...dto.provider ? { provider: dto.provider } : {},
          ...dto.notes ? { claimNotes: dto.notes } : {}
        }
      }
    });
  }
  async setReminder(id, dto) {
    await this.ensureIncident(id);
    return this.prisma.incident.update({
      where: { id },
      data: {
        reminderAt: new Date(dto.reminderAt),
        metadata: dto.message ? { reminderMessage: dto.message } : void 0
      }
    });
  }
  async attachCoi(incidentId, dto) {
    const incident = await this.ensureIncident(incidentId);
    return this.prisma.certificateOfInsurance.create({
      data: {
        incidentId,
        campgroundId: incident.campgroundId,
        reservationId: incident.reservationId,
        guestId: incident.guestId,
        fileUrl: dto.fileUrl,
        provider: dto.provider,
        policyNumber: dto.policyNumber,
        coverageType: dto.coverageType,
        effectiveDate: dto.effectiveDate ? new Date(dto.effectiveDate) : null,
        expiresAt: dto.expiresAt ? new Date(dto.expiresAt) : null,
        uploadedBy: dto.uploadedBy
      }
    });
  }
  async createTask(incidentId, dto) {
    await this.ensureIncident(incidentId);
    return this.prisma.incidentTask.create({
      data: {
        incidentId,
        title: dto.title,
        status: import_client24.IncidentTaskStatus.pending,
        dueAt: dto.dueAt ? new Date(dto.dueAt) : null,
        reminderAt: dto.reminderAt ? new Date(dto.reminderAt) : null,
        assignedTo: dto.assignedTo ?? null
      }
    });
  }
  async updateTask(incidentId, taskId, dto) {
    const existing = await this.prisma.incidentTask.findUnique({ where: { id: taskId } });
    if (!existing || existing.incidentId !== incidentId) {
      throw new import_common153.NotFoundException("Task not found for incident");
    }
    return this.prisma.incidentTask.update({
      where: { id: taskId },
      data: {
        ...dto,
        dueAt: dto.dueAt ? new Date(dto.dueAt) : void 0,
        reminderAt: dto.reminderAt ? new Date(dto.reminderAt) : void 0,
        completedAt: dto.status === import_client24.IncidentTaskStatus.done ? /* @__PURE__ */ new Date() : dto.status && dto.status !== import_client24.IncidentTaskStatus.done ? null : void 0
      }
    });
  }
  async report(campgroundId, format) {
    const byStatus = await this.prisma.incident.groupBy({
      by: ["status"],
      _count: { _all: true },
      where: { campgroundId },
      orderBy: { status: "asc" }
    });
    const byType = await this.prisma.incident.groupBy({
      by: ["type"],
      _count: { _all: true },
      where: { campgroundId },
      orderBy: { type: "asc" }
    });
    const openTasks = await this.prisma.incidentTask.count({
      where: { status: { not: import_client24.IncidentTaskStatus.done }, incident: { campgroundId } }
    });
    const summary = {
      byStatus,
      byType,
      openTasks,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (format === "csv") {
      const statusLines = byStatus.map((s) => `${s.status},${s._count._all}`).join("\n");
      const typeLines = byType.map((t) => `${t.type},${t._count._all}`).join("\n");
      return `section,count
${statusLines}
---
${typeLines}
openTasks,${openTasks}`;
    }
    return summary;
  }
  async ensureIncident(id) {
    const incident = await this.prisma.incident.findUnique({ where: { id } });
    if (!incident) {
      throw new import_common153.NotFoundException("Incident not found");
    }
    return incident;
  }
};
IncidentsService = __decorateClass([
  (0, import_common153.Injectable)()
], IncidentsService);

// src/incidents/incidents.controller.ts
var import_common154 = require("@nestjs/common");
var IncidentsController = class {
  constructor(incidents) {
    this.incidents = incidents;
  }
  list(campgroundId) {
    return this.incidents.list(campgroundId);
  }
  create(dto) {
    return this.incidents.create(dto);
  }
  update(id, dto) {
    return this.incidents.update(id, dto);
  }
  close(id, dto) {
    return this.incidents.close(id, dto);
  }
  addEvidence(id, dto) {
    return this.incidents.addEvidence(id, dto);
  }
  linkClaim(id, dto) {
    return this.incidents.linkClaim(id, dto);
  }
  setReminder(id, dto) {
    return this.incidents.setReminder(id, dto);
  }
  attachCoi(id, dto) {
    return this.incidents.attachCoi(id, dto);
  }
  createTask(id, dto) {
    return this.incidents.createTask(id, dto);
  }
  updateTask(id, taskId, dto) {
    return this.incidents.updateTask(id, taskId, dto);
  }
  report(campgroundId, format) {
    return this.incidents.report(campgroundId, format);
  }
};
__decorateClass([
  (0, import_common154.Get)(),
  __decorateParam(0, (0, import_common154.Query)("campgroundId"))
], IncidentsController.prototype, "list", 1);
__decorateClass([
  (0, import_common154.Post)(),
  __decorateParam(0, (0, import_common154.Body)())
], IncidentsController.prototype, "create", 1);
__decorateClass([
  (0, import_common154.Patch)(":id"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "update", 1);
__decorateClass([
  (0, import_common154.Post)(":id/close"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "close", 1);
__decorateClass([
  (0, import_common154.Post)(":id/evidence"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "addEvidence", 1);
__decorateClass([
  (0, import_common154.Post)(":id/claim"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "linkClaim", 1);
__decorateClass([
  (0, import_common154.Post)(":id/reminder"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "setReminder", 1);
__decorateClass([
  (0, import_common154.Post)(":id/coi"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "attachCoi", 1);
__decorateClass([
  (0, import_common154.Post)(":id/tasks"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Body)())
], IncidentsController.prototype, "createTask", 1);
__decorateClass([
  (0, import_common154.Patch)(":id/tasks/:taskId"),
  __decorateParam(0, (0, import_common154.Param)("id")),
  __decorateParam(1, (0, import_common154.Param)("taskId")),
  __decorateParam(2, (0, import_common154.Body)())
], IncidentsController.prototype, "updateTask", 1);
__decorateClass([
  (0, import_common154.Get)("report/export"),
  __decorateParam(0, (0, import_common154.Query)("campgroundId")),
  __decorateParam(1, (0, import_common154.Query)("format"))
], IncidentsController.prototype, "report", 1);
IncidentsController = __decorateClass([
  (0, import_common154.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles("owner", "manager", "front_desk", "maintenance"),
  (0, import_common154.Controller)("incidents")
], IncidentsController);

// src/incidents/incidents.module.ts
var IncidentsModule = class {
};
IncidentsModule = __decorateClass([
  (0, import_common155.Module)({
    imports: [PrismaModule],
    controllers: [IncidentsController],
    providers: [IncidentsService],
    exports: [IncidentsService]
  })
], IncidentsModule);

// src/internal-conversations/internal-conversations.module.ts
var import_common158 = require("@nestjs/common");

// src/internal-conversations/internal-conversations.service.ts
var import_common156 = require("@nestjs/common");
var InternalConversationsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async createChannel(name, campgroundId, participantIds) {
    return this.prisma.internalConversation.create({
      data: {
        name,
        type: "channel",
        campgroundId,
        participants: {
          create: participantIds.map((id) => ({ userId: id }))
        }
      },
      include: {
        participants: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        }
      }
    });
  }
  async createDM(campgroundId, participantIds) {
    return this.prisma.internalConversation.create({
      data: {
        type: "dm",
        campgroundId,
        participants: {
          create: participantIds.map((id) => ({ userId: id }))
        }
      },
      include: {
        participants: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        }
      }
    });
  }
  async findAll(userId, campgroundId) {
    return this.prisma.internalConversation.findMany({
      where: {
        campgroundId,
        participants: {
          some: {
            userId
          }
        }
      },
      include: {
        participants: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        },
        messages: {
          take: 1,
          orderBy: { createdAt: "desc" }
        }
      },
      orderBy: {
        updatedAt: "desc"
      }
    });
  }
};
InternalConversationsService = __decorateClass([
  (0, import_common156.Injectable)()
], InternalConversationsService);

// src/internal-conversations/internal-conversations.controller.ts
var import_common157 = require("@nestjs/common");
var InternalConversationsController = class {
  constructor(service) {
    this.service = service;
  }
  create(req, body) {
    if (body.type === "channel") {
      const participants = [.../* @__PURE__ */ new Set([...body.participantIds, req.user.id])];
      return this.service.createChannel(body.name || "New Channel", body.campgroundId, participants);
    } else {
      const participants = [.../* @__PURE__ */ new Set([...body.participantIds, req.user.id])];
      return this.service.createDM(body.campgroundId, participants);
    }
  }
  findAll(req, campgroundId) {
    return this.service.findAll(req.user.id, campgroundId);
  }
};
__decorateClass([
  (0, import_common157.Post)(),
  __decorateParam(0, (0, import_common157.Req)()),
  __decorateParam(1, (0, import_common157.Body)())
], InternalConversationsController.prototype, "create", 1);
__decorateClass([
  (0, import_common157.Get)(),
  __decorateParam(0, (0, import_common157.Req)()),
  __decorateParam(1, (0, import_common157.Query)("campgroundId"))
], InternalConversationsController.prototype, "findAll", 1);
InternalConversationsController = __decorateClass([
  (0, import_common157.Controller)("internal-conversations"),
  (0, import_common157.UseGuards)(JwtAuthGuard)
], InternalConversationsController);

// src/internal-conversations/internal-conversations.module.ts
var InternalConversationsModule = class {
};
InternalConversationsModule = __decorateClass([
  (0, import_common158.Module)({
    imports: [PrismaModule],
    controllers: [InternalConversationsController],
    providers: [InternalConversationsService],
    exports: [InternalConversationsService]
  })
], InternalConversationsModule);

// src/holds/holds.module.ts
var import_common161 = require("@nestjs/common");

// src/holds/holds.service.ts
var import_common159 = require("@nestjs/common");
var import_client25 = require("@prisma/client");
var HoldsService = class {
  constructor(prisma, waitlistService) {
    this.prisma = prisma;
    this.waitlistService = waitlistService;
    this.logger = new import_common159.Logger(HoldsService.name);
  }
  onModuleInit() {
    const intervalMs = Number(process.env.HOLDS_EXPIRE_INTERVAL_MS ?? 5 * 60 * 1e3);
    if (intervalMs > 0) {
      this.logger.log(`Starting hold expiry worker (every ${intervalMs} ms)`);
      this.expireTimer = setInterval(async () => {
        try {
          const expired = await this.expireStale();
          if (expired > 0) this.logger.log(`Expired ${expired} holds`);
        } catch (err) {
          this.logger.warn(`Hold expiry worker failed: ${err}`);
        }
      }, intervalMs);
    }
  }
  onModuleDestroy() {
    if (this.expireTimer) {
      clearInterval(this.expireTimer);
      this.expireTimer = void 0;
    }
  }
  parseDates(arrivalDate, departureDate) {
    const arrival = new Date(arrivalDate);
    const departure = new Date(departureDate);
    if (isNaN(arrival.valueOf()) || isNaN(departure.valueOf())) {
      throw new import_common159.BadRequestException("Invalid dates");
    }
    if (departure <= arrival) {
      throw new import_common159.BadRequestException("departureDate must be after arrivalDate");
    }
    return { arrival, departure };
  }
  async assertNoOverlap(siteId, arrival, departure) {
    const now = /* @__PURE__ */ new Date();
    const holdOverlap = await this.prisma.siteHold.count({
      where: {
        siteId,
        status: "active",
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }],
        arrivalDate: { lt: departure },
        departureDate: { gt: arrival }
      }
    });
    if (holdOverlap > 0) throw new import_common159.BadRequestException("Site is on hold for those dates");
    const reservationOverlap = await this.prisma.reservation.count({
      where: {
        siteId,
        status: { not: import_client25.ReservationStatus.cancelled },
        departureDate: { gt: arrival },
        arrivalDate: { lt: departure }
      }
    });
    if (reservationOverlap > 0) throw new import_common159.BadRequestException("Site already reserved for those dates");
  }
  computeExpiry(holdMinutes) {
    if (!holdMinutes || holdMinutes <= 0) return null;
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + holdMinutes);
    return expiresAt;
  }
  async create(dto) {
    const { arrival, departure } = this.parseDates(dto.arrivalDate, dto.departureDate);
    const site = await this.prisma.site.findUnique({ where: { id: dto.siteId }, select: { id: true, campgroundId: true } });
    if (!site || site.campgroundId !== dto.campgroundId) {
      throw new import_common159.NotFoundException("Site not found for campground");
    }
    await this.assertNoOverlap(dto.siteId, arrival, departure);
    return this.prisma.siteHold.create({
      data: {
        campgroundId: dto.campgroundId,
        siteId: dto.siteId,
        arrivalDate: arrival,
        departureDate: departure,
        expiresAt: this.computeExpiry(dto.holdMinutes ?? 15),
        status: "active",
        note: dto.note ?? null
      }
    });
  }
  async release(id) {
    const existing = await this.prisma.siteHold.findUnique({ where: { id } });
    if (!existing) throw new import_common159.NotFoundException("Hold not found");
    return this.prisma.siteHold.update({
      where: { id },
      data: { status: "released", expiresAt: existing.expiresAt ?? /* @__PURE__ */ new Date() }
    });
  }
  async listByCampground(campgroundId) {
    const now = /* @__PURE__ */ new Date();
    return this.prisma.siteHold.findMany({
      where: {
        campgroundId,
        status: "active",
        OR: [{ expiresAt: null }, { expiresAt: { gt: now } }]
      },
      include: { site: { select: { id: true, name: true, siteNumber: true } } },
      orderBy: { arrivalDate: "asc" }
    });
  }
  async expireStale() {
    const now = /* @__PURE__ */ new Date();
    const expired = await this.prisma.siteHold.findMany({
      where: { status: "active", expiresAt: { lte: now } },
      include: { site: { select: { id: true, siteClassId: true } } }
    });
    if (expired.length === 0) return 0;
    await Promise.all(
      expired.map(
        (hold) => this.prisma.siteHold.update({
          where: { id: hold.id },
          data: { status: "expired" }
        })
      )
    );
    for (const hold of expired) {
      try {
        await this.waitlistService.checkWaitlist(
          hold.campgroundId,
          hold.arrivalDate,
          hold.departureDate,
          hold.siteId,
          hold.site?.siteClassId ?? void 0
        );
      } catch (err) {
      }
    }
    return expired.length;
  }
};
HoldsService = __decorateClass([
  (0, import_common159.Injectable)()
], HoldsService);

// src/holds/holds.controller.ts
var import_common160 = require("@nestjs/common");
var HoldsController = class {
  constructor(holds) {
    this.holds = holds;
  }
  create(dto) {
    return this.holds.create(dto);
  }
  list(campgroundId) {
    return this.holds.listByCampground(campgroundId);
  }
  release(id) {
    return this.holds.release(id);
  }
  expireStale() {
    return this.holds.expireStale();
  }
};
__decorateClass([
  (0, import_common160.Post)(),
  __decorateParam(0, (0, import_common160.Body)())
], HoldsController.prototype, "create", 1);
__decorateClass([
  (0, import_common160.Get)("campgrounds/:campgroundId"),
  __decorateParam(0, (0, import_common160.Param)("campgroundId"))
], HoldsController.prototype, "list", 1);
__decorateClass([
  (0, import_common160.Delete)(":id"),
  __decorateParam(0, (0, import_common160.Param)("id"))
], HoldsController.prototype, "release", 1);
__decorateClass([
  (0, import_common160.Post)("expire")
], HoldsController.prototype, "expireStale", 1);
HoldsController = __decorateClass([
  (0, import_common160.UseGuards)(JwtAuthGuard),
  (0, import_common160.Controller)("holds")
], HoldsController);

// src/holds/holds.module.ts
var HoldsModule = class {
};
HoldsModule = __decorateClass([
  (0, import_common161.Module)({
    imports: [WaitlistModule],
    controllers: [HoldsController],
    providers: [HoldsService, PrismaService],
    exports: [HoldsService]
  })
], HoldsModule);

// src/communications/communications.module.ts
var import_common169 = require("@nestjs/common");

// src/communications/communications.controller.ts
var import_common162 = require("@nestjs/common");
var import_schedule7 = require("@nestjs/schedule");
var import_client26 = require("@prisma/client");
var CommunicationsController = class {
  constructor(prisma, emailService, smsService, npsService, observability, alerting) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.smsService = smsService;
    this.npsService = npsService;
    this.observability = observability;
    this.alerting = alerting;
    this.commsMetricsEnabled = (process.env.ENABLE_COMMS_METRICS ?? process.env.comms_alerts_enabled ?? "true").toString().toLowerCase() === "true";
  }
  normalizePostmarkStatus(recordType) {
    const rt = (recordType || "").toLowerCase();
    if (rt === "delivery") return "delivered";
    if (rt === "bounce") return "bounced";
    if (rt === "spamcomplaint") return "spam_complaint";
    if (rt === "deferred" || rt === "tempfail") return "deferred";
    if (rt === "open" || rt === "click") return "sent";
    return rt || "unknown";
  }
  normalizeTwilioStatus(status) {
    const s = (status || "").toLowerCase();
    if (s === "delivered") return "delivered";
    if (s === "sent") return "sent";
    if (s === "queued" || s === "accepted") return "queued";
    if (s === "failed" || s === "undelivered") return "failed";
    if (s === "receiving" || s === "received") return "received";
    return s || "unknown";
  }
  getSenderDomain(address) {
    if (!address) return null;
    const parts = address.split("@");
    return parts.length === 2 ? parts[1].toLowerCase() : null;
  }
  ensureVerifiedSenderDomain(address) {
    const allowedList = (process.env.EMAIL_SENDER_DOMAINS || "campreserv.com").split(",").map((d) => d.trim().toLowerCase()).filter(Boolean);
    const verifiedList = (process.env.EMAIL_VERIFIED_DOMAINS || "").split(",").map((d) => d.trim().toLowerCase()).filter(Boolean);
    const domain = this.getSenderDomain(address);
    if (!domain) {
      throw new import_common162.BadRequestException("fromAddress must include a domain");
    }
    if (!allowedList.includes(domain)) {
      throw new import_common162.BadRequestException(
        `Unverified sender domain ${domain}. Configure SPF/DKIM/DMARC and add to EMAIL_SENDER_DOMAINS.`
      );
    }
    if (verifiedList.length > 0 && !verifiedList.includes(domain)) {
      throw new import_common162.BadRequestException(
        `Sender domain ${domain} is not verified (SPF/DKIM/DMARC). Add to EMAIL_VERIFIED_DOMAINS after provider verification.`
      );
    }
    return domain;
  }
  normalizePhone(phone) {
    if (!phone) return "";
    const digits = phone.replace(/\D/g, "");
    if (digits.length > 10) return digits.slice(-10);
    return digits;
  }
  normalizeEmail(email) {
    return email?.trim().toLowerCase() || "";
  }
  getLocalTimeParts(date, timeZone) {
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
    const parts = dtf.formatToParts(date).reduce((acc, p) => {
      if (p.type !== "literal") acc[p.type] = p.value;
      return acc;
    }, {});
    return {
      year: Number(parts.year),
      month: Number(parts.month),
      day: Number(parts.day),
      hour: Number(parts.hour),
      minute: Number(parts.minute),
      second: Number(parts.second)
    };
  }
  getTimezoneOffsetMinutes(date, timeZone) {
    const parts = this.getLocalTimeParts(date, timeZone);
    const asUTC = Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, parts.second);
    return (asUTC - date.getTime()) / 6e4;
  }
  buildZonedDate(parts, time, timeZone) {
    const baseUtc = Date.UTC(parts.year, parts.month - 1, parts.day, time.hour, time.minute, 0, 0);
    const offsetMinutes = this.getTimezoneOffsetMinutes(new Date(baseUtc), timeZone);
    return new Date(baseUtc - offsetMinutes * 6e4);
  }
  campgroundTz(campground) {
    return campground?.parkTimeZone || campground?.timezone || "UTC";
  }
  async ensureChannelConsent(channel, recipient, _body, campgroundId) {
    const normalized = channel === "email" ? this.normalizeEmail(recipient ?? "") : this.normalizePhone(recipient ?? "");
    const consentRequiredSetting = await this.prisma.privacySetting.findUnique({ where: { campgroundId } });
    const consentRequired = consentRequiredSetting?.consentRequired !== false;
    if (!consentRequired) {
      return { consentOk: true, consentSource: "disabled", consentCheckedAt: (/* @__PURE__ */ new Date()).toISOString() };
    }
    if (!normalized) {
      throw new import_common162.BadRequestException(`${channel} recipient missing, unable to verify consent`);
    }
    const latest = await this.prisma.consentLog.findFirst({
      where: { campgroundId, subject: normalized, consentType: channel },
      orderBy: { grantedAt: "desc" }
    });
    if (!latest || latest.revokedAt || latest.expiresAt && latest.expiresAt < /* @__PURE__ */ new Date()) {
      throw new import_common162.BadRequestException(`Consent required for ${channel}; none on file or revoked`);
    }
    return {
      consentOk: true,
      consentSource: "consent_log",
      consentCheckedAt: (/* @__PURE__ */ new Date()).toISOString(),
      consentSubject: normalized,
      consentGrantedAt: latest.grantedAt
    };
  }
  async requireTemplateApproval(templateId, campgroundId) {
    const tpl = await this.prisma.communicationTemplate.findUnique({ where: { id: templateId } });
    if (!tpl || tpl.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Template not found for campground");
    }
    if (tpl.status !== "approved") {
      throw new import_common162.BadRequestException("Template not approved");
    }
    return tpl;
  }
  requireTemplateForOutbound(body, channel) {
    if (!body.templateId) {
      throw new import_common162.BadRequestException(
        `Template is required for outbound ${channel}. Raw bodies are not permitted without an approved template.`
      );
    }
  }
  isQuietHours(campground, date) {
    if (!campground?.quietHoursStart || !campground?.quietHoursEnd) return false;
    const timeZone = this.campgroundTz(campground);
    const parts = this.getLocalTimeParts(date, timeZone);
    const minutes = parts.hour * 60 + parts.minute;
    const [sh, sm] = campground.quietHoursStart.split(":").map((n) => Number(n));
    const [eh, em] = campground.quietHoursEnd.split(":").map((n) => Number(n));
    const start = sh * 60 + (sm || 0);
    const end = eh * 60 + (em || 0);
    if (start === end) return false;
    if (start < end) return minutes >= start && minutes < end;
    return minutes >= start || minutes < end;
  }
  async resolveGuestAndReservationByPhone(phone) {
    const normalized = this.normalizePhone(phone);
    if (!normalized) return { guestId: null, reservationId: null, campgroundId: null };
    const guest = await this.prisma.guest.findFirst({
      where: { phone: { contains: normalized } },
      select: { id: true }
    });
    if (!guest) return { guestId: null, reservationId: null, campgroundId: null };
    const reservation = await this.prisma.reservation.findFirst({
      where: { guestId: guest.id },
      orderBy: { createdAt: "desc" },
      select: { id: true, campgroundId: true }
    });
    return { guestId: guest.id, reservationId: reservation?.id ?? null, campgroundId: reservation?.campgroundId ?? null };
  }
  ensureWebhookToken(token) {
    const expected = process.env.TWILIO_WEBHOOK_TOKEN;
    if (!expected) return true;
    return token === expected;
  }
  ensurePostmarkToken(token) {
    const expected = process.env.POSTMARK_WEBHOOK_TOKEN;
    if (!expected) return true;
    return token === expected;
  }
  recordComms(status, meta) {
    if (!this.commsMetricsEnabled) return;
    this.observability.recordCommsStatus(status, meta);
  }
  async create(body) {
    if (!body.guestId && !body.reservationId) {
      throw new import_common162.BadRequestException("guestId or reservationId is required");
    }
    const communication = await this.prisma.communication.create({
      data: {
        campgroundId: body.campgroundId,
        organizationId: body.organizationId ?? null,
        guestId: body.guestId ?? null,
        reservationId: body.reservationId ?? null,
        type: body.type,
        direction: body.direction,
        subject: body.subject ?? null,
        body: body.body ?? null,
        preview: body.body ? body.body.slice(0, 280) : null,
        status: body.direction === "inbound" ? "received" : "sent",
        provider: body.provider ?? null,
        providerMessageId: body.providerMessageId ?? null,
        toAddress: body.toAddress ?? null,
        fromAddress: body.fromAddress ?? null
      }
    });
    return communication;
  }
  async list(query) {
    if (!query.campgroundId) throw new import_common162.BadRequestException("campgroundId is required");
    const limit = Math.min(query.limit || 20, 100);
    const where = { campgroundId: query.campgroundId };
    if (query.guestId) where.guestId = query.guestId;
    if (query.reservationId) where.reservationId = query.reservationId;
    if (query.type) where.type = query.type;
    if (query.direction) where.direction = query.direction;
    const communications = await this.prisma.communication.findMany({
      where,
      orderBy: { createdAt: "desc" },
      take: limit + 1,
      ...query.cursor ? { skip: 1, cursor: { id: query.cursor } } : {}
    });
    const hasMore = communications.length > limit;
    const items = hasMore ? communications.slice(0, limit) : communications;
    return {
      items,
      nextCursor: hasMore ? items[items.length - 1].id : null
    };
  }
  async send(body) {
    if (!body.campgroundId) throw new import_common162.BadRequestException("campgroundId is required");
    const prisma = this.prisma;
    const clientConsentProvided = body.consentGranted === true || Boolean(body.consentSource);
    if (clientConsentProvided) {
      body.consentGranted = void 0;
      body.consentSource = void 0;
    }
    const campground = await this.prisma.campground.findUnique({
      where: { id: body.campgroundId },
      select: { id: true, quietHoursStart: true, quietHoursEnd: true, timezone: true, parkTimeZone: true }
    });
    if (!campground) throw new import_common162.BadRequestException("Invalid campgroundId");
    if (body.type === "email") {
      if (!body.toAddress) throw new import_common162.BadRequestException("toAddress is required for email");
      this.requireTemplateForOutbound(body, "email");
      const template = body.templateId ? await this.requireTemplateApproval(body.templateId, body.campgroundId) : null;
      const consentMeta = await this.ensureChannelConsent("email", body.toAddress, body, body.campgroundId);
      if (this.isQuietHours(campground, /* @__PURE__ */ new Date()) && !body.quietHoursOverride) {
        throw new import_common162.BadRequestException("Quiet hours in effect; try again later or override");
      }
      const senderAddress = body.fromAddress || process.env.SMTP_FROM || "no-reply@campreserv.com";
      const senderDomain = this.ensureVerifiedSenderDomain(senderAddress);
      const html = template?.bodyHtml ?? body.body ?? "";
      const subject = template?.subject ?? body.subject ?? "Message from campground";
      const comm2 = await prisma.communication.create({
        data: {
          campgroundId: body.campgroundId,
          organizationId: body.organizationId ?? null,
          guestId: body.guestId ?? null,
          reservationId: body.reservationId ?? null,
          type: "email",
          direction: "outbound",
          subject,
          body: html,
          preview: html ? html.slice(0, 280) : subject ?? null,
          status: "queued",
          provider: "postmark",
          providerMessageId: null,
          toAddress: body.toAddress,
          fromAddress: senderAddress,
          metadata: {
            senderDomain,
            senderDomainAllowed: true,
            templateId: template?.id ?? null,
            consentSource: consentMeta.consentSource,
            consentCheckedAt: consentMeta.consentCheckedAt,
            consentSubject: consentMeta.consentSubject ?? null,
            consentGrantedAt: consentMeta.consentGrantedAt ?? null,
            clientConsentProvided: clientConsentProvided || void 0
          }
        }
      });
      try {
        const result = await this.emailService.sendEmail({
          to: body.toAddress,
          subject,
          html
        });
        const updated = await prisma.communication.update({
          where: { id: comm2.id },
          data: {
            status: "sent",
            provider: result.provider || "postmark",
            providerMessageId: result.providerMessageId ?? null,
            sentAt: /* @__PURE__ */ new Date(),
            metadata: { ...comm2.metadata, provider: result.provider, fallback: result.fallback }
          }
        });
        this.recordComms("sent", { campgroundId: body.campgroundId, provider: result.provider });
        return updated;
      } catch (err) {
        await prisma.communication.update({
          where: { id: comm2.id },
          data: { status: "failed", metadata: { ...comm2.metadata, error: err?.message } }
        });
        this.recordComms("failed", { campgroundId: body.campgroundId, error: err?.message });
        throw new import_common162.InternalServerErrorException("Failed to send email");
      }
    }
    if (body.type === "sms") {
      const toPhone = body.toPhone || body.toAddress;
      if (!toPhone) throw new import_common162.BadRequestException("toPhone is required for sms");
      this.requireTemplateForOutbound(body, "sms");
      const consentMeta = await this.ensureChannelConsent("sms", toPhone, body, body.campgroundId);
      if (this.isQuietHours(campground, /* @__PURE__ */ new Date()) && !body.quietHoursOverride) {
        throw new import_common162.BadRequestException("Quiet hours in effect; try again later or override");
      }
      const normalizedPhone = this.normalizePhone(toPhone);
      const comm2 = await prisma.communication.create({
        data: {
          campgroundId: body.campgroundId,
          organizationId: body.organizationId ?? null,
          guestId: body.guestId ?? null,
          reservationId: body.reservationId ?? null,
          type: "sms",
          direction: "outbound",
          subject: null,
          body: body.body ?? null,
          preview: body.body ? body.body.slice(0, 280) : null,
          status: "queued",
          provider: "twilio",
          providerMessageId: null,
          toAddress: normalizedPhone,
          fromAddress: body.fromAddress ?? null,
          metadata: {
            consentSource: consentMeta.consentSource,
            consentCheckedAt: consentMeta.consentCheckedAt,
            consentSubject: consentMeta.consentSubject ?? null,
            consentGrantedAt: consentMeta.consentGrantedAt ?? null,
            clientConsentProvided: clientConsentProvided || void 0
          }
        }
      });
      try {
        const result = await this.smsService.sendSms({ to: normalizedPhone, body: body.body ?? "" });
        const updated = await prisma.communication.update({
          where: { id: comm2.id },
          data: {
            status: result.success ? "sent" : "failed",
            provider: result.provider,
            providerMessageId: result.providerMessageId ?? null,
            metadata: { ...comm2.metadata, fallback: result.fallback }
          }
        });
        if (result.success) {
          this.recordComms("sent", { campgroundId: body.campgroundId, provider: result.provider });
        } else {
          this.recordComms("failed", { campgroundId: body.campgroundId, provider: result.provider });
          await this.alerting.dispatch(
            "SMS send failure",
            `Failed to send SMS via ${result.provider} to ${normalizedPhone}`,
            "error",
            `sms-send-failure-${comm2.id}`,
            { campgroundId: body.campgroundId, provider: result.provider, fallback: result.fallback }
          ).catch(() => void 0);
        }
        if (!result.success) throw new import_common162.InternalServerErrorException("Failed to send sms");
        return updated;
      } catch (err) {
        await prisma.communication.update({
          where: { id: comm2.id },
          data: { status: "failed", metadata: { ...comm2.metadata, error: err?.message } }
        });
        this.recordComms("failed", { campgroundId: body.campgroundId, error: err?.message });
        await this.alerting.dispatch(
          "SMS send failure",
          `SMS send errored for ${normalizedPhone}`,
          "error",
          `sms-send-error-${comm2.id}`,
          { campgroundId: body.campgroundId, error: err?.message }
        ).catch(() => void 0);
        throw new import_common162.InternalServerErrorException("Failed to send sms");
      }
    }
    const comm = await prisma.communication.create({
      data: {
        campgroundId: body.campgroundId,
        organizationId: body.organizationId ?? null,
        guestId: body.guestId ?? null,
        reservationId: body.reservationId ?? null,
        type: body.type,
        direction: "outbound",
        subject: body.subject ?? null,
        body: body.body ?? null,
        preview: body.body ? body.body.slice(0, 280) : body.subject ?? null,
        status: "sent",
        provider: body.provider ?? null,
        providerMessageId: body.providerMessageId ?? null,
        toAddress: body.toAddress ?? null,
        fromAddress: body.fromAddress ?? null
      }
    });
    return comm;
  }
  async senderStatus() {
    const allowedList = (process.env.EMAIL_SENDER_DOMAINS || "campreserv.com").split(",").map((d) => d.trim().toLowerCase()).filter(Boolean);
    const verifiedList = (process.env.EMAIL_VERIFIED_DOMAINS || "").split(",").map((d) => d.trim().toLowerCase()).filter(Boolean);
    const defaultFrom = process.env.SMTP_FROM || "no-reply@campreserv.com";
    const domains = allowedList.map((d) => ({
      domain: d,
      allowed: true,
      verified: verifiedList.includes(d),
      issues: verifiedList.includes(d) ? [] : ["Domain not in EMAIL_VERIFIED_DOMAINS (SPF/DKIM/DMARC not confirmed)"]
    }));
    const smsConfigured = Boolean(process.env.TWILIO_WEBHOOK_TOKEN);
    const commsAlertsEnabled = this.commsMetricsEnabled;
    return {
      allowedDomains: allowedList,
      verifiedDomains: verifiedList,
      domains,
      defaultFrom,
      configured: allowedList.length > 0,
      smsWebhookConfigured: smsConfigured,
      commsAlertsEnabled,
      enforcement: "fail_closed",
      note: "Domains must be listed in EMAIL_SENDER_DOMAINS and EMAIL_VERIFIED_DOMAINS after provider verification (SPF/DKIM/DMARC)."
    };
  }
  async twilioInbound(body, token) {
    if (!this.ensureWebhookToken(token)) {
      throw new import_common162.BadRequestException("Invalid webhook token");
    }
    const from = body.From;
    const to = body.To;
    const messageSid = body.MessageSid;
    const text = body.Body;
    if (!from || !to || !messageSid) {
      throw new import_common162.BadRequestException("Missing required Twilio fields");
    }
    const { guestId, reservationId, campgroundId } = await this.resolveGuestAndReservationByPhone(from);
    const communication = await this.prisma.communication.create({
      data: {
        campgroundId: body.campgroundId || campgroundId || "",
        organizationId: null,
        guestId,
        reservationId,
        type: "sms",
        direction: "inbound",
        subject: null,
        body: text ?? null,
        preview: text ? text.slice(0, 280) : null,
        status: "received",
        provider: "twilio",
        providerMessageId: messageSid,
        toAddress: to,
        fromAddress: from,
        receivedAt: /* @__PURE__ */ new Date()
      }
    });
    return { ok: true, id: communication.id };
  }
  async twilioStatus(body, token) {
    if (!this.ensureWebhookToken(token)) {
      throw new import_common162.BadRequestException("Invalid webhook token");
    }
    const messageSid = body.MessageSid;
    if (!messageSid) {
      throw new import_common162.BadRequestException("Missing MessageSid");
    }
    const status = this.normalizeTwilioStatus((body.MessageStatus || body.SmsStatus || "").toString());
    await this.prisma.communication.updateMany({
      where: { providerMessageId: messageSid },
      data: { status, metadata: body }
    });
    if (status === "failed") {
      this.recordComms("failed", { provider: "twilio" });
      await this.alerting.dispatch(
        "SMS delivery failure",
        `Twilio reported failure for message ${messageSid}`,
        "error",
        `sms-delivery-failure-${messageSid}`,
        { status: body.MessageStatus || body.SmsStatus, to: body.To, from: body.From }
      ).catch(() => void 0);
    } else if (status === "delivered") {
      this.recordComms("delivered", { provider: "twilio" });
    } else if (status === "sent" || status === "queued") {
      this.recordComms("sent", { provider: "twilio" });
    }
    return { ok: true };
  }
  async postmarkInbound(body, token) {
    if (!this.ensurePostmarkToken(token)) {
      throw new import_common162.BadRequestException("Invalid webhook token");
    }
    const from = body.FromFull?.Email;
    const to = body.ToFull?.[0]?.Email;
    const subject = body.Subject;
    const textBody = body.TextBody;
    const messageId = body.MessageID;
    if (!from || !to || !messageId) {
      throw new import_common162.BadRequestException("Missing required Postmark fields");
    }
    const normalizedFrom = this.normalizeEmail(from);
    const guest = normalizedFrom ? await this.prisma.guest.findFirst({
      where: { email: { equals: normalizedFrom, mode: "insensitive" } },
      select: { id: true }
    }) : null;
    const reservation = guest ? await this.prisma.reservation.findFirst({
      where: { guestId: guest.id },
      orderBy: { createdAt: "desc" },
      select: { id: true, campgroundId: true }
    }) : null;
    const communication = await this.prisma.communication.create({
      data: {
        campgroundId: body.campgroundId || reservation?.campgroundId || "",
        organizationId: null,
        guestId: guest?.id ?? null,
        reservationId: reservation?.id ?? null,
        type: "email",
        direction: "inbound",
        subject: subject ?? null,
        body: textBody ?? null,
        preview: textBody ? textBody.slice(0, 280) : subject ?? null,
        status: "received",
        provider: "postmark",
        providerMessageId: messageId,
        toAddress: to,
        fromAddress: from,
        receivedAt: /* @__PURE__ */ new Date()
      }
    });
    return { ok: true, id: communication.id };
  }
  async postmarkStatus(body, token) {
    if (!this.ensurePostmarkToken(token)) {
      throw new import_common162.BadRequestException("Invalid webhook token");
    }
    const messageId = body.MessageID;
    if (!messageId) {
      throw new import_common162.BadRequestException("Missing MessageID");
    }
    const status = this.normalizePostmarkStatus(body.RecordType);
    const bounceTypeRaw = body.BounceType;
    const bounceType = (bounceTypeRaw || "").toString().toLowerCase();
    const isHardFail = status === "bounced" || status === "spam_complaint" || bounceType === "hardbounce";
    const finalStatus = isHardFail ? "failed" : status;
    const metadata = {
      ...body,
      normalizedStatus: status,
      bounceType: bounceTypeRaw,
      bounceSubType: body.BounceSubType,
      description: body.Description
    };
    await this.prisma.communication.updateMany({
      where: { providerMessageId: messageId },
      data: { status: finalStatus, metadata }
    });
    if (finalStatus === "failed" || finalStatus === "bounced") {
      this.recordComms("bounced", { provider: "postmark", bounceType });
      await this.alerting.dispatch(
        "Email bounced",
        `Postmark message ${messageId} bounced (${bounceType || status})`,
        "warning",
        `postmark-bounce-${messageId}`,
        { bounceType: bounceTypeRaw || body.BounceType, description: body.Description }
      );
    } else if (finalStatus === "spam_complaint") {
      this.recordComms("spam_complaint", { provider: "postmark" });
      await this.alerting.dispatch(
        "Spam complaint",
        `Postmark complaint for message ${messageId}`,
        "error",
        `postmark-complaint-${messageId}`,
        { bounceType, description: body.Description }
      );
    } else if (finalStatus === "delivered" || finalStatus === "sent") {
      this.recordComms("delivered", { provider: "postmark" });
    }
    return { ok: true };
  }
  async listTemplates(campgroundId, status) {
    if (!campgroundId) throw new import_common162.BadRequestException("campgroundId is required");
    const where = { campgroundId };
    if (status) where.status = status;
    const templates = await this.prisma.communicationTemplate.findMany({
      where,
      orderBy: [{ updatedAt: "desc" }]
    });
    return templates;
  }
  async createTemplate(body) {
    if (!body.campgroundId || !body.name) {
      throw new import_common162.BadRequestException("campgroundId and name are required");
    }
    const template = await this.prisma.communicationTemplate.create({
      data: {
        campgroundId: body.campgroundId,
        name: body.name,
        subject: body.subject ?? null,
        bodyHtml: body.bodyHtml ?? null,
        status: "draft",
        version: 1,
        auditLog: [{ action: "created", at: (/* @__PURE__ */ new Date()).toISOString() }]
      }
    });
    return template;
  }
  async updateTemplate(id, body, campgroundId) {
    const existing = await this.prisma.communicationTemplate.findUnique({ where: { id } });
    if (!existing) throw new import_common162.BadRequestException("Template not found");
    if (campgroundId && existing.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Unauthorized campground scope");
    }
    const auditEntry = {
      action: "updated",
      at: (/* @__PURE__ */ new Date()).toISOString(),
      changes: ["name", "subject", "bodyHtml", "status"].reduce((acc, key) => {
        if (body[key] !== void 0 && body[key] !== existing[key]) {
          acc[key] = { from: existing[key], to: body[key] };
        }
        return acc;
      }, {})
    };
    const updated = await this.prisma.communicationTemplate.update({
      where: { id },
      data: {
        name: body.name ?? existing.name,
        subject: body.subject ?? existing.subject,
        bodyHtml: body.bodyHtml ?? existing.bodyHtml,
        status: body.status ?? existing.status,
        auditLog: [...existing.auditLog ?? [], auditEntry]
      }
    });
    return updated;
  }
  async listJobs(campgroundId, status) {
    if (!campgroundId) throw new import_common162.BadRequestException("campgroundId is required");
    const where = { campgroundId };
    if (status) where.status = status;
    return this.prisma.communicationPlaybookJob.findMany({
      where,
      orderBy: [{ scheduledAt: "asc" }]
    });
  }
  async processJob(job) {
    const playbook = await this.prisma.communicationPlaybook.findUnique({
      where: { id: job.playbookId },
      include: { campground: true, template: true }
    });
    if (!playbook || !playbook.enabled) {
      await this.prisma.communicationPlaybookJob.update({ where: { id: job.id }, data: { status: "skipped", lastError: "Playbook disabled" } });
      return;
    }
    if (!playbook.template || playbook.template.status !== "approved") {
      await this.prisma.communicationPlaybookJob.update({ where: { id: job.id }, data: { status: "skipped", lastError: "Template not approved" } });
      return;
    }
    const now = /* @__PURE__ */ new Date();
    if (this.isQuietHours(playbook.campground, now)) {
      const [eh, em] = (playbook.campground.quietHoursEnd || "08:00").split(":").map((n) => Number(n));
      const tz = this.campgroundTz(playbook.campground);
      const localParts = this.getLocalTimeParts(now, tz);
      const next = this.buildZonedDate(
        { year: localParts.year, month: localParts.month, day: localParts.day },
        { hour: eh || 8, minute: em || 0 },
        tz
      );
      if (next <= now) {
        const tomorrow = new Date(next.getTime() + 24 * 60 * 60 * 1e3);
        const tomorrowParts = this.getLocalTimeParts(tomorrow, tz);
        next.setTime(
          this.buildZonedDate(
            { year: tomorrowParts.year, month: tomorrowParts.month, day: tomorrowParts.day },
            { hour: eh || 8, minute: em || 0 },
            tz
          ).getTime()
        );
      }
      await this.prisma.communicationPlaybookJob.update({
        where: { id: job.id },
        data: { scheduledAt: next, attempts: job.attempts + 1 }
      });
      return;
    }
    const reservation = job.reservationId ? await this.prisma.reservation.findUnique({ where: { id: job.reservationId }, include: { guest: true } }) : null;
    const guest = reservation?.guest || (job.guestId ? await this.prisma.guest.findUnique({ where: { id: job.guestId } }) : null);
    const toEmail = guest?.email || reservation?.guest?.email;
    const toPhone = guest?.phone || reservation?.guest?.phone;
    try {
      await this.prisma.communicationPlaybookJob.update({ where: { id: job.id }, data: { status: "processing", attempts: job.attempts + 1 } });
      if (playbook.type === "nps") {
        if (!toEmail) throw new Error("Missing recipient email");
        const metadata = job.metadata || {};
        const surveyId = metadata.surveyId;
        if (!surveyId) throw new Error("Missing surveyId for NPS job");
        const templateId = metadata.templateId || playbook.templateId || null;
        await this.npsService.createInvite({
          surveyId,
          campgroundId: job.campgroundId,
          guestId: job.guestId ?? void 0,
          reservationId: job.reservationId ?? void 0,
          channel: "email",
          email: toEmail,
          templateId: templateId ?? void 0,
          expireDays: 30
        });
      } else if (playbook.channel === "email") {
        if (!toEmail) throw new Error("Missing recipient email");
        await this.emailService.sendEmail({
          to: toEmail,
          subject: playbook.template.subject || "Message from campground",
          html: playbook.template.bodyHtml || ""
        });
      } else if (playbook.channel === "sms") {
        if (!toPhone) throw new Error("Missing recipient phone");
        await this.smsService.sendSms({ to: toPhone, body: playbook.template.bodyHtml || playbook.template.subject || "Message" });
      }
      await this.prisma.communicationPlaybookJob.update({
        where: { id: job.id },
        data: { status: "sent", lastError: null }
      });
    } catch (err) {
      const attempts = job.attempts + 1;
      const maxAttempts = 3;
      const nextTime = new Date(now);
      nextTime.setMinutes(nextTime.getMinutes() + Math.min(30, attempts * 5));
      await this.prisma.communicationPlaybookJob.update({
        where: { id: job.id },
        data: {
          status: attempts >= maxAttempts ? "failed" : "pending",
          scheduledAt: attempts >= maxAttempts ? job.scheduledAt : nextTime,
          attempts,
          lastError: err?.message || "Send failed"
        }
      });
    }
  }
  async runPlaybookJobs(campgroundId) {
    const now = /* @__PURE__ */ new Date();
    const jobs = await this.prisma.communicationPlaybookJob.findMany({
      where: {
        status: "pending",
        scheduledAt: { lte: now },
        ...campgroundId ? { campgroundId } : {}
      },
      orderBy: { scheduledAt: "asc" },
      take: 25
    });
    for (const job of jobs) {
      await this.processJob(job);
    }
    return { processed: jobs.length };
  }
  // every 5 minutes
  async cronRunPlaybookJobs() {
    await this.runPlaybookJobs();
  }
  async retryPlaybookJob(id, campgroundId) {
    const job = await this.prisma.communicationPlaybookJob.findUnique({ where: { id } });
    if (!job) throw new import_common162.BadRequestException("Job not found");
    if (campgroundId && job.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Job does not belong to this campground");
    }
    const updated = await this.prisma.communicationPlaybookJob.update({
      where: { id },
      data: {
        status: "pending",
        scheduledAt: /* @__PURE__ */ new Date(),
        lastError: null
      }
    });
    return updated;
  }
  async enqueueUnpaidPlaybooks(campgroundId) {
    const reservations = await this.prisma.reservation.findMany({
      where: {
        ...campgroundId ? { campgroundId } : {},
        status: { not: "cancelled" },
        totalAmount: { gt: 0 }
      },
      select: { id: true, campgroundId: true, guestId: true, totalAmount: true, paidAmount: true }
    });
    const due = reservations.filter((r) => Number(r.paidAmount || 0) < Number(r.totalAmount || 0));
    const playbooks = await this.prisma.communicationPlaybook.findMany({
      where: {
        ...campgroundId ? { campgroundId } : {},
        type: "unpaid",
        enabled: true,
        templateId: { not: null }
      }
    });
    let enqueued = 0;
    for (const pb of playbooks) {
      const tpl = await this.prisma.communicationTemplate.findFirst({
        where: { id: pb.templateId, status: "approved" }
      });
      if (!tpl) continue;
      for (const r of due.filter((d) => d.campgroundId === pb.campgroundId)) {
        const scheduledAt = /* @__PURE__ */ new Date();
        if (pb.offsetMinutes && Number.isFinite(pb.offsetMinutes)) {
          scheduledAt.setMinutes(scheduledAt.getMinutes() + pb.offsetMinutes);
        }
        await this.prisma.communicationPlaybookJob.create({
          data: {
            playbookId: pb.id,
            campgroundId: r.campgroundId,
            reservationId: r.id,
            guestId: r.guestId,
            status: "pending",
            scheduledAt
          }
        });
        enqueued++;
      }
    }
    return { enqueued };
  }
  async approveTemplate(id, body, campgroundId, actorId) {
    const existing = await this.prisma.communicationTemplate.findUnique({ where: { id } });
    if (!existing) throw new import_common162.BadRequestException("Template not found");
    if (campgroundId && existing.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Unauthorized campground scope");
    }
    const auditEntry = {
      action: "approved",
      at: (/* @__PURE__ */ new Date()).toISOString(),
      actorId: actorId ?? null,
      reason: body.reason ?? null
    };
    const updated = await this.prisma.communicationTemplate.update({
      where: { id },
      data: {
        status: "approved",
        approvedById: actorId ?? null,
        approvedAt: /* @__PURE__ */ new Date(),
        auditLog: [...existing.auditLog ?? [], auditEntry]
      }
    });
    return updated;
  }
  async rejectTemplate(id, body, campgroundId, actorId) {
    const existing = await this.prisma.communicationTemplate.findUnique({ where: { id } });
    if (!existing) throw new import_common162.BadRequestException("Template not found");
    if (campgroundId && existing.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Unauthorized campground scope");
    }
    const auditEntry = {
      action: "rejected",
      at: (/* @__PURE__ */ new Date()).toISOString(),
      actorId: actorId ?? null,
      reason: body.reason ?? null
    };
    const updated = await this.prisma.communicationTemplate.update({
      where: { id },
      data: {
        status: "rejected",
        approvedById: null,
        approvedAt: null,
        auditLog: [...existing.auditLog ?? [], auditEntry]
      }
    });
    return updated;
  }
  async listPlaybooks(campgroundId) {
    if (!campgroundId) throw new import_common162.BadRequestException("campgroundId is required");
    return this.prisma.communicationPlaybook.findMany({
      where: { campgroundId },
      orderBy: { updatedAt: "desc" }
    });
  }
  async createPlaybook(body) {
    if (!body.campgroundId || !body.type) throw new import_common162.BadRequestException("campgroundId and type are required");
    return this.prisma.communicationPlaybook.create({
      data: {
        campgroundId: body.campgroundId,
        type: body.type,
        enabled: body.enabled ?? false,
        templateId: body.templateId ?? null,
        channel: body.channel ?? null,
        offsetMinutes: body.offsetMinutes ?? null,
        quietHoursStart: body.quietHoursStart ?? null,
        quietHoursEnd: body.quietHoursEnd ?? null,
        throttlePerMinute: body.throttlePerMinute ?? null,
        routingAssigneeId: body.routingAssigneeId ?? null
      }
    });
  }
  async updatePlaybook(id, body, campgroundId) {
    const existing = await this.prisma.communicationPlaybook.findUnique({ where: { id } });
    if (!existing) throw new import_common162.BadRequestException("Playbook not found");
    if (campgroundId && existing.campgroundId !== campgroundId) {
      throw new import_common162.BadRequestException("Unauthorized campground scope");
    }
    return this.prisma.communicationPlaybook.update({
      where: { id },
      data: {
        enabled: body.enabled ?? existing.enabled,
        templateId: body.templateId !== void 0 ? body.templateId : existing.templateId,
        channel: body.channel !== void 0 ? body.channel : existing.channel,
        offsetMinutes: body.offsetMinutes !== void 0 ? body.offsetMinutes : existing.offsetMinutes,
        quietHoursStart: body.quietHoursStart !== void 0 ? body.quietHoursStart : existing.quietHoursStart,
        quietHoursEnd: body.quietHoursEnd !== void 0 ? body.quietHoursEnd : existing.quietHoursEnd,
        throttlePerMinute: body.throttlePerMinute !== void 0 ? body.throttlePerMinute : existing.throttlePerMinute,
        routingAssigneeId: body.routingAssigneeId !== void 0 ? body.routingAssigneeId : existing.routingAssigneeId
      }
    });
  }
};
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "communications", action: "write" }),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.front_desk, import_client26.UserRole.finance, import_client26.UserRole.marketing, import_client26.UserRole.readonly),
  (0, import_common162.Post)("communications"),
  __decorateParam(0, (0, import_common162.Body)())
], CommunicationsController.prototype, "create", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "communications", action: "read" }),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.front_desk, import_client26.UserRole.finance, import_client26.UserRole.marketing, import_client26.UserRole.readonly),
  (0, import_common162.Get)("communications"),
  __decorateParam(0, (0, import_common162.Query)())
], CommunicationsController.prototype, "list", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "communications", action: "write" }),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.front_desk, import_client26.UserRole.finance, import_client26.UserRole.marketing),
  (0, import_common162.Post)("communications/send"),
  __decorateParam(0, (0, import_common162.Body)())
], CommunicationsController.prototype, "send", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  RequireScope({ resource: "communications", action: "read" }),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.front_desk, import_client26.UserRole.finance, import_client26.UserRole.marketing, import_client26.UserRole.readonly),
  (0, import_common162.Get)("communications/sender-status")
], CommunicationsController.prototype, "senderStatus", 1);
__decorateClass([
  (0, import_common162.Post)("communications/webhook/twilio"),
  __decorateParam(0, (0, import_common162.Body)()),
  __decorateParam(1, (0, import_common162.Query)("token"))
], CommunicationsController.prototype, "twilioInbound", 1);
__decorateClass([
  (0, import_common162.Post)("communications/webhook/twilio/status"),
  __decorateParam(0, (0, import_common162.Body)()),
  __decorateParam(1, (0, import_common162.Query)("token"))
], CommunicationsController.prototype, "twilioStatus", 1);
__decorateClass([
  (0, import_common162.Post)("communications/webhook/postmark/inbound"),
  __decorateParam(0, (0, import_common162.Body)()),
  __decorateParam(1, (0, import_common162.Query)("token"))
], CommunicationsController.prototype, "postmarkInbound", 1);
__decorateClass([
  (0, import_common162.HttpCode)(200),
  (0, import_common162.Post)("communications/webhook/postmark/status"),
  __decorateParam(0, (0, import_common162.Body)()),
  __decorateParam(1, (0, import_common162.Query)("token"))
], CommunicationsController.prototype, "postmarkStatus", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Get)("communications/templates"),
  __decorateParam(0, (0, import_common162.Query)("campgroundId")),
  __decorateParam(1, (0, import_common162.Query)("status"))
], CommunicationsController.prototype, "listTemplates", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Post)("communications/templates"),
  __decorateParam(0, (0, import_common162.Body)())
], CommunicationsController.prototype, "createTemplate", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Patch)("communications/templates/:id"),
  __decorateParam(0, (0, import_common162.Param)("id")),
  __decorateParam(1, (0, import_common162.Body)()),
  __decorateParam(2, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "updateTemplate", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Get)("communications/playbooks/jobs"),
  __decorateParam(0, (0, import_common162.Query)("campgroundId")),
  __decorateParam(1, (0, import_common162.Query)("status"))
], CommunicationsController.prototype, "listJobs", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Post)("communications/playbooks/run"),
  __decorateParam(0, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "runPlaybookJobs", 1);
__decorateClass([
  (0, import_schedule7.Cron)("*/5 * * * *")
], CommunicationsController.prototype, "cronRunPlaybookJobs", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Post)("communications/playbooks/jobs/:id/retry"),
  __decorateParam(0, (0, import_common162.Param)("id")),
  __decorateParam(1, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "retryPlaybookJob", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.finance),
  (0, import_common162.Post)("communications/playbooks/enqueue-unpaid"),
  __decorateParam(0, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "enqueueUnpaidPlaybooks", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager),
  (0, import_common162.Post)("communications/templates/:id/approve"),
  __decorateParam(0, (0, import_common162.Param)("id")),
  __decorateParam(1, (0, import_common162.Body)()),
  __decorateParam(2, (0, import_common162.Query)("campgroundId")),
  __decorateParam(3, (0, import_common162.Query)("actorId"))
], CommunicationsController.prototype, "approveTemplate", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager),
  (0, import_common162.Post)("communications/templates/:id/reject"),
  __decorateParam(0, (0, import_common162.Param)("id")),
  __decorateParam(1, (0, import_common162.Body)()),
  __decorateParam(2, (0, import_common162.Query)("campgroundId")),
  __decorateParam(3, (0, import_common162.Query)("actorId"))
], CommunicationsController.prototype, "rejectTemplate", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Get)("communications/playbooks"),
  __decorateParam(0, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "listPlaybooks", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Post)("communications/playbooks"),
  __decorateParam(0, (0, import_common162.Body)())
], CommunicationsController.prototype, "createPlaybook", 1);
__decorateClass([
  (0, import_common162.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client26.UserRole.owner, import_client26.UserRole.manager, import_client26.UserRole.marketing),
  (0, import_common162.Patch)("communications/playbooks/:id"),
  __decorateParam(0, (0, import_common162.Param)("id")),
  __decorateParam(1, (0, import_common162.Body)()),
  __decorateParam(2, (0, import_common162.Query)("campgroundId"))
], CommunicationsController.prototype, "updatePlaybook", 1);
CommunicationsController = __decorateClass([
  (0, import_common162.Controller)()
], CommunicationsController);

// src/nps/nps.module.ts
var import_common168 = require("@nestjs/common");

// src/nps/nps.controller.ts
var import_common163 = require("@nestjs/common");
var import_client27 = require("@prisma/client");
var NpsController = class {
  constructor(npsService) {
    this.npsService = npsService;
  }
  createSurvey(dto) {
    return this.npsService.createSurvey(dto);
  }
  listSurveys(campgroundId) {
    return this.npsService.listSurveys(campgroundId);
  }
  addRule(dto) {
    return this.npsService.addRule(dto);
  }
  createInvite(dto) {
    return this.npsService.createInvite(dto);
  }
  respond(dto) {
    return this.npsService.respond(dto);
  }
  recordOpen(token) {
    return this.npsService.recordOpen(token);
  }
  metrics(campgroundId) {
    return this.npsService.metrics(campgroundId);
  }
};
__decorateClass([
  (0, import_common163.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client27.UserRole.owner, import_client27.UserRole.manager, import_client27.UserRole.marketing, import_client27.UserRole.front_desk),
  (0, import_common163.Post)("nps/surveys"),
  __decorateParam(0, (0, import_common163.Body)())
], NpsController.prototype, "createSurvey", 1);
__decorateClass([
  (0, import_common163.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client27.UserRole.owner, import_client27.UserRole.manager, import_client27.UserRole.marketing, import_client27.UserRole.front_desk, import_client27.UserRole.readonly),
  (0, import_common163.Get)("nps/surveys"),
  __decorateParam(0, (0, import_common163.Query)("campgroundId"))
], NpsController.prototype, "listSurveys", 1);
__decorateClass([
  (0, import_common163.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client27.UserRole.owner, import_client27.UserRole.manager, import_client27.UserRole.marketing),
  (0, import_common163.Post)("nps/rules"),
  __decorateParam(0, (0, import_common163.Body)())
], NpsController.prototype, "addRule", 1);
__decorateClass([
  (0, import_common163.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client27.UserRole.owner, import_client27.UserRole.manager, import_client27.UserRole.marketing, import_client27.UserRole.front_desk),
  (0, import_common163.Post)("nps/invites"),
  __decorateParam(0, (0, import_common163.Body)())
], NpsController.prototype, "createInvite", 1);
__decorateClass([
  (0, import_common163.Post)("nps/respond"),
  __decorateParam(0, (0, import_common163.Body)())
], NpsController.prototype, "respond", 1);
__decorateClass([
  (0, import_common163.Post)("nps/open"),
  __decorateParam(0, (0, import_common163.Body)("token"))
], NpsController.prototype, "recordOpen", 1);
__decorateClass([
  (0, import_common163.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client27.UserRole.owner, import_client27.UserRole.manager, import_client27.UserRole.marketing, import_client27.UserRole.front_desk, import_client27.UserRole.readonly),
  (0, import_common163.Get)("nps/metrics"),
  __decorateParam(0, (0, import_common163.Query)("campgroundId"))
], NpsController.prototype, "metrics", 1);
NpsController = __decorateClass([
  (0, import_common163.Controller)()
], NpsController);

// src/nps/nps.service.ts
var import_common164 = require("@nestjs/common");
var import_crypto15 = require("crypto");
var import_schedule8 = require("@nestjs/schedule");
function baseAppUrl() {
  const url = process.env.PUBLIC_WEB_URL || process.env.NEXT_PUBLIC_APP_URL || "https://app.campreserv.com";
  return url.endsWith("/") ? url.slice(0, -1) : url;
}
var NpsService = class {
  constructor(prisma, emailService, supportService) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.supportService = supportService;
  }
  async createSurvey(dto) {
    const prisma = this.prisma;
    return prisma.npsSurvey.create({
      data: {
        campgroundId: dto.campgroundId,
        name: dto.name,
        question: dto.question ?? "How likely are you to recommend us to a friend?",
        channels: dto.channels ?? ["inapp", "email"],
        locales: dto.locales ?? ["en"],
        cooldownDays: dto.cooldownDays ?? 30,
        samplingPercent: dto.samplingPercent ?? 100,
        activeFrom: dto.activeFrom ? new Date(dto.activeFrom) : null,
        activeTo: dto.activeTo ? new Date(dto.activeTo) : null,
        status: "active"
      }
    });
  }
  async listSurveys(campgroundId) {
    const prisma = this.prisma;
    return prisma.npsSurvey.findMany({
      where: { campgroundId },
      include: { rules: true },
      orderBy: { createdAt: "desc" }
    });
  }
  async addRule(dto) {
    const prisma = this.prisma;
    const survey = await prisma.npsSurvey.findUnique({ where: { id: dto.surveyId } });
    if (!survey) throw new import_common164.NotFoundException("Survey not found");
    return prisma.npsRule.create({
      data: {
        surveyId: dto.surveyId,
        trigger: dto.trigger,
        percentage: dto.percentage ?? survey.samplingPercent ?? 100,
        cooldownDays: dto.cooldownDays ?? survey.cooldownDays ?? 30,
        segmentJson: dto.segmentJson,
        isActive: dto.isActive ?? true
      }
    });
  }
  generateToken() {
    return (0, import_crypto15.randomBytes)(24).toString("hex");
  }
  async resolveGuestContact(guestId, reservationId, email, phone) {
    if (guestId) {
      const guest = await this.prisma.guest.findUnique({
        where: { id: guestId },
        select: { email: true, phone: true, primaryFirstName: true, primaryLastName: true }
      });
      if (guest) {
        return {
          email: email ?? guest.email,
          phone: phone ?? guest.phone,
          name: `${guest.primaryFirstName} ${guest.primaryLastName}`
        };
      }
    }
    if (reservationId) {
      const reservation = await this.prisma.reservation.findUnique({
        where: { id: reservationId },
        select: {
          guest: { select: { email: true, phone: true, primaryFirstName: true, primaryLastName: true } }
        }
      });
      if (reservation?.guest) {
        const g = reservation.guest;
        return {
          email: email ?? g.email,
          phone: phone ?? g.phone,
          name: `${g.primaryFirstName} ${g.primaryLastName}`
        };
      }
    }
    return { email, phone, name: void 0 };
  }
  async createInvite(dto) {
    const prisma = this.prisma;
    const survey = await prisma.npsSurvey.findUnique({
      where: { id: dto.surveyId },
      include: { campground: { select: { name: true } } }
    });
    if (!survey) throw new import_common164.NotFoundException("Survey not found");
    if (survey.status !== "active") throw new import_common164.BadRequestException("Survey is not active");
    if (survey.activeFrom && survey.activeFrom > /* @__PURE__ */ new Date()) throw new import_common164.BadRequestException("Survey not yet active");
    if (survey.activeTo && survey.activeTo < /* @__PURE__ */ new Date()) throw new import_common164.BadRequestException("Survey expired");
    const contact = await this.resolveGuestContact(dto.guestId, dto.reservationId, dto.email, dto.phone);
    const cooldownDays = survey.cooldownDays ?? 30;
    if (dto.guestId && cooldownDays > 0) {
      const recent = await prisma.npsInvite.findFirst({
        where: {
          guestId: dto.guestId,
          surveyId: dto.surveyId,
          createdAt: { gte: new Date(Date.now() - cooldownDays * 24 * 60 * 60 * 1e3) }
        }
      });
      if (recent) {
        throw new import_common164.BadRequestException("Guest already invited within cooldown window");
      }
    }
    const token = this.generateToken();
    const expiresAt = dto.expireDays ? new Date(Date.now() + dto.expireDays * 24 * 60 * 60 * 1e3) : null;
    const link = `${baseAppUrl()}/nps/respond?token=${token}`;
    const invite = await prisma.npsInvite.create({
      data: {
        surveyId: dto.surveyId,
        campgroundId: dto.campgroundId,
        organizationId: dto.organizationId ?? null,
        guestId: dto.guestId ?? null,
        reservationId: dto.reservationId ?? null,
        channel: dto.channel,
        status: dto.channel === "email" ? "sent" : "queued",
        token,
        expiresAt,
        sentAt: dto.channel === "email" ? /* @__PURE__ */ new Date() : null,
        metadata: { link }
      }
    });
    if (dto.channel === "email") {
      if (!contact.email) throw new import_common164.BadRequestException("Email required for email channel");
      const guestName = contact.name || "there";
      let subject = `How was your stay at ${survey.campground.name}?`;
      let html = `
        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 640px; margin: 0 auto; padding: 20px;">
          <h2 style="color: #0f172a; margin-bottom: 8px;">Hi ${guestName},</h2>
          <p style="color: #475569; line-height: 1.6;">We'd love your quick feedback. How likely are you to recommend us to a friend or colleague?</p>
          <p style="margin: 16px 0;">
            <a href="${link}" style="background: #0ea5e9; color: white; padding: 12px 18px; border-radius: 8px; text-decoration: none; font-weight: 600;">Rate your stay</a>
          </p>
          <p style="color: #94a3b8; font-size: 12px;">This link is unique to you and may expire.</p>
        </div>
      `;
      if (dto.templateId) {
        const template = await prisma.communicationTemplate.findFirst({
          where: { id: dto.templateId, campgroundId: dto.campgroundId }
        });
        if (!template) {
          throw new import_common164.BadRequestException("Template not found for this campground");
        }
        if (template.status !== "approved") {
          throw new import_common164.BadRequestException("Template not approved");
        }
        subject = template.subject || subject;
        const linkHtml = `<p><a href="${link}" style="color:#0ea5e9;font-weight:600;">Rate your stay</a></p>`;
        html = (template.bodyHtml || html).replace("{{nps_link}}", link).replace("{{npsLink}}", link);
        if (!html.includes(link)) {
          html += linkHtml;
        }
      }
      await this.emailService.sendEmail({
        to: contact.email,
        subject,
        html,
        guestId: dto.guestId,
        reservationId: dto.reservationId,
        campgroundId: dto.campgroundId
      });
    }
    return invite;
  }
  async recordOpen(token) {
    const prisma = this.prisma;
    const invite = await prisma.npsInvite.findUnique({ where: { token } });
    if (!invite) throw new import_common164.NotFoundException("Invite not found");
    await prisma.npsInvite.update({
      where: { id: invite.id },
      data: { openedAt: invite.openedAt ?? /* @__PURE__ */ new Date(), status: invite.status === "queued" ? "opened" : invite.status }
    });
    await prisma.npsEvent.create({
      data: { inviteId: invite.id, type: "open" }
    });
    return { ok: true };
  }
  async respond(dto, ip) {
    const prisma = this.prisma;
    const invite = await prisma.npsInvite.findUnique({
      where: { token: dto.token },
      include: { survey: true }
    });
    if (!invite) throw new import_common164.NotFoundException("Invite not found");
    if (invite.expiresAt && invite.expiresAt < /* @__PURE__ */ new Date()) {
      await prisma.npsInvite.update({ where: { id: invite.id }, data: { status: "expired" } });
      throw new import_common164.BadRequestException("Invite expired");
    }
    if (invite.respondedAt) throw new import_common164.BadRequestException("Invite already used");
    const response = await prisma.npsResponse.create({
      data: {
        surveyId: invite.surveyId,
        inviteId: invite.id,
        campgroundId: invite.campgroundId,
        guestId: invite.guestId,
        reservationId: invite.reservationId,
        score: dto.score,
        comment: dto.comment ?? null,
        tags: dto.tags ?? [],
        sentiment: null
      }
    });
    await prisma.npsInvite.update({
      where: { id: invite.id },
      data: { respondedAt: /* @__PURE__ */ new Date(), status: "responded" }
    });
    await prisma.npsEvent.create({
      data: { inviteId: invite.id, type: "respond", payload: { ip } }
    });
    if (dto.score <= 6) {
      await this.supportService.create({
        description: `NPS detractor (${dto.score})`,
        steps: dto.comment || "No comment provided",
        contactEmail: void 0,
        path: "/nps/respond",
        roleFilter: void 0,
        pinnedIds: [],
        recentIds: [],
        rawContext: { inviteId: invite.id, surveyId: invite.surveyId, score: dto.score },
        campgroundId: invite.campgroundId
      });
      if (process.env.NPS_ALERT_EMAIL) {
        await this.emailService.sendEmail({
          to: process.env.NPS_ALERT_EMAIL,
          subject: `Detractor alert (${dto.score}) for survey ${invite.surveyId}`,
          html: `<p>Score: ${dto.score}</p><p>Comment: ${dto.comment || "None"}</p><p>Invite: ${invite.id}</p>`
        });
      }
    }
    if (dto.score >= 9) {
      const reviewToken = this.generateToken();
      await prisma.reviewRequest.create({
        data: {
          campgroundId: invite.campgroundId,
          organizationId: invite.organizationId ?? null,
          guestId: invite.guestId ?? null,
          reservationId: invite.reservationId ?? null,
          channel: "inapp",
          status: "queued",
          token: reviewToken,
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
          metadata: { source: "nps_promoter", inviteId: invite.id }
        }
      });
    }
    return response;
  }
  parseSchedule(raw, defaultTemplateId) {
    const entries = Array.isArray(raw) ? raw : [];
    const safeEntries = entries.map((e) => ({
      id: e.id || (0, import_crypto15.randomBytes)(6).toString("hex"),
      anchor: e.anchor === "arrival" ? "arrival" : "departure",
      direction: e.direction === "before" ? "before" : "after",
      offset: Number.isFinite(e.offset) ? Number(e.offset) : 0,
      unit: e.unit === "hours" ? "hours" : "days",
      templateId: e.templateId || defaultTemplateId || null,
      enabled: e.enabled !== false
    })).filter((e) => e.enabled);
    safeEntries.push({
      id: "nps-post-departure-default",
      anchor: "departure",
      direction: "after",
      offset: 1,
      unit: "days",
      templateId: defaultTemplateId || null,
      enabled: true
    });
    return safeEntries;
  }
  computeScheduledTime(anchorDate, entry, sendHour) {
    const target = new Date(anchorDate);
    const deltaMs = entry.unit === "hours" ? entry.offset * 60 * 60 * 1e3 : entry.offset * 24 * 60 * 60 * 1e3;
    const signed = entry.direction === "before" ? -deltaMs : deltaMs;
    const shifted = new Date(target.getTime() + signed);
    shifted.setHours(sendHour, 0, 0, 0);
    return shifted;
  }
  async sendPostCheckoutInvites() {
    const prisma = this.prisma;
    const now = /* @__PURE__ */ new Date();
    const campgrounds = await prisma.campground.findMany({
      select: { id: true, timezone: true, npsAutoSendEnabled: true, npsSendHour: true, npsTemplateId: true, npsSchedule: true }
    });
    const surveys = await prisma.npsSurvey.findMany({
      where: { status: "active" },
      select: { id: true, campgroundId: true },
      include: { rules: { where: { trigger: "post_checkout", isActive: true } } }
    });
    for (const cg of campgrounds) {
      if (!cg.npsAutoSendEnabled) continue;
      const sendHour = cg.npsSendHour ?? 7;
      const schedule = this.parseSchedule(cg.npsSchedule, cg.npsTemplateId);
      if (!schedule.length) continue;
      const cgSurveys = surveys.filter((s) => s.campgroundId === cg.id && s.rules.length > 0);
      if (cgSurveys.length === 0) continue;
      const surveyId = cgSurveys[0].id;
      let playbook = await prisma.communicationPlaybook.findFirst({
        where: { campgroundId: cg.id, type: "nps" }
      });
      if (!playbook) {
        playbook = await prisma.communicationPlaybook.create({
          data: {
            campgroundId: cg.id,
            type: "nps",
            enabled: true,
            templateId: cg.npsTemplateId ?? null,
            channel: "email"
          }
        });
      }
      const reservations = await prisma.reservation.findMany({
        where: { campgroundId: cg.id, status: { not: "cancelled" } },
        select: {
          id: true,
          guestId: true,
          arrivalDate: true,
          departureDate: true,
          status: true,
          guest: { select: { email: true, phone: true, primaryFirstName: true, primaryLastName: true } }
        }
      });
      for (const res of reservations) {
        for (const entry of schedule) {
          const anchorDate = entry.anchor === "arrival" ? res.arrivalDate : res.departureDate;
          if (!anchorDate) continue;
          const target = this.computeScheduledTime(anchorDate, entry, sendHour);
          const windowStart = target;
          const windowEnd = new Date(target.getTime() + 60 * 60 * 1e3);
          if (now < windowStart || now > windowEnd) continue;
          const existingJob = await prisma.communicationPlaybookJob.findFirst({
            where: {
              campgroundId: cg.id,
              reservationId: res.id,
              playbookId: playbook.id,
              metadata: { path: ["entryId"], equals: entry.id }
            }
          });
          if (existingJob) continue;
          await prisma.communicationPlaybookJob.create({
            data: {
              playbookId: playbook.id,
              campgroundId: cg.id,
              reservationId: res.id,
              guestId: res.guestId ?? null,
              status: "pending",
              scheduledAt: target,
              metadata: {
                entryId: entry.id,
                surveyId,
                templateId: entry.templateId ?? cg.npsTemplateId ?? playbook.templateId ?? null
              }
            }
          });
        }
      }
    }
  }
  getLocalHour(now, tz) {
    try {
      const formatter = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        hour: "2-digit",
        timeZone: tz || "UTC"
      });
      const parts = formatter.formatToParts(now);
      const hourPart = parts.find((p) => p.type === "hour")?.value;
      return hourPart ? parseInt(hourPart, 10) : now.getUTCHours();
    } catch {
      return now.getUTCHours();
    }
  }
  async metrics(campgroundId) {
    const prisma = this.prisma;
    const [responses, invites] = await Promise.all([
      prisma.npsResponse.findMany({
        where: { campgroundId },
        select: { score: true, createdAt: true }
      }),
      prisma.npsInvite.count({ where: { campgroundId } })
    ]);
    const total = responses.length;
    const promoters = responses.filter((r) => r.score >= 9).length;
    const detractors = responses.filter((r) => r.score <= 6).length;
    const passives = total - promoters - detractors;
    const nps = total > 0 ? Math.round((promoters - detractors) / total * 100) : null;
    return {
      totalResponses: total,
      promoters,
      passives,
      detractors,
      nps,
      responseRate: invites > 0 ? Math.round(total / invites * 100) : null
    };
  }
};
__decorateClass([
  (0, import_schedule8.Cron)("0 * * * *")
], NpsService.prototype, "sendPostCheckoutInvites", 1);
NpsService = __decorateClass([
  (0, import_common164.Injectable)()
], NpsService);

// src/support/support.module.ts
var import_common167 = require("@nestjs/common");

// src/support/support.controller.ts
var import_common165 = require("@nestjs/common");
var PLATFORM_SUPPORT_ROLES = ["support_agent", "support_lead", "regional_support", "platform_admin"];
var SupportController = class {
  constructor(support) {
    this.support = support;
  }
  canAct(user) {
    const membershipRole = user?.role;
    const platformRole = user?.platformRole;
    const platformOk = platformRole && PLATFORM_SUPPORT_ROLES.includes(platformRole);
    const membershipOk = membershipRole && ["owner", "manager", "support"].includes(membershipRole);
    return platformOk || membershipOk;
  }
  regionAllowed(user, targetRegion) {
    if (!targetRegion) return true;
    if (user?.platformRegion) return user.platformRegion === targetRegion;
    if (user?.region) return user.region === targetRegion;
    return true;
  }
  async create(dto, req) {
    if (!this.canAct(req?.user)) {
      throw new import_common165.ForbiddenException();
    }
    const authorId = req?.user?.id;
    return this.support.create(dto, authorId);
  }
  async list(req) {
    if (!this.canAct(req?.user)) {
      throw new import_common165.ForbiddenException();
    }
    const requestedRegion = req?.query?.region ?? null;
    if (!this.regionAllowed(req?.user, requestedRegion)) {
      throw new import_common165.ForbiddenException("Forbidden by region scope");
    }
    const region = requestedRegion ?? req?.user?.platformRegion ?? req?.user?.region ?? null;
    const campgroundId = req?.query?.campgroundId ?? null;
    return this.support.findAll({ region, campgroundId });
  }
  async update(id, dto, req) {
    if (!this.canAct(req?.user)) {
      throw new import_common165.ForbiddenException();
    }
    const actorCampgrounds = req?.user?.memberships?.map((m) => m.campgroundId) ?? [];
    return this.support.update(
      id,
      dto,
      req?.user?.id,
      req?.user?.platformRegion ?? req?.user?.region ?? null,
      actorCampgrounds,
      this.canAct(req?.user) && PLATFORM_SUPPORT_ROLES.includes(req?.user?.platformRole)
    );
  }
  async staffDirectory(req) {
    const requestedRegion = req?.query?.region ?? null;
    const campgroundId = req?.query?.campgroundId ?? null;
    const userRegion = req?.user?.platformRegion ?? req?.user?.region ?? null;
    if (requestedRegion && userRegion && requestedRegion !== userRegion) {
      throw new import_common165.ForbiddenException("Forbidden by region scope");
    }
    return this.support.staffDirectory({ region: requestedRegion ?? null, campgroundId });
  }
  async updateStaffScope(id, dto, req) {
    if (!this.canAct(req?.user)) {
      throw new import_common165.ForbiddenException();
    }
    const userRegion = req?.user?.platformRegion ?? req?.user?.region ?? null;
    if (dto.region && userRegion && dto.region !== userRegion) {
      throw new import_common165.ForbiddenException("Forbidden by region scope");
    }
    return this.support.updateStaffScope(id, dto);
  }
};
__decorateClass([
  (0, import_common165.Post)(),
  (0, import_common165.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "support", action: "write" }),
  __decorateParam(0, (0, import_common165.Body)()),
  __decorateParam(1, (0, import_common165.Req)())
], SupportController.prototype, "create", 1);
__decorateClass([
  (0, import_common165.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "support", action: "read" }),
  (0, import_common165.Get)(),
  __decorateParam(0, (0, import_common165.Req)())
], SupportController.prototype, "list", 1);
__decorateClass([
  (0, import_common165.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "support", action: "write" }),
  (0, import_common165.Patch)(":id"),
  __decorateParam(0, (0, import_common165.Param)("id")),
  __decorateParam(1, (0, import_common165.Body)()),
  __decorateParam(2, (0, import_common165.Req)())
], SupportController.prototype, "update", 1);
__decorateClass([
  (0, import_common165.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "support", action: "read" }),
  (0, import_common165.Get)("/staff/directory"),
  __decorateParam(0, (0, import_common165.Req)())
], SupportController.prototype, "staffDirectory", 1);
__decorateClass([
  (0, import_common165.UseGuards)(JwtAuthGuard, ScopeGuard),
  RequireScope({ resource: "support", action: "assign" }),
  (0, import_common165.Patch)("/staff/:id/scope"),
  __decorateParam(0, (0, import_common165.Param)("id")),
  __decorateParam(1, (0, import_common165.Body)()),
  __decorateParam(2, (0, import_common165.Req)())
], SupportController.prototype, "updateStaffScope", 1);
SupportController = __decorateClass([
  (0, import_common165.Controller)("support/reports")
], SupportController);

// src/support/support.service.ts
var import_common166 = require("@nestjs/common");
var SupportService = class {
  constructor(prisma, email) {
    this.prisma = prisma;
    this.email = email;
    this.logger = new import_common166.Logger(SupportService.name);
  }
  create(dto, authorId) {
    const {
      description,
      steps,
      contactEmail,
      path,
      userAgent,
      language,
      timezone,
      viewportWidth,
      viewportHeight,
      roleFilter,
      pinnedIds,
      recentIds,
      rawContext,
      campgroundId,
      region,
      ownershipRole
    } = dto;
    return this.prisma.supportReport.create({
      data: {
        description,
        steps,
        contactEmail,
        path,
        userAgent,
        language,
        timezone,
        viewportWidth: viewportWidth ?? null,
        viewportHeight: viewportHeight ?? null,
        roleFilter,
        pinnedIds: pinnedIds ?? [],
        recentIds: recentIds ?? [],
        rawContext: { ...rawContext, region, ownershipRole },
        campgroundId,
        authorId: authorId ?? null
      },
      include: {
        campground: { select: { id: true, name: true } },
        assignee: { select: { id: true, email: true, firstName: true, lastName: true } },
        author: { select: { id: true, email: true, firstName: true, lastName: true } }
      }
    }).then((report) => {
      void this.notifyNew(report);
      return report;
    });
  }
  findAll(args) {
    const { region, campgroundId } = args;
    return this.prisma.supportReport.findMany({
      where: {
        AND: [
          region ? { rawContext: { path: ["region"], equals: region } } : void 0,
          campgroundId ? { campgroundId } : void 0
        ].filter(Boolean)
      },
      orderBy: { createdAt: "desc" },
      include: {
        author: { select: { id: true, email: true, firstName: true, lastName: true } },
        assignee: { select: { id: true, email: true, firstName: true, lastName: true } },
        campground: { select: { id: true, name: true } }
      }
    });
  }
  async update(id, dto, actorId, actorRegion, actorCampgrounds, platformScoped = false) {
    const { status, assigneeId } = dto;
    const before = await this.prisma.supportReport.findUnique({
      where: { id },
      select: { assigneeId: true, rawContext: true, campgroundId: true }
    });
    const beforeRegion = before?.rawContext?.region;
    if (beforeRegion && actorRegion && beforeRegion !== actorRegion) {
      throw new import_common166.ForbiddenException("Forbidden by region scope");
    }
    if (before?.campgroundId && actorCampgrounds && !actorCampgrounds.includes(before.campgroundId) && !platformScoped) {
      throw new import_common166.ForbiddenException("Forbidden by campground scope");
    }
    if (assigneeId) {
      const assignee = await this.prisma.user.findUnique({
        where: { id: assigneeId },
        select: {
          id: true,
          region: true,
          memberships: { select: { campgroundId: true } },
          ownershipRoles: true
        }
      });
      if (!assignee) {
        throw new import_common166.ForbiddenException("Assignee not found");
      }
      const matchesRegion = beforeRegion ? assignee.region === beforeRegion : true;
      const matchesCamp = before?.campgroundId ? assignee.memberships.some((m) => m.campgroundId === before?.campgroundId) : true;
      if (!matchesRegion && !matchesCamp) {
        throw new import_common166.ForbiddenException("Assignee not permitted for region/campground");
      }
    }
    const report = await this.prisma.supportReport.update({
      where: { id },
      data: {
        status: status ?? void 0,
        assigneeId: assigneeId ?? void 0,
        updatedAt: /* @__PURE__ */ new Date()
        // audit can be added later
      },
      include: {
        campground: { select: { id: true, name: true } },
        assignee: { select: { id: true, email: true, firstName: true, lastName: true } },
        author: { select: { id: true, email: true, firstName: true, lastName: true } }
      }
    });
    if (assigneeId && assigneeId !== before?.assigneeId) {
      void this.notifyAssignment(report);
    }
    return report;
  }
  async staffDirectory(args) {
    const { region, campgroundId } = args;
    const whereOr = [];
    if (region) {
      whereOr.push({ region });
    }
    if (campgroundId) {
      whereOr.push({ memberships: { some: { campgroundId } } });
    }
    const users = await this.prisma.user.findMany({
      where: {
        isActive: true,
        platformActive: { not: false },
        ...whereOr.length > 0 ? { OR: whereOr } : {}
      },
      take: 200,
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        region: true,
        platformRole: true,
        platformRegion: true,
        platformActive: true,
        ownershipRoles: true,
        memberships: { select: { campgroundId: true, role: true } }
      }
    });
    return users.map((u) => ({
      ...u,
      platformRole: u.platformRole ?? null,
      platformRegion: u.platformRegion ?? null,
      platformActive: u.platformActive ?? true,
      notifyChannels: ["email"]
    }));
  }
  async updateStaffScope(id, dto) {
    const { region, ownershipRoles } = dto;
    return this.prisma.user.update({
      where: { id },
      data: {
        region: region ?? void 0,
        platformRegion: dto.platformRegion ?? void 0,
        platformRole: dto.platformRole ?? void 0,
        platformActive: typeof dto.platformActive === "string" ? dto.platformActive === "true" : void 0,
        ownershipRoles: ownershipRoles ?? void 0,
        updatedAt: /* @__PURE__ */ new Date()
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        region: true,
        platformRole: true,
        platformRegion: true,
        platformActive: true,
        ownershipRoles: true,
        memberships: { select: { campgroundId: true, role: true } }
      }
    });
  }
  formatReportSummary(report) {
    const parts = [
      `New support report (${report.status})`,
      report.campground?.name ? `Campground: ${report.campground.name}` : null,
      report.path ? `Path: ${report.path}` : null,
      `Desc: ${report.description}`,
      report.steps ? `Steps: ${report.steps}` : null,
      report.contactEmail ? `Contact: ${report.contactEmail}` : null,
      report.id ? `Id: ${report.id}` : null
    ].filter(Boolean).join("\n");
    return parts;
  }
  async notifyNew(report) {
    const slackWebhook = process.env.SUPPORT_SLACK_WEBHOOK;
    const emailList = (process.env.SUPPORT_ALERT_EMAILS || "").split(",").map((e) => e.trim()).filter(Boolean);
    if (slackWebhook) {
      try {
        const text = this.formatReportSummary(report);
        await fetch(slackWebhook, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });
      } catch (err) {
        this.logger.warn(`Failed to send support Slack notification: ${String(err)}`);
      }
    }
    if (emailList.length > 0) {
      const subject = `New support report: ${report.status || "open"} ${report.path || ""}`.trim();
      const html = `
        <div style="font-family: Arial, sans-serif; color: #0f172a; max-width: 640px;">
          <h2 style="margin: 0 0 12px 0;">New support report</h2>
          <p style="margin: 4px 0; color: #334155;"><strong>Status:</strong> ${report.status}</p>
          ${report.campground?.name ? `<p style="margin: 4px 0; color: #334155;"><strong>Campground:</strong> ${report.campground.name}</p>` : ""}
          ${report.path ? `<p style="margin: 4px 0; color: #334155;"><strong>Path:</strong> ${report.path}</p>` : ""}
          ${report.contactEmail ? `<p style="margin: 4px 0; color: #334155;"><strong>Contact:</strong> ${report.contactEmail}</p>` : ""}
          <p style="margin: 12px 0 4px 0; color: #0f172a;"><strong>Description</strong></p>
          <p style="margin: 0 0 12px 0; color: #334155; white-space: pre-wrap;">${report.description}</p>
          ${report.steps ? `
            <p style="margin: 12px 0 4px 0; color: #0f172a;"><strong>Steps</strong></p>
            <p style="margin: 0 0 12px 0; color: #334155; white-space: pre-wrap;">${report.steps}</p>
          ` : ""}
          <p style="margin: 12px 0 4px 0; color: #0f172a;"><strong>Context</strong></p>
          <ul style="margin: 0; padding-left: 18px; color: #334155; line-height: 1.5;">
            ${report.timezone ? `<li>Timezone: ${report.timezone}</li>` : ""}
            ${report.language ? `<li>Language: ${report.language}</li>` : ""}
            ${report.userAgent ? `<li>Browser: ${report.userAgent}</li>` : ""}
            ${report.viewportWidth && report.viewportHeight ? `<li>Viewport: ${report.viewportWidth} x ${report.viewportHeight}</li>` : ""}
            ${report.roleFilter ? `<li>Role filter: ${report.roleFilter}</li>` : ""}
            ${report.pinnedIds?.length ? `<li>Pinned: ${report.pinnedIds.join(", ")}</li>` : ""}
            ${report.recentIds?.length ? `<li>Recent: ${report.recentIds.join(", ")}</li>` : ""}
          </ul>
          <p style="margin: 12px 0 0 0; color: #64748b; font-size: 12px;">Report ID: ${report.id}</p>
        </div>
      `;
      await Promise.allSettled(
        emailList.map(
          (to) => this.email.sendEmail({
            to,
            subject,
            html
          })
        )
      );
    }
  }
  async notifyAssignment(report) {
    const slackWebhook = process.env.SUPPORT_SLACK_WEBHOOK;
    if (slackWebhook && report.assignee?.email) {
      try {
        const text = [
          `Support report assigned`,
          `To: ${report.assignee.email}`,
          report.campground?.name ? `Campground: ${report.campground.name}` : null,
          report.path ? `Path: ${report.path}` : null,
          `Desc: ${report.description}`,
          `Id: ${report.id}`
        ].filter(Boolean).join("\n");
        await fetch(slackWebhook, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });
      } catch (err) {
        this.logger.warn(`Failed to send assignment Slack notification: ${String(err)}`);
      }
    }
    const assigneeEmail = report.assignee?.email;
    if (assigneeEmail) {
      const subject = `Assigned: Support report (${report.status || "open"}) ${report.path || ""}`.trim();
      const html = `
        <div style="font-family: Arial, sans-serif; color: #0f172a; max-width: 640px;">
          <h2 style="margin: 0 0 12px 0;">You were assigned a support report</h2>
          ${report.campground?.name ? `<p style="margin: 4px 0; color: #334155;"><strong>Campground:</strong> ${report.campground.name}</p>` : ""}
          ${report.path ? `<p style="margin: 4px 0; color: #334155;"><strong>Path:</strong> ${report.path}</p>` : ""}
          <p style="margin: 4px 0; color: #334155;"><strong>Status:</strong> ${report.status}</p>
          <p style="margin: 12px 0 4px 0; color: #0f172a;"><strong>Description</strong></p>
          <p style="margin: 0 0 12px 0; color: #334155; white-space: pre-wrap;">${report.description}</p>
          ${report.steps ? `
            <p style="margin: 12px 0 4px 0; color: #0f172a;"><strong>Steps</strong></p>
            <p style="margin: 0 0 12px 0; color: #334155; white-space: pre-wrap;">${report.steps}</p>
          ` : ""}
          <p style="margin: 12px 0 0 0; color: #64748b; font-size: 12px;">Report ID: ${report.id}</p>
        </div>
      `;
      try {
        await this.email.sendEmail({
          to: assigneeEmail,
          subject,
          html
        });
      } catch (err) {
        this.logger.warn(`Failed to send assignment email: ${String(err)}`);
      }
    }
  }
};
SupportService = __decorateClass([
  (0, import_common166.Injectable)()
], SupportService);

// src/support/support.module.ts
var SupportModule = class {
};
SupportModule = __decorateClass([
  (0, import_common167.Module)({
    imports: [PermissionsModule],
    controllers: [SupportController],
    providers: [SupportService, PrismaService],
    exports: [SupportService]
  })
], SupportModule);

// src/nps/nps.module.ts
var NpsModule = class {
};
NpsModule = __decorateClass([
  (0, import_common168.Module)({
    imports: [EmailModule, SupportModule],
    controllers: [NpsController],
    providers: [NpsService, PrismaService],
    exports: [NpsService]
  })
], NpsModule);

// src/communications/communications.module.ts
var CommunicationsModule = class {
};
CommunicationsModule = __decorateClass([
  (0, import_common169.Module)({
    imports: [SmsModule, NpsModule, PermissionsModule, ObservabilityModule],
    controllers: [CommunicationsController],
    providers: [PrismaService, EmailService],
    exports: []
  })
], CommunicationsModule);

// src/campaigns/campaigns.module.ts
var import_common173 = require("@nestjs/common");

// src/campaigns/campaigns.service.ts
var import_common170 = require("@nestjs/common");
var import_client28 = require("@prisma/client");
var ChannelTypeValues = { email: "email", sms: "sms", both: "both" };
var CampaignStatusValues = { draft: "draft", scheduled: "scheduled", sending: "sending", sent: "sent", cancelled: "cancelled" };
var CampaignsService = class {
  constructor(prisma, emailService, smsService) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.smsService = smsService;
  }
  appendEmailFooter(html) {
    const footer = `
      <hr style="border:none;border-top:1px solid #e2e8f0;margin:24px 0;" />
      <p style="font-size:12px;color:#64748b;margin:0;">
        You received this because you opted in to updates from this campground.
        <br/>To unsubscribe, reply to this email or update your preferences.
      </p>
    `;
    return `${html}${footer}`;
  }
  appendSmsFooter(body) {
    const stop = " Reply STOP to opt out.";
    return body.includes("STOP") ? body : `${body}${stop}`;
  }
  create(dto) {
    const scheduledAt = dto.scheduledAt ? new Date(dto.scheduledAt) : null;
    return this.prisma.campaign.create({
      data: {
        campgroundId: dto.campgroundId,
        name: dto.name,
        subject: dto.subject,
        fromEmail: dto.fromEmail,
        fromName: dto.fromName || null,
        html: dto.html,
        textBody: dto.textBody || null,
        channel: dto.channel || ChannelTypeValues.email,
        status: CampaignStatusValues.draft,
        variables: dto.variables || {},
        scheduledAt
      }
    });
  }
  createTemplate(dto) {
    const templateClient = this.prisma.campaignTemplate;
    if (!templateClient?.create) return null;
    return templateClient.create({
      data: {
        campgroundId: dto.campgroundId,
        name: dto.name,
        channel: dto.channel || ChannelTypeValues.email,
        category: dto.category || "general",
        subject: dto.subject || null,
        html: dto.html || null,
        textBody: dto.textBody || null
      }
    });
  }
  listTemplates(campgroundId) {
    const templateClient = this.prisma.campaignTemplate;
    if (!templateClient?.findMany) return [];
    return templateClient.findMany({
      where: { campgroundId },
      orderBy: { updatedAt: "desc" }
    });
  }
  async audiencePreview(filters) {
    const whereReservation = {
      ...filters.campgroundId ? { campgroundId: filters.campgroundId } : {}
    };
    if (filters.stayedFrom) {
      whereReservation.departureDate = { ...whereReservation.departureDate || {}, gte: new Date(filters.stayedFrom) };
    }
    if (filters.stayedTo) {
      whereReservation.arrivalDate = { ...whereReservation.arrivalDate || {}, lte: new Date(filters.stayedTo) };
    }
    if (filters.stayFrom || filters.stayTo) {
      whereReservation.arrivalDate = {
        ...whereReservation.arrivalDate || {},
        ...filters.stayFrom ? { gte: new Date(filters.stayFrom) } : {},
        ...filters.stayTo ? { lte: new Date(filters.stayTo) } : {}
      };
    }
    const guests = await this.prisma.guest.findMany({
      where: {
        marketingOptIn: true,
        email: { not: "" },
        reservations: {
          some: {
            ...whereReservation,
            ...filters.siteType ? { site: { siteType: filters.siteType } } : {},
            ...filters.siteClassId ? { siteClassId: filters.siteClassId } : {}
          }
        },
        ...filters.state ? { state: filters.state } : {},
        ...filters.vip ? { vip: true } : {},
        ...filters.loyaltyTier ? { loyaltyProfile: { tier: filters.loyaltyTier } } : {}
      },
      select: {
        id: true,
        email: true,
        phone: true,
        primaryFirstName: true,
        primaryLastName: true,
        reservations: {
          select: { arrivalDate: true, departureDate: true, promoCode: true },
          orderBy: { arrivalDate: "desc" },
          take: 1
        }
      },
      take: 200
    });
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const filtered = guests.filter((g) => {
      const lastStay = g.reservations[0]?.departureDate;
      if (filters.lastStayBefore && lastStay && new Date(lastStay) >= new Date(filters.lastStayBefore)) return false;
      if (filters.notStayedThisYear && lastStay && new Date(lastStay).getFullYear() === currentYear) return false;
      if (filters.promoUsed && !g.reservations[0]?.promoCode) return false;
      return true;
    });
    return {
      count: filtered.length,
      sample: filtered.slice(0, 20).map((g) => ({
        id: g.id,
        name: `${g.primaryFirstName || ""} ${g.primaryLastName || ""}`.trim(),
        email: g.email,
        phone: g.phone,
        lastStay: g.reservations[0]?.departureDate || null
      }))
    };
  }
  async suggestions(campgroundId) {
    const now = /* @__PURE__ */ new Date();
    const end14 = /* @__PURE__ */ new Date();
    end14.setDate(now.getDate() + 14);
    const end30 = /* @__PURE__ */ new Date();
    end30.setDate(now.getDate() + 30);
    const siteCounts = await this.prisma.site.groupBy({
      by: ["siteType"],
      where: { campgroundId, isActive: true },
      _count: { _all: true }
    });
    const reservations = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        status: { not: "cancelled" },
        arrivalDate: { lt: end14 },
        departureDate: { gt: now }
      },
      select: { site: { select: { siteType: true } } }
    });
    const activeByType = {};
    reservations.forEach((r) => {
      const t = (r.site?.siteType || "rv").toLowerCase();
      activeByType[t] = (activeByType[t] || 0) + 1;
    });
    const suggestions14 = siteCounts.map((sc) => {
      const type = sc.siteType.toLowerCase();
      const total = sc._count._all;
      const active = activeByType[type] || 0;
      const occ = total > 0 ? active / total : 1;
      return { type, total, active, occ };
    }).filter((s) => s.occ < 0.6 && s.total > 0).map((s) => ({
      reason: `${s.type.toUpperCase()} occupancy ${Math.round(s.occ * 100)}% in next 14 days`,
      filters: {
        campgroundId,
        siteType: s.type,
        notStayedThisYear: true
      }
    }));
    const reservations30 = await this.prisma.reservation.findMany({
      where: {
        campgroundId,
        status: { not: "cancelled" },
        arrivalDate: { lt: end30 },
        departureDate: { gt: now }
      },
      select: { site: { select: { siteType: true } } }
    });
    const activeByType30 = {};
    reservations30.forEach((r) => {
      const t = (r.site?.siteType || "rv").toLowerCase();
      activeByType30[t] = (activeByType30[t] || 0) + 1;
    });
    const suggestions30 = siteCounts.map((sc) => {
      const type = sc.siteType.toLowerCase();
      const total = sc._count._all;
      const active = activeByType30[type] || 0;
      const occ = total > 0 ? active / total : 1;
      return { type, total, active, occ };
    }).filter((s) => s.occ < 0.7 && s.total > 0).map((s) => ({
      reason: `${s.type.toUpperCase()} soft occupancy in next 30 days (${Math.round(s.occ * 100)}%)`,
      filters: {
        campgroundId,
        siteType: s.type
      }
    }));
    const oneYearAgo = /* @__PURE__ */ new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const lapsed = [
      {
        reason: "Lapsed guests: no stay in 12 months",
        filters: {
          campgroundId,
          lastStayBefore: oneYearAgo.toISOString().slice(0, 10)
        }
      }
    ];
    const lastYear = /* @__PURE__ */ new Date();
    lastYear.setFullYear(lastYear.getFullYear() - 1);
    const month = lastYear.getMonth() + 1;
    const repeatMonth = [
      {
        reason: `Guests who stayed in month ${month} last year but not this year`,
        filters: {
          campgroundId,
          stayedFrom: new Date(lastYear.getFullYear(), month - 1, 1).toISOString().slice(0, 10),
          stayedTo: new Date(lastYear.getFullYear(), month, 0).toISOString().slice(0, 10),
          notStayedThisYear: true
        }
      }
    ];
    const promoUsers = [
      {
        reason: "Guests who used a promo last year but not this year",
        filters: {
          campgroundId,
          promoUsed: true,
          notStayedThisYear: true
        }
      }
    ];
    const vip = [
      {
        reason: "VIP/loyalty guests to win back",
        filters: {
          campgroundId,
          vip: true,
          notStayedThisYear: true
        }
      }
    ];
    return [...suggestions14, ...suggestions30, ...lapsed, ...repeatMonth, ...promoUsers, ...vip];
  }
  list(campgroundId) {
    const campaignClient = this.prisma.campaign;
    if (!campaignClient?.findMany) return [];
    return campaignClient.findMany({
      where: campgroundId ? { campgroundId } : {},
      orderBy: { updatedAt: "desc" }
    });
  }
  async update(id, dto) {
    const campaign = await this.prisma.campaign.findUnique({ where: { id } });
    if (!campaign) throw new import_common170.NotFoundException("Campaign not found");
    const scheduledAt = dto.scheduledAt === void 0 ? void 0 : dto.scheduledAt ? new Date(dto.scheduledAt) : null;
    return this.prisma.campaign.update({
      where: { id },
      data: {
        name: dto.name ?? campaign.name,
        subject: dto.subject ?? campaign.subject,
        fromEmail: dto.fromEmail ?? campaign.fromEmail,
        fromName: dto.fromName ?? campaign.fromName,
        html: dto.html ?? campaign.html,
        status: dto.status ?? campaign.status,
        scheduledAt
      }
    });
  }
  async sendNow(id, opts) {
    const campaign = await this.prisma.campaign.findUnique({
      where: { id },
      include: { campground: true }
    });
    if (!campaign) throw new import_common170.NotFoundException("Campaign not found");
    if (campaign.status !== CampaignStatusValues.draft && campaign.status !== CampaignStatusValues.scheduled) {
      throw new import_common170.BadRequestException("Campaign cannot be sent from current status");
    }
    if (opts?.scheduledAt) {
      const sched = new Date(opts.scheduledAt);
      if (sched > /* @__PURE__ */ new Date()) {
        await this.prisma.campaign.update({
          where: { id },
          data: { status: CampaignStatusValues.scheduled, scheduledAt: sched }
        });
        return { scheduledAt: sched };
      }
    }
    await this.prisma.campaign.update({ where: { id }, data: { status: CampaignStatusValues.sending, scheduledAt: null } });
    const guests = await this.prisma.guest.findMany({
      where: {
        marketingOptIn: true,
        OR: [
          { email: { not: "" } },
          { phone: { not: "" } }
        ],
        reservations: {
          some: { campgroundId: campaign.campgroundId }
        }
      },
      select: { id: true, email: true, phone: true, primaryFirstName: true, primaryLastName: true }
    });
    const batch = opts?.batchPerMinute ? Number(opts.batchPerMinute) : 0;
    const delayMs = batch > 0 ? Math.max(0, Math.floor(6e4 / batch)) : 0;
    let sent = 0;
    for (const guest of guests) {
      const targetEmail = guest.email;
      const targetPhone = guest.phone;
      if ((campaign.channel === ChannelTypeValues.email || campaign.channel === ChannelTypeValues.both) && targetEmail) {
        const send = await this.prisma.campaignSend.create({
          data: {
            campaignId: campaign.id,
            campgroundId: campaign.campgroundId,
            guestId: guest.id,
            email: targetEmail,
            phone: "",
            channel: ChannelTypeValues.email,
            status: import_client28.CampaignSendStatus.queued
          }
        });
        try {
          const html = this.appendEmailFooter(campaign.html);
          const result = await this.emailService.sendEmail({
            to: targetEmail,
            subject: campaign.subject,
            html
          });
          await this.prisma.campaignSend.update({
            where: { id: send.id },
            data: {
              status: import_client28.CampaignSendStatus.sent,
              providerMessageId: result.providerMessageId || null,
              sentAt: /* @__PURE__ */ new Date()
            }
          });
          sent += 1;
        } catch (err) {
          await this.prisma.campaignSend.update({
            where: { id: send.id },
            data: {
              status: import_client28.CampaignSendStatus.failed,
              error: err instanceof Error ? err.message : "Failed to send"
            }
          });
        }
      }
      if ((campaign.channel === ChannelTypeValues.sms || campaign.channel === ChannelTypeValues.both) && targetPhone) {
        const send = await this.prisma.campaignSend.create({
          data: {
            campaignId: campaign.id,
            campgroundId: campaign.campgroundId,
            guestId: guest.id,
            phone: targetPhone,
            email: "",
            channel: ChannelTypeValues.sms,
            status: import_client28.CampaignSendStatus.queued
          }
        });
        try {
          const body = this.appendSmsFooter(campaign.textBody || "");
          const result = await this.smsService.sendSms({
            to: targetPhone,
            body
          });
          await this.prisma.campaignSend.update({
            where: { id: send.id },
            data: {
              status: import_client28.CampaignSendStatus.sent,
              providerMessageId: result.providerMessageId || null,
              sentAt: /* @__PURE__ */ new Date()
            }
          });
          sent += 1;
        } catch (err) {
          await this.prisma.campaignSend.update({
            where: { id: send.id },
            data: {
              status: import_client28.CampaignSendStatus.failed,
              error: err instanceof Error ? err.message : "Failed to send SMS"
            }
          });
        }
      }
      if (delayMs > 0) {
        await new Promise((res) => setTimeout(res, delayMs));
      }
    }
    await this.prisma.campaign.update({ where: { id }, data: { status: CampaignStatusValues.sent } });
    return { sent };
  }
  async testSend(id, opts) {
    const campaign = await this.prisma.campaign.findUnique({ where: { id } });
    if (!campaign) throw new import_common170.NotFoundException("Campaign not found");
    const targets = [];
    if ((campaign.channel === ChannelTypeValues.email || campaign.channel === ChannelTypeValues.both) && opts.email) {
      targets.push({ channel: ChannelTypeValues.email, email: opts.email });
    }
    if ((campaign.channel === ChannelTypeValues.sms || campaign.channel === ChannelTypeValues.both) && opts.phone) {
      targets.push({ channel: ChannelTypeValues.sms, phone: opts.phone });
    }
    let sent = 0;
    for (const t of targets) {
      if (t.channel === ChannelTypeValues.email && t.email) {
        const html = this.appendEmailFooter(campaign.html);
        await this.emailService.sendEmail({
          to: t.email,
          subject: `[TEST] ${campaign.subject}`,
          html
        });
        sent += 1;
      }
      if (t.channel === ChannelTypeValues.sms && t.phone) {
        const body = this.appendSmsFooter(campaign.textBody || "");
        await this.smsService.sendSms({ to: t.phone, body: `[TEST] ${body}` });
        sent += 1;
      }
    }
    return { sent };
  }
};
CampaignsService = __decorateClass([
  (0, import_common170.Injectable)()
], CampaignsService);

// src/campaigns/campaigns.controller.ts
var import_common171 = require("@nestjs/common");
var CampaignsController = class {
  constructor(campaigns) {
    this.campaigns = campaigns;
  }
  list(campgroundId) {
    return this.campaigns.list(campgroundId);
  }
  create(body) {
    return this.campaigns.create(body);
  }
  update(id, body) {
    return this.campaigns.update(id, body);
  }
  send(id, body) {
    return this.campaigns.sendNow(id, body);
  }
  testSend(id, body) {
    return this.campaigns.testSend(id, body);
  }
  createTemplate(body) {
    return this.campaigns.createTemplate(body);
  }
  listTemplates(campgroundId) {
    return this.campaigns.listTemplates(campgroundId);
  }
  audiencePreview(body) {
    return this.campaigns.audiencePreview(body);
  }
  suggestions(campgroundId) {
    return this.campaigns.suggestions(campgroundId);
  }
};
__decorateClass([
  (0, import_common171.Get)("campaigns"),
  __decorateParam(0, (0, import_common171.Query)("campgroundId"))
], CampaignsController.prototype, "list", 1);
__decorateClass([
  (0, import_common171.Post)("campaigns"),
  __decorateParam(0, (0, import_common171.Body)())
], CampaignsController.prototype, "create", 1);
__decorateClass([
  (0, import_common171.Patch)("campaigns/:id"),
  __decorateParam(0, (0, import_common171.Param)("id")),
  __decorateParam(1, (0, import_common171.Body)())
], CampaignsController.prototype, "update", 1);
__decorateClass([
  (0, import_common171.Post)("campaigns/:id/send"),
  __decorateParam(0, (0, import_common171.Param)("id")),
  __decorateParam(1, (0, import_common171.Body)())
], CampaignsController.prototype, "send", 1);
__decorateClass([
  (0, import_common171.Post)("campaigns/:id/test"),
  __decorateParam(0, (0, import_common171.Param)("id")),
  __decorateParam(1, (0, import_common171.Body)())
], CampaignsController.prototype, "testSend", 1);
__decorateClass([
  (0, import_common171.Post)("campaign-templates"),
  __decorateParam(0, (0, import_common171.Body)())
], CampaignsController.prototype, "createTemplate", 1);
__decorateClass([
  (0, import_common171.Get)("campaign-templates"),
  __decorateParam(0, (0, import_common171.Query)("campgroundId"))
], CampaignsController.prototype, "listTemplates", 1);
__decorateClass([
  (0, import_common171.Post)("campaigns/audience/preview"),
  __decorateParam(0, (0, import_common171.Body)())
], CampaignsController.prototype, "audiencePreview", 1);
__decorateClass([
  (0, import_common171.Get)("campaigns/suggestions"),
  __decorateParam(0, (0, import_common171.Query)("campgroundId"))
], CampaignsController.prototype, "suggestions", 1);
CampaignsController = __decorateClass([
  (0, import_common171.UseGuards)(JwtAuthGuard),
  (0, import_common171.Controller)()
], CampaignsController);

// src/campaigns/campaigns.scheduler.ts
var import_common172 = require("@nestjs/common");
var import_schedule9 = require("@nestjs/schedule");
var import_client29 = require("@prisma/client");
var CampaignsScheduler = class {
  constructor(prisma, campaigns, queue) {
    this.prisma = prisma;
    this.campaigns = campaigns;
    this.queue = queue;
    this.logger = new import_common172.Logger(CampaignsScheduler.name);
  }
  async dispatchScheduled() {
    const now = /* @__PURE__ */ new Date();
    const due = await this.prisma.campaign.findMany({
      where: {
        status: import_client29.CampaignStatus.scheduled,
        scheduledAt: { lte: now }
      },
      select: { id: true }
    });
    await Promise.all(
      due.map(
        (c) => this.queue.enqueue(
          "campaign-dispatch",
          () => this.campaigns.sendNow(c.id),
          { jobName: `campaign-${c.id}`, timeoutMs: 2e4, concurrency: 2 }
        ).catch((err) => {
          this.logger.warn(`Failed to dispatch scheduled campaign ${c.id}: ${err instanceof Error ? err.message : err}`);
        })
      )
    );
  }
};
__decorateClass([
  (0, import_schedule9.Cron)("*/1 * * * *")
], CampaignsScheduler.prototype, "dispatchScheduled", 1);
CampaignsScheduler = __decorateClass([
  (0, import_common172.Injectable)()
], CampaignsScheduler);

// src/campaigns/campaigns.module.ts
var import_schedule10 = require("@nestjs/schedule");
var CampaignsModule = class {
};
CampaignsModule = __decorateClass([
  (0, import_common173.Module)({
    imports: [EmailModule, SmsModule, import_schedule10.ScheduleModule.forRoot()],
    controllers: [CampaignsController],
    providers: [CampaignsService, PrismaService, CampaignsScheduler]
  })
], CampaignsModule);

// src/site-map/site-map.module.ts
var import_common176 = require("@nestjs/common");

// src/site-map/site-map.service.ts
var import_common174 = require("@nestjs/common");
var import_client30 = require("@prisma/client");
var SiteMapService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async getMap(campgroundId, startDate, endDate) {
    const [layouts, config2] = await this.prisma.$transaction([
      this.prisma.siteMapLayout.findMany({
        where: { campgroundId },
        include: { site: true }
      }),
      this.prisma.campgroundMapConfig.findUnique({ where: { campgroundId } })
    ]);
    let conflictsBySite = {};
    if (startDate && endDate) {
      const { start, end } = this.parseDates(startDate, endDate);
      conflictsBySite = await this.buildConflictsMap(campgroundId, layouts.map((l) => l.siteId), start, end);
    }
    return {
      config: config2 ?? null,
      sites: layouts.map((layout) => ({
        siteId: layout.siteId,
        name: layout.site.name,
        siteNumber: layout.site.siteNumber,
        geometry: layout.geometry,
        centroid: layout.centroid,
        label: layout.label ?? layout.site.mapLabel ?? layout.site.name,
        rotation: layout.rotation,
        ada: layout.site.accessible,
        amenityTags: (layout.site.amenityTags?.length ? layout.site.amenityTags : layout.site.tags) ?? [],
        rigConstraints: {
          length: layout.site.rigMaxLength ?? null,
          width: layout.site.rigMaxWidth ?? null,
          height: layout.site.rigMaxHeight ?? null,
          pullThrough: layout.site.pullThrough ?? false
        },
        hookups: {
          power: layout.site.hookupsPower,
          powerAmps: layout.site.powerAmps,
          water: layout.site.hookupsWater,
          sewer: layout.site.hookupsSewer
        },
        status: layout.site.status ?? null,
        conflicts: conflictsBySite[layout.siteId] ?? []
      }))
    };
  }
  async upsertMap(campgroundId, dto) {
    const ops = [];
    const siteIds = dto.sites?.map((s) => s.siteId) ?? [];
    if (siteIds.length) {
      const count = await this.prisma.site.count({ where: { id: { in: siteIds }, campgroundId } });
      if (count !== siteIds.length) {
        throw new import_common174.BadRequestException("One or more sites do not belong to this campground");
      }
    }
    if (dto.config) {
      ops.push(
        this.prisma.campgroundMapConfig.upsert({
          where: { campgroundId },
          update: {
            bounds: dto.config.bounds ?? null,
            defaultCenter: dto.config.defaultCenter ?? null,
            defaultZoom: dto.config.defaultZoom ?? null,
            layers: dto.config.layers ?? null,
            legend: dto.config.legend ?? null
          },
          create: {
            campgroundId,
            bounds: dto.config.bounds ?? null,
            defaultCenter: dto.config.defaultCenter ?? null,
            defaultZoom: dto.config.defaultZoom ?? null,
            layers: dto.config.layers ?? null,
            legend: dto.config.legend ?? null
          }
        })
      );
    }
    if (dto.sites?.length) {
      for (const site of dto.sites) {
        ops.push(
          this.prisma.siteMapLayout.upsert({
            where: { siteId: site.siteId },
            update: {
              geometry: site.geometry,
              centroid: site.centroid ?? null,
              label: site.label ?? null,
              rotation: site.rotation ?? null,
              metadata: site.metadata ?? null,
              campgroundId
            },
            create: {
              siteId: site.siteId,
              campgroundId,
              geometry: site.geometry,
              centroid: site.centroid ?? null,
              label: site.label ?? null,
              rotation: site.rotation ?? null,
              metadata: site.metadata ?? null
            }
          })
        );
      }
    }
    if (!ops.length) return this.getMap(campgroundId);
    await this.prisma.$transaction(ops);
    return this.getMap(campgroundId);
  }
  async checkAssignment(campgroundId, dto) {
    const site = await this.prisma.site.findUnique({ where: { id: dto.siteId } });
    if (!site || site.campgroundId !== campgroundId) {
      throw new import_common174.NotFoundException("Site not found in this campground");
    }
    const { start, end } = this.parseDates(dto.startDate, dto.endDate);
    const reasons = this.evaluateSiteFit(site, dto);
    const conflictsMap = await this.buildConflictsMap(campgroundId, [site.id], start, end);
    const conflicts = conflictsMap[site.id] ?? [];
    if (conflicts.length) reasons.push("status_blocked");
    return {
      ok: reasons.length === 0,
      reasons: Array.from(new Set(reasons)),
      conflicts
    };
  }
  async previewAssignments(campgroundId, dto) {
    const { start, end } = this.parseDates(dto.startDate, dto.endDate);
    const sites = await this.prisma.site.findMany({
      where: {
        campgroundId,
        ...dto.siteIds?.length ? { id: { in: dto.siteIds } } : {},
        isActive: true
      }
    });
    if (!sites.length) {
      return { eligible: [], ineligible: [] };
    }
    const conflictsMap = await this.buildConflictsMap(campgroundId, sites.map((s) => s.id), start, end);
    const eligible = [];
    const ineligible = [];
    for (const site of sites) {
      const reasons = this.evaluateSiteFit(site, dto);
      const conflicts = conflictsMap[site.id] ?? [];
      if (conflicts.length) reasons.push("status_blocked");
      const payload = {
        siteId: site.id,
        reasons: Array.from(new Set(reasons)),
        conflicts
      };
      if (payload.reasons.length === 0) {
        eligible.push(payload);
      } else {
        ineligible.push(payload);
      }
    }
    return { eligible, ineligible };
  }
  evaluateSiteFit(site, dto) {
    const reasons = [];
    const rig = dto.rig ?? {};
    if (rig.length && site.rigMaxLength && rig.length > site.rigMaxLength) reasons.push("rig_too_long");
    if (rig.width && site.rigMaxWidth && rig.width > site.rigMaxWidth) reasons.push("rig_too_wide");
    if (rig.height && site.rigMaxHeight && rig.height > site.rigMaxHeight) reasons.push("rig_too_tall");
    if (dto.needsADA && !site.accessible) reasons.push("ada_required");
    if (dto.partySize && site.maxOccupancy && dto.partySize > site.maxOccupancy) reasons.push("party_too_large");
    const requiredAmenities = dto.requiredAmenities ?? [];
    if (requiredAmenities.length) {
      const available = ((site.amenityTags?.length ? site.amenityTags : site.tags) ?? []).map((a) => a.toLowerCase());
      const missing = requiredAmenities.filter((a) => !available.includes(a.toLowerCase()));
      if (missing.length) reasons.push("missing_amenities");
    }
    return reasons;
  }
  async buildConflictsMap(campgroundId, siteIds, start, end) {
    const map = {};
    const siteFilter = siteIds?.length ? { in: siteIds } : void 0;
    const [reservations, holds, maintenance, blackouts] = await Promise.all([
      this.prisma.reservation.findMany({
        where: {
          campgroundId,
          ...siteFilter ? { siteId: siteFilter } : {},
          status: { not: import_client30.ReservationStatus.cancelled },
          arrivalDate: { lt: end },
          departureDate: { gt: start }
        },
        select: { id: true, siteId: true, arrivalDate: true, departureDate: true, status: true }
      }),
      this.prisma.siteHold.findMany({
        where: {
          campgroundId,
          ...siteFilter ? { siteId: siteFilter } : {},
          status: "active",
          arrivalDate: { lt: end },
          departureDate: { gt: start },
          OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
        },
        select: { id: true, siteId: true, arrivalDate: true, departureDate: true, status: true }
      }),
      this.prisma.maintenanceTicket.findMany({
        where: {
          campgroundId,
          ...siteFilter ? { siteId: siteFilter } : {},
          status: { in: ["open", "in_progress"] },
          OR: [{ outOfOrder: true }, { isBlocking: true }, { outOfOrderUntil: { gt: start } }]
        },
        select: { id: true, siteId: true, outOfOrderUntil: true, status: true, outOfOrder: true, isBlocking: true }
      }),
      this.prisma.blackoutDate.findMany({
        where: {
          campgroundId,
          startDate: { lt: end },
          endDate: { gt: start },
          ...siteFilter ? { OR: [{ siteId: null }, { siteId: siteFilter }] } : {}
        },
        select: { id: true, siteId: true, startDate: true, endDate: true, reason: true }
      })
    ]);
    for (const r of reservations) {
      if (!r.siteId) continue;
      map[r.siteId] = map[r.siteId] || [];
      map[r.siteId].push({ type: "reservation", id: r.id, start: r.arrivalDate, end: r.departureDate, status: r.status });
    }
    for (const h of holds) {
      map[h.siteId] = map[h.siteId] || [];
      map[h.siteId].push({ type: "hold", id: h.id, start: h.arrivalDate, end: h.departureDate, status: h.status });
    }
    for (const m of maintenance) {
      if (!m.siteId) continue;
      map[m.siteId] = map[m.siteId] || [];
      map[m.siteId].push({
        type: "maintenance",
        id: m.id,
        start,
        end: m.outOfOrderUntil ?? end,
        status: m.status,
        reason: m.outOfOrder ? "out_of_order" : m.isBlocking ? "blocking" : null
      });
    }
    for (const b of blackouts) {
      const targets = b.siteId ? [b.siteId] : siteIds ?? [];
      for (const target of targets) {
        map[target] = map[target] || [];
        map[target].push({ type: "blackout", id: b.id, start: b.startDate, end: b.endDate, reason: b.reason ?? null });
      }
    }
    return map;
  }
  parseDates(startDate, endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    if (!Number.isFinite(start.getTime()) || !Number.isFinite(end.getTime())) {
      throw new import_common174.BadRequestException("Invalid date range");
    }
    if (end <= start) {
      throw new import_common174.BadRequestException("End date must be after start date");
    }
    return { start, end };
  }
};
SiteMapService = __decorateClass([
  (0, import_common174.Injectable)()
], SiteMapService);

// src/site-map/site-map.controller.ts
var import_common175 = require("@nestjs/common");
var SiteMapController = class {
  constructor(siteMap) {
    this.siteMap = siteMap;
  }
  getMap(campgroundId, startDate, endDate) {
    return this.siteMap.getMap(campgroundId, startDate, endDate);
  }
  upsertMap(campgroundId, body) {
    return this.siteMap.upsertMap(campgroundId, body);
  }
  check(campgroundId, body) {
    return this.siteMap.checkAssignment(campgroundId, body);
  }
  preview(campgroundId, body) {
    return this.siteMap.previewAssignments(campgroundId, body);
  }
};
__decorateClass([
  (0, import_common175.Get)("campgrounds/:campgroundId/map"),
  __decorateParam(0, (0, import_common175.Param)("campgroundId")),
  __decorateParam(1, (0, import_common175.Query)("startDate")),
  __decorateParam(2, (0, import_common175.Query)("endDate"))
], SiteMapController.prototype, "getMap", 1);
__decorateClass([
  (0, import_common175.Put)("campgrounds/:campgroundId/map"),
  __decorateParam(0, (0, import_common175.Param)("campgroundId")),
  __decorateParam(1, (0, import_common175.Body)())
], SiteMapController.prototype, "upsertMap", 1);
__decorateClass([
  (0, import_common175.Post)("campgrounds/:campgroundId/assignments/check"),
  __decorateParam(0, (0, import_common175.Param)("campgroundId")),
  __decorateParam(1, (0, import_common175.Body)())
], SiteMapController.prototype, "check", 1);
__decorateClass([
  (0, import_common175.Post)("campgrounds/:campgroundId/assignments/preview"),
  __decorateParam(0, (0, import_common175.Param)("campgroundId")),
  __decorateParam(1, (0, import_common175.Body)())
], SiteMapController.prototype, "preview", 1);
SiteMapController = __decorateClass([
  (0, import_common175.UseGuards)(JwtAuthGuard),
  (0, import_common175.Controller)()
], SiteMapController);

// src/site-map/site-map.module.ts
var SiteMapModule = class {
};
SiteMapModule = __decorateClass([
  (0, import_common176.Module)({
    controllers: [SiteMapController],
    providers: [SiteMapService, PrismaService],
    exports: [SiteMapService]
  })
], SiteMapModule);

// src/reviews/reviews.module.ts
var import_common179 = require("@nestjs/common");

// src/reviews/reviews.controller.ts
var import_common177 = require("@nestjs/common");
var import_client31 = require("@prisma/client");
var ReviewsController = class {
  constructor(reviewsService) {
    this.reviewsService = reviewsService;
  }
  createRequest(dto) {
    return this.reviewsService.createRequest(dto);
  }
  submit(dto, req) {
    return this.reviewsService.submitReview(dto, req.ip);
  }
  listPublic(campgroundId) {
    return this.reviewsService.listPublic(campgroundId);
  }
  listAdmin(campgroundId, status) {
    return this.reviewsService.listAdmin(campgroundId, status);
  }
  moderate(dto, req) {
    const actorId = req.user?.userId;
    return this.reviewsService.moderate(dto, actorId);
  }
  vote(dto, req) {
    const guestId = req.user?.guestId ?? void 0;
    return this.reviewsService.vote(dto, req.ip, guestId);
  }
  reply(dto) {
    return this.reviewsService.reply(dto);
  }
};
__decorateClass([
  (0, import_common177.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client31.UserRole.owner, import_client31.UserRole.manager, import_client31.UserRole.marketing, import_client31.UserRole.front_desk),
  (0, import_common177.Post)("reviews/requests"),
  __decorateParam(0, (0, import_common177.Body)())
], ReviewsController.prototype, "createRequest", 1);
__decorateClass([
  (0, import_common177.Post)("reviews/submit"),
  __decorateParam(0, (0, import_common177.Body)()),
  __decorateParam(1, (0, import_common177.Req)())
], ReviewsController.prototype, "submit", 1);
__decorateClass([
  (0, import_common177.Get)("reviews/public"),
  __decorateParam(0, (0, import_common177.Query)("campgroundId"))
], ReviewsController.prototype, "listPublic", 1);
__decorateClass([
  (0, import_common177.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client31.UserRole.owner, import_client31.UserRole.manager, import_client31.UserRole.marketing, import_client31.UserRole.front_desk, import_client31.UserRole.readonly),
  (0, import_common177.Get)("reviews"),
  __decorateParam(0, (0, import_common177.Query)("campgroundId")),
  __decorateParam(1, (0, import_common177.Query)("status"))
], ReviewsController.prototype, "listAdmin", 1);
__decorateClass([
  (0, import_common177.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client31.UserRole.owner, import_client31.UserRole.manager, import_client31.UserRole.marketing),
  (0, import_common177.Post)("reviews/moderate"),
  __decorateParam(0, (0, import_common177.Body)()),
  __decorateParam(1, (0, import_common177.Req)())
], ReviewsController.prototype, "moderate", 1);
__decorateClass([
  (0, import_common177.Post)("reviews/vote"),
  __decorateParam(0, (0, import_common177.Body)()),
  __decorateParam(1, (0, import_common177.Req)())
], ReviewsController.prototype, "vote", 1);
__decorateClass([
  (0, import_common177.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client31.UserRole.owner, import_client31.UserRole.manager, import_client31.UserRole.front_desk),
  (0, import_common177.Post)("reviews/reply"),
  __decorateParam(0, (0, import_common177.Body)())
], ReviewsController.prototype, "reply", 1);
ReviewsController = __decorateClass([
  (0, import_common177.Controller)()
], ReviewsController);

// src/reviews/reviews.service.ts
var import_common178 = require("@nestjs/common");
var import_crypto16 = require("crypto");
var import_client32 = require("@prisma/client");
function baseAppUrl2() {
  const url = process.env.PUBLIC_WEB_URL || process.env.NEXT_PUBLIC_APP_URL || "https://app.campreserv.com";
  return url.endsWith("/") ? url.slice(0, -1) : url;
}
var ReviewsService = class {
  constructor(prisma, emailService, gamification) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.gamification = gamification;
  }
  generateToken() {
    return (0, import_crypto16.randomBytes)(24).toString("hex");
  }
  hashIp(ip) {
    if (!ip) return null;
    return (0, import_crypto16.createHash)("sha256").update(ip).digest("hex");
  }
  async resolveGuestContact(guestId, reservationId, email, phone) {
    if (guestId) {
      const guest = await this.prisma.guest.findUnique({
        where: { id: guestId },
        select: { email: true, phone: true, primaryFirstName: true, primaryLastName: true }
      });
      if (guest) {
        return {
          email: email ?? guest.email,
          phone: phone ?? guest.phone,
          name: `${guest.primaryFirstName} ${guest.primaryLastName}`
        };
      }
    }
    if (reservationId) {
      const reservation = await this.prisma.reservation.findUnique({
        where: { id: reservationId },
        select: {
          guest: { select: { email: true, phone: true, primaryFirstName: true, primaryLastName: true } }
        }
      });
      if (reservation?.guest) {
        const g = reservation.guest;
        return {
          email: email ?? g.email,
          phone: phone ?? g.phone,
          name: `${g.primaryFirstName} ${g.primaryLastName}`
        };
      }
    }
    return { email, phone, name: void 0 };
  }
  async createRequest(dto) {
    const contact = await this.resolveGuestContact(dto.guestId, dto.reservationId, dto.email, dto.phone);
    const token = this.generateToken();
    const expiresAt = dto.expireDays ? new Date(Date.now() + dto.expireDays * 24 * 60 * 60 * 1e3) : null;
    const link = `${baseAppUrl2()}/reviews/submit?token=${token}`;
    const request = await this.prisma.reviewRequest.create({
      data: {
        campgroundId: dto.campgroundId,
        organizationId: dto.organizationId ?? null,
        guestId: dto.guestId ?? null,
        reservationId: dto.reservationId ?? null,
        channel: dto.channel,
        status: dto.channel === "email" ? "sent" : "queued",
        token,
        expiresAt,
        sentAt: dto.channel === "email" ? /* @__PURE__ */ new Date() : null,
        metadata: { link }
      }
    });
    if (dto.channel === "email") {
      if (!contact.email) throw new import_common178.BadRequestException("Email required for email channel");
      const subject = "Share your experience with us";
      const guestName = contact.name || "there";
      const html = `
        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 640px; margin: 0 auto; padding: 20px;">
          <h2 style="color: #0f172a; margin-bottom: 8px;">Hi ${guestName},</h2>
          <p style="color: #475569; line-height: 1.6;">We hope you enjoyed your stay. Would you leave a quick review to help other guests?</p>
          <p style="margin: 16px 0;">
            <a href="${link}" style="background: #22c55e; color: white; padding: 12px 18px; border-radius: 8px; text-decoration: none; font-weight: 600;">Leave a review</a>
          </p>
          <p style="color: #94a3b8; font-size: 12px;">This link is unique to you and may expire.</p>
        </div>
      `;
      await this.emailService.sendEmail({
        to: contact.email,
        subject,
        html,
        guestId: dto.guestId,
        reservationId: dto.reservationId,
        campgroundId: dto.campgroundId
      });
    }
    return request;
  }
  async submitReview(dto, ip) {
    const request = await this.prisma.reviewRequest.findUnique({
      where: { token: dto.token },
      include: { review: true }
    });
    if (!request) throw new import_common178.NotFoundException("Review request not found");
    if (request.expiresAt && request.expiresAt < /* @__PURE__ */ new Date()) {
      await this.prisma.reviewRequest.update({ where: { id: request.id }, data: { status: "expired" } });
      throw new import_common178.BadRequestException("Review link expired");
    }
    if (request.review) throw new import_common178.BadRequestException("Review already submitted");
    const review = await this.prisma.review.create({
      data: {
        campgroundId: request.campgroundId,
        organizationId: request.organizationId ?? null,
        guestId: request.guestId ?? null,
        reservationId: request.reservationId ?? null,
        requestId: request.id,
        rating: dto.rating,
        title: dto.title ?? null,
        body: dto.body ?? null,
        photos: dto.photos ?? [],
        tags: dto.tags ?? [],
        source: request.channel === "kiosk" ? "kiosk" : request.channel === "sms" ? "sms" : "email",
        status: "approved",
        exposure: "public"
      }
    });
    await this.prisma.reviewRequest.update({
      where: { id: request.id },
      data: { status: "responded", respondedAt: /* @__PURE__ */ new Date() }
    });
    await this.prisma.reviewModeration.create({
      data: {
        reviewId: review.id,
        status: "pending",
        reasons: []
      }
    });
    await this.prisma.reviewVote.create({
      data: {
        reviewId: review.id,
        campgroundId: review.campgroundId,
        ipHash: this.hashIp(ip),
        value: "helpful"
      }
    }).catch(() => void 0);
    if (review.reservationId && review.rating >= 4) {
      const reservation = await this.prisma.reservation.findUnique({
        where: { id: review.reservationId },
        select: { id: true, campgroundId: true, createdBy: true }
      });
      if (reservation?.createdBy) {
        const membership = await this.prisma.campgroundMembership.findFirst({
          where: { userId: reservation.createdBy, campgroundId: reservation.campgroundId }
        });
        await this.gamification.recordEvent({
          campgroundId: reservation.campgroundId,
          userId: reservation.createdBy,
          membershipId: membership?.id,
          category: import_client32.GamificationEventCategory.review_mention,
          reason: "Positive guest review",
          sourceType: "review",
          sourceId: review.id,
          eventKey: `review:${review.id}:positive`
        });
      }
    }
    return review;
  }
  async listPublic(campgroundId) {
    return this.prisma.review.findMany({
      where: { campgroundId, status: { not: "removed" } },
      orderBy: { createdAt: "desc" },
      select: {
        id: true,
        rating: true,
        title: true,
        body: true,
        photos: true,
        tags: true,
        createdAt: true,
        replies: true
      }
    });
  }
  async listAdmin(campgroundId, status) {
    return this.prisma.review.findMany({
      where: { campgroundId, ...status ? { status } : {} },
      orderBy: { createdAt: "desc" },
      include: {
        moderation: true,
        guest: { select: { primaryFirstName: true, primaryLastName: true, email: true } },
        reservation: { select: { id: true } }
      }
    });
  }
  async moderate(dto, actorId) {
    const prisma = this.prisma;
    const review = await prisma.review.findUnique({ where: { id: dto.reviewId } });
    if (!review) throw new import_common178.NotFoundException("Review not found");
    await prisma.review.update({
      where: { id: dto.reviewId },
      data: { status: dto.status, exposure: dto.status === "approved" ? "public" : review.exposure }
    });
    await prisma.reviewModeration.upsert({
      where: { reviewId: dto.reviewId },
      create: {
        reviewId: dto.reviewId,
        status: dto.status,
        reasons: dto.reasons ?? [],
        decidedBy: actorId ?? null,
        decidedAt: /* @__PURE__ */ new Date(),
        notes: dto.notes ?? null
      },
      update: {
        status: dto.status,
        reasons: dto.reasons ?? [],
        decidedBy: actorId ?? null,
        decidedAt: /* @__PURE__ */ new Date(),
        notes: dto.notes ?? null
      }
    });
    return { ok: true };
  }
  async vote(dto, ip, guestId) {
    const review = await this.prisma.review.findUnique({ where: { id: dto.reviewId } });
    if (!review) throw new import_common178.NotFoundException("Review not found");
    const ipHash = this.hashIp(ip ?? "");
    if (guestId) {
      const vote = await this.prisma.reviewVote.upsert({
        where: { reviewId_guestId: { reviewId: dto.reviewId, guestId } },
        update: { value: dto.value, ipHash },
        create: {
          reviewId: dto.reviewId,
          guestId,
          ipHash,
          campgroundId: review.campgroundId,
          value: dto.value
        }
      });
      return vote;
    }
    const existing = ipHash ? await this.prisma.reviewVote.findFirst({ where: { reviewId: dto.reviewId, ipHash } }) : null;
    if (existing) {
      return this.prisma.reviewVote.update({
        where: { id: existing.id },
        data: { value: dto.value, ipHash }
      });
    }
    return this.prisma.reviewVote.create({
      data: { reviewId: dto.reviewId, guestId: null, ipHash, campgroundId: review.campgroundId, value: dto.value }
    });
  }
  async reply(dto) {
    const review = await this.prisma.review.findUnique({ where: { id: dto.reviewId } });
    if (!review) throw new import_common178.NotFoundException("Review not found");
    return this.prisma.reviewReply.create({
      data: {
        reviewId: dto.reviewId,
        authorType: dto.authorType,
        authorId: dto.authorId ?? null,
        body: dto.body
      }
    });
  }
};
ReviewsService = __decorateClass([
  (0, import_common178.Injectable)()
], ReviewsService);

// src/reviews/reviews.module.ts
var ReviewsModule = class {
};
ReviewsModule = __decorateClass([
  (0, import_common179.Module)({
    imports: [EmailModule, GamificationModule],
    controllers: [ReviewsController],
    providers: [ReviewsService, PrismaService],
    exports: [ReviewsService]
  })
], ReviewsModule);

// src/forms/forms.module.ts
var import_common182 = require("@nestjs/common");

// src/forms/forms.service.ts
var import_common180 = require("@nestjs/common");
var import_client33 = require("@prisma/client");
var FormsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  listByCampground(campgroundId) {
    return this.prisma.formTemplate.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" }
    });
  }
  create(data) {
    return this.prisma.formTemplate.create({
      data: {
        campgroundId: data.campgroundId,
        title: data.title,
        type: data.type,
        description: data.description ?? null,
        fields: data.fields ?? import_client33.Prisma.DbNull,
        isActive: data.isActive ?? true
      }
    });
  }
  async update(id, data) {
    const existing = await this.prisma.formTemplate.findUnique({ where: { id } });
    if (!existing) throw new import_common180.NotFoundException("Form template not found");
    return this.prisma.formTemplate.update({
      where: { id },
      data: {
        title: data.title ?? void 0,
        type: data.type ?? void 0,
        description: data.description ?? void 0,
        fields: data.fields ?? void 0,
        isActive: data.isActive ?? void 0,
        version: existing.version + 1
      }
    });
  }
  async remove(id) {
    const existing = await this.prisma.formTemplate.findUnique({ where: { id } });
    if (!existing) throw new import_common180.NotFoundException("Form template not found");
    await this.prisma.formTemplate.delete({ where: { id } });
    return { id };
  }
  listSubmissions(filters) {
    return this.prisma.formSubmission.findMany({
      where: {
        reservationId: filters.reservationId,
        guestId: filters.guestId
      },
      include: {
        formTemplate: { select: { id: true, title: true, type: true } }
      },
      orderBy: { createdAt: "desc" }
    });
  }
  async createSubmission(data) {
    const template = await this.prisma.formTemplate.findUnique({ where: { id: data.formTemplateId } });
    if (!template) throw new import_common180.NotFoundException("Form template not found");
    return this.prisma.formSubmission.create({
      data: {
        formTemplateId: data.formTemplateId,
        reservationId: data.reservationId ?? null,
        guestId: data.guestId ?? null,
        responses: data.responses ?? import_client33.Prisma.DbNull
      },
      include: { formTemplate: { select: { id: true, title: true, type: true } } }
    });
  }
  async updateSubmission(id, data) {
    const existing = await this.prisma.formSubmission.findUnique({ where: { id } });
    if (!existing) throw new import_common180.NotFoundException("Form submission not found");
    return this.prisma.formSubmission.update({
      where: { id },
      data: {
        status: data.status ?? void 0,
        responses: data.responses ?? void 0,
        signedAt: data.status === "completed" ? /* @__PURE__ */ new Date() : void 0
      },
      include: { formTemplate: { select: { id: true, title: true, type: true } } }
    });
  }
  async deleteSubmission(id) {
    const existing = await this.prisma.formSubmission.findUnique({ where: { id } });
    if (!existing) throw new import_common180.NotFoundException("Form submission not found");
    await this.prisma.formSubmission.delete({ where: { id } });
    return { id };
  }
};
FormsService = __decorateClass([
  (0, import_common180.Injectable)()
], FormsService);

// src/forms/forms.controller.ts
var import_common181 = require("@nestjs/common");
var FormsController = class {
  constructor(forms) {
    this.forms = forms;
  }
  listByCampground(campgroundId) {
    return this.forms.listByCampground(campgroundId);
  }
  create(body) {
    return this.forms.create(body);
  }
  update(id, body) {
    return this.forms.update(id, body);
  }
  remove(id) {
    return this.forms.remove(id);
  }
  listForReservation(reservationId) {
    return this.forms.listSubmissions({ reservationId });
  }
  listForGuest(guestId) {
    return this.forms.listSubmissions({ guestId });
  }
  createSubmission(body) {
    return this.forms.createSubmission(body);
  }
  updateSubmission(id, body) {
    return this.forms.updateSubmission(id, body);
  }
  deleteSubmission(id) {
    return this.forms.deleteSubmission(id);
  }
};
__decorateClass([
  (0, import_common181.Get)("campgrounds/:campgroundId/forms"),
  __decorateParam(0, (0, import_common181.Param)("campgroundId"))
], FormsController.prototype, "listByCampground", 1);
__decorateClass([
  (0, import_common181.Post)("forms"),
  __decorateParam(0, (0, import_common181.Body)())
], FormsController.prototype, "create", 1);
__decorateClass([
  (0, import_common181.Patch)("forms/:id"),
  __decorateParam(0, (0, import_common181.Param)("id")),
  __decorateParam(1, (0, import_common181.Body)())
], FormsController.prototype, "update", 1);
__decorateClass([
  (0, import_common181.Delete)("forms/:id"),
  __decorateParam(0, (0, import_common181.Param)("id"))
], FormsController.prototype, "remove", 1);
__decorateClass([
  (0, import_common181.Get)("reservations/:reservationId/forms"),
  __decorateParam(0, (0, import_common181.Param)("reservationId"))
], FormsController.prototype, "listForReservation", 1);
__decorateClass([
  (0, import_common181.Get)("guests/:guestId/forms"),
  __decorateParam(0, (0, import_common181.Param)("guestId"))
], FormsController.prototype, "listForGuest", 1);
__decorateClass([
  (0, import_common181.Post)("forms/submissions"),
  __decorateParam(0, (0, import_common181.Body)())
], FormsController.prototype, "createSubmission", 1);
__decorateClass([
  (0, import_common181.Patch)("forms/submissions/:id"),
  __decorateParam(0, (0, import_common181.Param)("id")),
  __decorateParam(1, (0, import_common181.Body)())
], FormsController.prototype, "updateSubmission", 1);
__decorateClass([
  (0, import_common181.Delete)("forms/submissions/:id"),
  __decorateParam(0, (0, import_common181.Param)("id"))
], FormsController.prototype, "deleteSubmission", 1);
FormsController = __decorateClass([
  (0, import_common181.UseGuards)(JwtAuthGuard),
  (0, import_common181.Controller)()
], FormsController);

// src/forms/forms.module.ts
var FormsModule = class {
};
FormsModule = __decorateClass([
  (0, import_common182.Module)({
    controllers: [FormsController],
    providers: [FormsService, PrismaService]
  })
], FormsModule);

// src/social-planner/social-planner.module.ts
var import_common186 = require("@nestjs/common");

// src/social-planner/social-planner.controller.ts
var import_common183 = require("@nestjs/common");
var SocialPlannerController = class {
  constructor(service) {
    this.service = service;
  }
  listPosts(campgroundId) {
    return this.service.listPosts(campgroundId);
  }
  getPost(id) {
    return this.service.getPost(id);
  }
  createPost(dto) {
    return this.service.createPost(dto);
  }
  updatePost(id, dto) {
    return this.service.updatePost(id, dto);
  }
  deletePost(id) {
    return this.service.deletePost(id);
  }
  listTemplates(campgroundId) {
    return this.service.listTemplates(campgroundId);
  }
  createTemplate(dto) {
    return this.service.createTemplate(dto);
  }
  updateTemplate(id, dto) {
    return this.service.updateTemplate(id, dto);
  }
  deleteTemplate(id) {
    return this.service.deleteTemplate(id);
  }
  listAssets(campgroundId) {
    return this.service.listAssets(campgroundId);
  }
  createAsset(dto) {
    return this.service.createAsset(dto);
  }
  updateAsset(id, dto) {
    return this.service.updateAsset(id, dto);
  }
  deleteAsset(id) {
    return this.service.deleteAsset(id);
  }
  listSuggestions(campgroundId, status) {
    return this.service.listSuggestions(campgroundId, status);
  }
  createSuggestion(dto) {
    return this.service.createSuggestion(dto);
  }
  refreshSuggestions(campgroundId) {
    return this.service.refreshSuggestions(campgroundId);
  }
  updateSuggestionStatus(id, dto) {
    return this.service.updateSuggestionStatus(id, dto);
  }
  generateWeekly(campgroundId) {
    return this.service.generateWeeklyIdeas(campgroundId);
  }
  createStrategy(dto) {
    return this.service.createStrategy(dto);
  }
  listStrategies(campgroundId) {
    return this.service.listStrategies(campgroundId);
  }
  createAlert(dto) {
    return this.service.createAlert(dto);
  }
  listAlerts(campgroundId) {
    return this.service.listAlerts(campgroundId);
  }
  dismissAlert(id) {
    return this.service.dismissAlert(id);
  }
  recordPerformance(dto) {
    return this.service.recordPerformance(dto);
  }
  report(campgroundId) {
    return this.service.reportSummary(campgroundId);
  }
};
__decorateClass([
  (0, import_common183.Get)("posts"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "listPosts", 1);
__decorateClass([
  (0, import_common183.Get)("posts/:id"),
  __decorateParam(0, (0, import_common183.Param)("id"))
], SocialPlannerController.prototype, "getPost", 1);
__decorateClass([
  (0, import_common183.Post)("posts"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createPost", 1);
__decorateClass([
  (0, import_common183.Patch)("posts/:id"),
  __decorateParam(0, (0, import_common183.Param)("id")),
  __decorateParam(1, (0, import_common183.Body)())
], SocialPlannerController.prototype, "updatePost", 1);
__decorateClass([
  (0, import_common183.Delete)("posts/:id"),
  __decorateParam(0, (0, import_common183.Param)("id"))
], SocialPlannerController.prototype, "deletePost", 1);
__decorateClass([
  (0, import_common183.Get)("templates"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "listTemplates", 1);
__decorateClass([
  (0, import_common183.Post)("templates"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createTemplate", 1);
__decorateClass([
  (0, import_common183.Patch)("templates/:id"),
  __decorateParam(0, (0, import_common183.Param)("id")),
  __decorateParam(1, (0, import_common183.Body)())
], SocialPlannerController.prototype, "updateTemplate", 1);
__decorateClass([
  (0, import_common183.Delete)("templates/:id"),
  __decorateParam(0, (0, import_common183.Param)("id"))
], SocialPlannerController.prototype, "deleteTemplate", 1);
__decorateClass([
  (0, import_common183.Get)("assets"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "listAssets", 1);
__decorateClass([
  (0, import_common183.Post)("assets"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createAsset", 1);
__decorateClass([
  (0, import_common183.Patch)("assets/:id"),
  __decorateParam(0, (0, import_common183.Param)("id")),
  __decorateParam(1, (0, import_common183.Body)())
], SocialPlannerController.prototype, "updateAsset", 1);
__decorateClass([
  (0, import_common183.Delete)("assets/:id"),
  __decorateParam(0, (0, import_common183.Param)("id"))
], SocialPlannerController.prototype, "deleteAsset", 1);
__decorateClass([
  (0, import_common183.Get)("suggestions"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId")),
  __decorateParam(1, (0, import_common183.Query)("status"))
], SocialPlannerController.prototype, "listSuggestions", 1);
__decorateClass([
  (0, import_common183.Post)("suggestions"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createSuggestion", 1);
__decorateClass([
  (0, import_common183.Post)("suggestions/refresh"),
  __decorateParam(0, (0, import_common183.Body)("campgroundId"))
], SocialPlannerController.prototype, "refreshSuggestions", 1);
__decorateClass([
  (0, import_common183.Patch)("suggestions/:id/status"),
  __decorateParam(0, (0, import_common183.Param)("id")),
  __decorateParam(1, (0, import_common183.Body)())
], SocialPlannerController.prototype, "updateSuggestionStatus", 1);
__decorateClass([
  (0, import_common183.Post)("weekly"),
  __decorateParam(0, (0, import_common183.Body)("campgroundId"))
], SocialPlannerController.prototype, "generateWeekly", 1);
__decorateClass([
  (0, import_common183.Post)("strategies"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createStrategy", 1);
__decorateClass([
  (0, import_common183.Get)("strategies"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "listStrategies", 1);
__decorateClass([
  (0, import_common183.Post)("alerts"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "createAlert", 1);
__decorateClass([
  (0, import_common183.Get)("alerts"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "listAlerts", 1);
__decorateClass([
  (0, import_common183.Post)("alerts/:id/dismiss"),
  __decorateParam(0, (0, import_common183.Param)("id"))
], SocialPlannerController.prototype, "dismissAlert", 1);
__decorateClass([
  (0, import_common183.Post)("performance"),
  __decorateParam(0, (0, import_common183.Body)())
], SocialPlannerController.prototype, "recordPerformance", 1);
__decorateClass([
  (0, import_common183.Get)("reports"),
  __decorateParam(0, (0, import_common183.Query)("campgroundId"))
], SocialPlannerController.prototype, "report", 1);
SocialPlannerController = __decorateClass([
  (0, import_common183.UseGuards)(JwtAuthGuard),
  (0, import_common183.Controller)("social-planner")
], SocialPlannerController);

// src/social-planner/social-planner.service.ts
var import_common184 = require("@nestjs/common");
var import_client34 = require("@prisma/client");
var addDays3 = (date, days) => {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
};
var toDate = (value) => {
  if (!value) return void 0;
  return typeof value === "string" ? new Date(value) : value;
};
var SocialPlannerService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.logger = new import_common184.Logger(SocialPlannerService.name);
  }
  // Posts
  async listPosts(campgroundId) {
    return this.prisma.socialPost.findMany({
      where: { campgroundId },
      orderBy: [{ scheduledFor: "asc" }, { createdAt: "desc" }],
      include: { template: true, suggestion: true }
    });
  }
  async getPost(id) {
    return this.prisma.socialPost.findUnique({ where: { id }, include: { template: true, suggestion: true } });
  }
  async createPost(dto) {
    const data = {
      campground: { connect: { id: dto.campgroundId } },
      title: dto.title,
      platform: dto.platform,
      status: dto.status || import_client34.SocialPostStatus.draft,
      category: dto.category,
      scheduledFor: toDate(dto.scheduledFor) ?? null,
      publishedFor: toDate(dto.publishedFor) ?? null,
      caption: dto.caption ?? null,
      hashtags: dto.hashtags ?? [],
      imagePrompt: dto.imagePrompt ?? null,
      notes: dto.notes ?? null,
      template: dto.templateId ? { connect: { id: dto.templateId } } : void 0,
      assetUrls: dto.assetUrls ?? [],
      tags: dto.tags ?? [],
      ideaParkingLot: dto.ideaParkingLot ?? false,
      suggestion: dto.suggestionId ? { connect: { id: dto.suggestionId } } : void 0
    };
    return this.prisma.socialPost.create({ data });
  }
  async updatePost(id, dto) {
    const data = {
      title: dto.title,
      platform: dto.platform,
      status: dto.status,
      category: dto.category,
      scheduledFor: dto.scheduledFor === void 0 ? void 0 : toDate(dto.scheduledFor) ?? null,
      publishedFor: dto.publishedFor === void 0 ? void 0 : toDate(dto.publishedFor) ?? null,
      caption: dto.caption,
      hashtags: dto.hashtags,
      imagePrompt: dto.imagePrompt,
      notes: dto.notes,
      assetUrls: dto.assetUrls,
      tags: dto.tags,
      ideaParkingLot: dto.ideaParkingLot,
      template: dto.templateId ? { connect: { id: dto.templateId } } : dto.templateId === null ? { disconnect: true } : void 0,
      suggestion: dto.suggestionId ? { connect: { id: dto.suggestionId } } : dto.suggestionId === null ? { disconnect: true } : void 0
    };
    return this.prisma.socialPost.update({ where: { id }, data });
  }
  async deletePost(id) {
    return this.prisma.socialPost.delete({ where: { id } });
  }
  // Templates
  async listTemplates(campgroundId) {
    return this.prisma.socialTemplate.findMany({ where: { campgroundId }, orderBy: [{ createdAt: "desc" }] });
  }
  async createTemplate(dto) {
    const data = {
      campground: { connect: { id: dto.campgroundId } },
      name: dto.name,
      summary: dto.summary ?? null,
      category: dto.category,
      style: dto.style,
      defaultCaption: dto.defaultCaption ?? null,
      captionFillIns: dto.captionFillIns ?? null,
      imageGuidance: dto.imageGuidance ?? null,
      hashtagSet: dto.hashtagSet ?? [],
      bestTime: dto.bestTime ?? null
    };
    return this.prisma.socialTemplate.create({ data });
  }
  async updateTemplate(id, dto) {
    const data = {
      name: dto.name,
      summary: dto.summary,
      category: dto.category,
      style: dto.style,
      defaultCaption: dto.defaultCaption,
      captionFillIns: dto.captionFillIns,
      imageGuidance: dto.imageGuidance,
      hashtagSet: dto.hashtagSet,
      bestTime: dto.bestTime
    };
    return this.prisma.socialTemplate.update({ where: { id }, data });
  }
  async deleteTemplate(id) {
    return this.prisma.socialTemplate.delete({ where: { id } });
  }
  // Assets (content bank)
  async listAssets(campgroundId) {
    return this.prisma.socialContentAsset.findMany({ where: { campgroundId }, orderBy: [{ createdAt: "desc" }] });
  }
  async createAsset(dto) {
    const data = {
      campground: { connect: { id: dto.campgroundId } },
      title: dto.title,
      type: dto.type,
      url: dto.url,
      tags: dto.tags ?? [],
      notes: dto.notes ?? null,
      uploadedBy: dto.uploadedById ? { connect: { id: dto.uploadedById } } : void 0
    };
    return this.prisma.socialContentAsset.create({ data });
  }
  async updateAsset(id, dto) {
    const data = {
      title: dto.title,
      type: dto.type,
      url: dto.url,
      tags: dto.tags,
      notes: dto.notes,
      uploadedBy: dto.uploadedById ? { connect: { id: dto.uploadedById } } : dto.uploadedById === null ? { disconnect: true } : void 0
    };
    return this.prisma.socialContentAsset.update({ where: { id }, data });
  }
  async deleteAsset(id) {
    return this.prisma.socialContentAsset.delete({ where: { id } });
  }
  // Suggestions
  async listSuggestions(campgroundId, status) {
    return this.prisma.socialSuggestion.findMany({
      where: { campgroundId, status: status || void 0 },
      orderBy: [{ proposedDate: "asc" }, { createdAt: "desc" }]
    });
  }
  async createSuggestion(dto) {
    const data = {
      campground: { connect: { id: dto.campgroundId } },
      type: dto.type,
      status: dto.status || import_client34.SocialSuggestionStatus.new,
      message: dto.message,
      reason: dto.reason,
      category: dto.category,
      platform: dto.platform,
      proposedDate: toDate(dto.proposedDate) ?? null,
      opportunityAt: toDate(dto.opportunityAt) ?? null
    };
    return this.prisma.socialSuggestion.create({ data });
  }
  async updateSuggestionStatus(id, dto) {
    const data = {
      status: dto.status
      // relation to post intentionally omitted in stub
    };
    return this.prisma.socialSuggestion.update({ where: { id }, data });
  }
  async refreshSuggestions(campgroundId) {
    await this.prisma.socialSuggestion.deleteMany({
      where: { campgroundId, status: import_client34.SocialSuggestionStatus.new }
    });
    const now = /* @__PURE__ */ new Date();
    const recentExisting = await this.prisma.socialSuggestion.findMany({
      where: {
        campgroundId,
        createdAt: { gte: addDays3(now, -7) }
      },
      select: { type: true, message: true, proposedDate: true }
    });
    const generated = await this.buildRuleBasedSuggestions(campgroundId);
    if (!generated.length) return this.listSuggestions(campgroundId);
    const norm = (msg) => msg.replace(/\s+/g, " ").trim().toLowerCase();
    const dayKey2 = (d) => d ? new Date(d).toISOString().slice(0, 10) : "none";
    const already = new Set(
      recentExisting.map((e) => `${e.type}::${norm(e.message)}::${dayKey2(e.proposedDate)}`)
    );
    const deduped = [];
    const seen = /* @__PURE__ */ new Set();
    for (const g of generated) {
      const key = `${g.type}::${norm(g.message)}::${dayKey2(g.proposedDate)}`;
      if (seen.has(key) || already.has(key)) continue;
      seen.add(key);
      deduped.push(g);
    }
    if (deduped.length) {
      await this.prisma.socialSuggestion.createMany({ data: deduped });
    }
    return this.listSuggestions(campgroundId);
  }
  async buildRuleBasedSuggestions(campgroundId) {
    const now = /* @__PURE__ */ new Date();
    const near = addDays3(now, 14);
    const monthAhead = addDays3(now, 45);
    const siteCount = await this.prisma.site.count({ where: { campgroundId } });
    const reservations = await this.prisma.reservation.count({
      where: {
        campgroundId,
        arrivalDate: { gte: now, lte: near },
        status: { in: ["confirmed", "checked_in"] }
      }
    });
    const suggestions = [];
    const occupancyRatio = siteCount > 0 ? reservations / siteCount : 0;
    if (occupancyRatio >= 0.85) {
      suggestions.push({
        id: void 0,
        campgroundId,
        type: import_client34.SocialSuggestionType.occupancy,
        status: import_client34.SocialSuggestionStatus.new,
        message: "Cabins and premium sites are nearly full next weekend. Post a countdown and encourage early bookings.",
        category: "occupancy",
        platform: "facebook",
        proposedDate: near,
        opportunityAt: near,
        reason: { occupancyRatio, windowDays: 14 },
        createdAt: now,
        updatedAt: now
      });
    } else if (siteCount > 0 && occupancyRatio <= 0.4) {
      suggestions.push({
        id: void 0,
        campgroundId,
        type: import_client34.SocialSuggestionType.occupancy,
        status: import_client34.SocialSuggestionStatus.new,
        message: "Tent and RV sites are under 40% for the upcoming holiday window. Spotlight availability and a simple bundle.",
        category: "occupancy",
        platform: "instagram",
        proposedDate: near,
        opportunityAt: near,
        reason: { occupancyRatio, windowDays: 14 },
        createdAt: now,
        updatedAt: now
      });
    }
    const events = await this.prisma.event.findMany({
      where: { campgroundId, isCancelled: false, startDate: { gte: now, lte: monthAhead } },
      select: { id: true, title: true, startDate: true, currentSignups: true, capacity: true },
      orderBy: { startDate: "asc" }
    });
    events.forEach((event) => {
      const utilization = event.capacity ? event.currentSignups / event.capacity : 0;
      if (utilization < 0.5) {
        suggestions.push({
          id: void 0,
          campgroundId,
          type: import_client34.SocialSuggestionType.event,
          status: import_client34.SocialSuggestionStatus.new,
          message: `${event.title} sign-ups are light. Post a reminder and add a quick RSVP link.`,
          category: "events",
          platform: "facebook",
          proposedDate: event.startDate,
          opportunityAt: event.startDate,
          reason: { utilization, capacity: event.capacity, startDate: event.startDate },
          createdAt: now,
          updatedAt: now
        });
      } else {
        suggestions.push({
          id: void 0,
          campgroundId,
          type: import_client34.SocialSuggestionType.event,
          status: import_client34.SocialSuggestionStatus.new,
          message: `${event.title} is coming up. Run a teaser and behind-the-scenes post this week.`,
          category: "events",
          platform: "instagram",
          proposedDate: addDays3(event.startDate, -7),
          opportunityAt: event.startDate,
          reason: { startDate: event.startDate },
          createdAt: now,
          updatedAt: now
        });
      }
    });
    const promotions = await this.prisma.promotion.findMany({
      where: {
        campgroundId,
        isActive: true,
        AND: [
          { OR: [{ validFrom: null }, { validFrom: { lte: now } }] },
          { OR: [{ validTo: null }, { validTo: { gte: now } }] }
        ]
      },
      orderBy: { createdAt: "desc" }
    });
    promotions.forEach((promo) => {
      suggestions.push({
        id: void 0,
        campgroundId,
        type: import_client34.SocialSuggestionType.deal,
        status: import_client34.SocialSuggestionStatus.new,
        message: `Promote ${promo.code} \u2014 it has ${promo.usageCount} uses. Share how it works in a carousel.`,
        category: "deals",
        platform: "instagram",
        proposedDate: addDays3(now, 2),
        opportunityAt: now,
        reason: { promotionId: promo.id, usageCount: promo.usageCount },
        createdAt: now,
        updatedAt: now
      });
    });
    const month = now.getMonth();
    if (month === 9) {
      suggestions.push({
        id: void 0,
        campgroundId,
        type: import_client34.SocialSuggestionType.seasonal,
        status: import_client34.SocialSuggestionStatus.new,
        message: "Halloween build-up: tease decorations, costume contests, and pumpkin carving.",
        category: "holiday",
        platform: "facebook",
        proposedDate: addDays3(now, 3),
        opportunityAt: addDays3(now, 7),
        reason: { season: "halloween" },
        createdAt: now,
        updatedAt: now
      });
    } else if (month === 5) {
      suggestions.push({
        id: void 0,
        campgroundId,
        type: import_client34.SocialSuggestionType.seasonal,
        status: import_client34.SocialSuggestionStatus.new,
        message: "Pool opening season \u2014 share a countdown and first swim weekend.",
        category: "pool",
        platform: "instagram",
        proposedDate: addDays3(now, 2),
        opportunityAt: addDays3(now, 7),
        reason: { season: "pool_opening" },
        createdAt: now,
        updatedAt: now
      });
    }
    return suggestions;
  }
  // Weekly ideas (auto-generated)
  async generateWeeklyIdeas(campgroundId) {
    const anchor = this.getMondayAnchor(/* @__PURE__ */ new Date());
    const existing = await this.prisma.socialWeeklyIdea.findUnique({ where: { campgroundId_generatedFor: { campgroundId, generatedFor: anchor } } });
    if (existing) return existing;
    const bundle = {
      posts: [
        { type: "promotional", idea: "Book-now highlight with an early-bird hook", platform: "facebook" },
        { type: "engagement", idea: "Staff story or fun moment from the park", platform: "instagram" },
        { type: "behind_the_scenes", idea: "Guest experience or UGC repost with a thank-you", platform: "tiktok" }
      ],
      cadence: [
        { day: "Tuesday", theme: "Book-Now Highlight" },
        { day: "Thursday", theme: "Staff Story or Fun Moment" },
        { day: "Saturday", theme: "Guest Experience / UGC" }
      ]
    };
    return this.prisma.socialWeeklyIdea.create({
      data: {
        campground: { connect: { id: campgroundId } },
        generatedFor: anchor,
        ideas: bundle.posts,
        cadence: bundle.cadence
      }
    });
  }
  getMondayAnchor(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = day === 0 ? -6 : 1 - day;
    d.setDate(d.getDate() + diff);
    d.setUTCHours(0, 0, 0, 0);
    return d;
  }
  // Strategy & alerts
  async createStrategy(dto) {
    return this.prisma.socialStrategy.create({
      data: {
        campground: { connect: { id: dto.campgroundId } },
        month: toDate(dto.month) || /* @__PURE__ */ new Date(),
        annual: dto.annual ?? false,
        plan: dto.plan
      }
    });
  }
  async listStrategies(campgroundId) {
    return this.prisma.socialStrategy.findMany({
      where: { campgroundId },
      orderBy: [{ month: "desc" }]
    });
  }
  async createAlert(dto) {
    return this.prisma.socialOpportunityAlert.create({
      data: {
        campground: { connect: { id: dto.campgroundId } },
        category: dto.category,
        message: dto.message,
        startsAt: toDate(dto.startsAt) ?? null,
        endsAt: toDate(dto.endsAt) ?? null
      }
    });
  }
  async listAlerts(campgroundId) {
    return this.prisma.socialOpportunityAlert.findMany({
      where: { campgroundId },
      orderBy: [{ createdAt: "desc" }]
    });
  }
  async dismissAlert(id) {
    return this.prisma.socialOpportunityAlert.update({ where: { id }, data: { dismissed: true } });
  }
  // Reporting & performance
  async recordPerformance(dto) {
    return this.prisma.socialPerformanceInput.create({
      data: {
        campground: { connect: { id: dto.campgroundId } },
        post: dto.postId ? { connect: { id: dto.postId } } : void 0,
        likes: dto.likes ?? null,
        reach: dto.reach ?? null,
        comments: dto.comments ?? null,
        saves: dto.saves ?? null,
        shares: dto.shares ?? null,
        notes: dto.notes ?? null,
        recordedAt: toDate(dto.recordedAt) ?? /* @__PURE__ */ new Date()
      }
    });
  }
  async reportSummary(campgroundId) {
    const [posts, templates, suggestions, performance] = await Promise.all([
      this.prisma.socialPost.count({ where: { campgroundId } }),
      this.prisma.socialTemplate.count({ where: { campgroundId } }),
      this.prisma.socialSuggestion.count({ where: { campgroundId, status: import_client34.SocialSuggestionStatus.new } }),
      this.prisma.socialPerformanceInput.findMany({
        where: { campgroundId },
        select: { likes: true, reach: true, comments: true, shares: true, saves: true }
      })
    ]);
    const metrics = performance.reduce(
      (acc, row) => {
        acc.likes += row.likes ?? 0;
        acc.reach += row.reach ?? 0;
        acc.comments += row.comments ?? 0;
        acc.shares += row.shares ?? 0;
        acc.saves += row.saves ?? 0;
        return acc;
      },
      { likes: 0, reach: 0, comments: 0, shares: 0, saves: 0 }
    );
    return {
      posts,
      templates,
      openSuggestions: suggestions,
      performance: metrics
    };
  }
  // Scheduler helpers
  async generateWeeklyIdeasForAllCampgrounds() {
    const camps = await this.prisma.campground.findMany({ select: { id: true } });
    for (const camp of camps) {
      try {
        await this.generateWeeklyIdeas(camp.id);
      } catch (err) {
        this.logger.error(`Failed to generate weekly ideas for ${camp.id}`, err);
      }
    }
  }
};
SocialPlannerService = __decorateClass([
  (0, import_common184.Injectable)()
], SocialPlannerService);

// src/social-planner/social-planner.scheduler.ts
var import_common185 = require("@nestjs/common");
var import_schedule11 = require("@nestjs/schedule");
var SocialPlannerScheduler = class {
  constructor(planner) {
    this.planner = planner;
    this.logger = new import_common185.Logger(SocialPlannerScheduler.name);
  }
  async generateWeeklyIdeas() {
    this.logger.log("Generating weekly social planner ideas for all campgrounds");
    await this.planner.generateWeeklyIdeasForAllCampgrounds();
  }
};
__decorateClass([
  (0, import_schedule11.Cron)("0 7 * * 1")
], SocialPlannerScheduler.prototype, "generateWeeklyIdeas", 1);
SocialPlannerScheduler = __decorateClass([
  (0, import_common185.Injectable)()
], SocialPlannerScheduler);

// src/social-planner/social-planner.module.ts
var SocialPlannerModule = class {
};
SocialPlannerModule = __decorateClass([
  (0, import_common186.Module)({
    controllers: [SocialPlannerController],
    providers: [SocialPlannerService, SocialPlannerScheduler, PrismaService],
    exports: [SocialPlannerService]
  })
], SocialPlannerModule);

// src/analytics/analytics.module.ts
var import_common189 = require("@nestjs/common");

// src/analytics/analytics.service.ts
var import_common187 = require("@nestjs/common");
var import_schedule12 = require("@nestjs/schedule");
var import_client35 = require("@prisma/client");
var import_crypto17 = require("crypto");
var MOCK_MODE = process.env.ANALYTICS_MOCK_MODE === "true";
var mockStore = {
  events: [],
  aggregates: /* @__PURE__ */ new Map()
};
var MOCK_EVENT_LIMIT = 2e3;
function dayKey(d) {
  const copy = new Date(d);
  copy.setUTCHours(0, 0, 0, 0);
  return copy.toISOString();
}
function recordMockEvent(raw) {
  const occurredAt = raw.occurredAt || /* @__PURE__ */ new Date();
  const event = { ...raw, occurredAt };
  mockStore.events.push(event);
  if (mockStore.events.length > MOCK_EVENT_LIMIT) {
    mockStore.events.shift();
  }
  const key = `${raw.campgroundId ?? "mock"}|${raw.eventName}|${dayKey(occurredAt)}`;
  const entry = mockStore.aggregates.get(key) ?? { count: 0, sessions: /* @__PURE__ */ new Set() };
  entry.count += 1;
  if (raw.sessionId) entry.sessions.add(raw.sessionId);
  mockStore.aggregates.set(key, entry);
  return event;
}
function getMockAggregates(campgroundId, since) {
  const results = [];
  for (const [key, value] of mockStore.aggregates.entries()) {
    const [cg, eventName, dateStr] = key.split("|");
    const date = new Date(dateStr);
    if (cg === (campgroundId ?? "mock") && date >= since) {
      results.push({
        campgroundId: cg,
        eventName,
        date,
        count: value.count,
        uniqueSessions: value.sessions.size
      });
    }
  }
  return results;
}
function getMockEvents(campgroundId, since) {
  return mockStore.events.filter((e) => (e.campgroundId ?? "mock") === (campgroundId ?? "mock") && e.occurredAt >= since);
}
var AnalyticsService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
    this.logger = new import_common187.Logger(AnalyticsService.name);
  }
  async ingest(dto, scope) {
    const occurredAt = dto.occurredAt ? new Date(dto.occurredAt) : /* @__PURE__ */ new Date();
    if (MOCK_MODE) {
      return recordMockEvent({
        sessionId: dto.sessionId,
        eventName: dto.eventName,
        occurredAt,
        page: dto.page,
        referrer: dto.referrer,
        referrerUrl: dto.referrerUrl,
        deviceType: dto.deviceType,
        region: dto.region,
        campgroundId: dto.campgroundId ?? scope.campgroundId ?? "mock",
        organizationId: dto.organizationId ?? scope.organizationId ?? void 0,
        reservationId: dto.reservationId,
        siteId: dto.siteId,
        siteClassId: dto.siteClassId,
        promotionId: dto.promotionId,
        imageId: dto.imageId,
        abVariantId: dto.abVariantId,
        metadata: dto.metadata
      });
    }
    const data = {
      sessionId: dto.sessionId,
      eventName: dto.eventName,
      occurredAt,
      page: dto.page,
      referrer: dto.referrer,
      referrerUrl: dto.referrerUrl,
      deviceType: dto.deviceType,
      region: dto.region,
      metadata: dto.metadata,
      createdAt: /* @__PURE__ */ new Date(),
      campground: dto.campgroundId ? { connect: { id: dto.campgroundId } } : scope.campgroundId ? { connect: { id: scope.campgroundId } } : void 0,
      organization: dto.organizationId ? { connect: { id: dto.organizationId } } : scope.organizationId ? { connect: { id: scope.organizationId } } : void 0,
      reservation: dto.reservationId ? { connect: { id: dto.reservationId } } : void 0,
      site: dto.siteId ? { connect: { id: dto.siteId } } : void 0,
      siteClass: dto.siteClassId ? { connect: { id: dto.siteClassId } } : void 0,
      promotion: dto.promotionId ? { connect: { id: dto.promotionId } } : void 0,
      abVariant: dto.abVariantId ? { connect: { id: dto.abVariantId } } : void 0,
      imageId: dto.imageId
    };
    const event = await this.prisma.analyticsEvent.create({ data });
    await this.updateDailyAggregate({
      campgroundId: dto.campgroundId ?? scope.campgroundId ?? null,
      organizationId: dto.organizationId ?? scope.organizationId ?? null,
      eventName: dto.eventName,
      sessionId: dto.sessionId,
      occurredAt
    });
    return event;
  }
  async updateDailyAggregate(params) {
    if (MOCK_MODE) {
      return;
    }
    if (!params.campgroundId && !params.organizationId) {
      return;
    }
    const dayStart = new Date(params.occurredAt);
    dayStart.setUTCHours(0, 0, 0, 0);
    await this.prisma.analyticsDailyAggregate.upsert({
      where: {
        campgroundId_eventName_date: {
          campgroundId: params.campgroundId ?? null,
          eventName: params.eventName,
          date: dayStart
        }
      },
      create: {
        campground: params.campgroundId ? { connect: { id: params.campgroundId } } : void 0,
        organization: params.organizationId ? { connect: { id: params.organizationId } } : void 0,
        eventName: params.eventName,
        date: dayStart,
        count: 1,
        uniqueSessions: params.sessionId ? 1 : 0
      },
      update: {
        count: { increment: 1 },
        uniqueSessions: params.sessionId ? { increment: 1 } : void 0
      }
    });
  }
  async refreshDailyAggregates() {
    if (MOCK_MODE) {
      return;
    }
    const rows = await this.prisma.$queryRaw`
      SELECT
        "campgroundId",
        "organizationId",
        "eventName",
        date_trunc('day', "occurredAt") AS date,
        COUNT(*)::bigint AS count,
        COUNT(DISTINCT "sessionId")::bigint AS "uniqueSessions"
      FROM "AnalyticsEvent"
      WHERE "occurredAt" >= NOW() - INTERVAL '3 day'
      GROUP BY "campgroundId", "organizationId", "eventName", date
    `;
    for (const row of rows) {
      if (!row.campgroundId) continue;
      await this.prisma.analyticsDailyAggregate.upsert({
        where: {
          campgroundId_eventName_date: {
            campgroundId: row.campgroundId,
            eventName: row.eventName,
            date: row.date
          }
        },
        create: {
          campground: row.campgroundId ? { connect: { id: row.campgroundId } } : void 0,
          organization: row.organizationId ? { connect: { id: row.organizationId } } : void 0,
          eventName: row.eventName,
          date: row.date,
          count: Number(row.count),
          uniqueSessions: Number(row.uniqueSessions)
        },
        update: {
          count: Number(row.count),
          uniqueSessions: Number(row.uniqueSessions)
        }
      });
    }
    this.logger.debug(`Refreshed analytics daily aggregates (${rows.length} rows)`);
  }
  async enforceRetention() {
    if (MOCK_MODE) {
      const days2 = Number(process.env.ANALYTICS_RETENTION_DAYS || 395);
      const cutoff2 = /* @__PURE__ */ new Date();
      cutoff2.setDate(cutoff2.getDate() - days2);
      mockStore.events = mockStore.events.filter((e) => e.occurredAt >= cutoff2);
      for (const [key] of mockStore.aggregates.entries()) {
        const [, , dateStr] = key.split("|");
        const d = new Date(dateStr);
        if (d < cutoff2) mockStore.aggregates.delete(key);
      }
      return;
    }
    const days = Number(process.env.ANALYTICS_RETENTION_DAYS || 395);
    const cutoff = /* @__PURE__ */ new Date();
    cutoff.setDate(cutoff.getDate() - days);
    const deleted = await this.prisma.analyticsEvent.deleteMany({
      where: { occurredAt: { lt: cutoff } }
    });
    if (deleted.count > 0) {
      this.logger.log(`Analytics retention pruned ${deleted.count} events older than ${days} days`);
    }
  }
  async getRecommendations(campgroundId) {
    if (!campgroundId) {
      throw new import_common187.BadRequestException("campgroundId is required");
    }
    const since = /* @__PURE__ */ new Date();
    since.setDate(since.getDate() - 7);
    const aggregates = MOCK_MODE ? getMockAggregates(campgroundId, since) : await this.prisma.analyticsDailyAggregate.findMany({
      where: { campgroundId, date: { gte: since } }
    });
    const sum = (event) => aggregates.filter((a) => a.eventName === event).reduce((acc, cur) => acc + (cur.count || 0), 0);
    const addToStay = sum(import_client35.AnalyticsEventName.add_to_stay);
    const completes = sum(import_client35.AnalyticsEventName.reservation_completed);
    const abandons = sum(import_client35.AnalyticsEventName.reservation_abandoned);
    const imageViews = sum(import_client35.AnalyticsEventName.image_viewed);
    const imageClicks = sum(import_client35.AnalyticsEventName.image_clicked);
    const availabilityChecks = sum(import_client35.AnalyticsEventName.availability_check);
    const dealViews = sum(import_client35.AnalyticsEventName.deal_viewed);
    const dealApplies = sum(import_client35.AnalyticsEventName.deal_applied);
    const recommendations = [];
    const funnelBase = Math.max(addToStay, 1);
    const abandonmentRate = abandons / funnelBase;
    if (abandonmentRate > 0.4) {
      recommendations.push({
        id: "pricing-soften",
        type: "pricing",
        title: "Lower midweek rates to recover drop-offs",
        explanation: `Abandonment is ${(abandonmentRate * 100).toFixed(0)}% of add-to-stay events. Consider a temporary midweek reduction to improve conversion.`,
        confidence: "medium",
        projectedImpact: "3\u20137% booking lift on low-occupancy nights",
        action: "apply_pricing_adjustment",
        applyAllowed: true,
        requiresApproval: true
      });
    }
    if (imageViews > 10 && imageClicks / Math.max(imageViews, 1) < 0.2) {
      recommendations.push({
        id: "image-order",
        type: "images",
        title: "Reorder hero images for better engagement",
        explanation: "Image click-through is low compared to views. Moving high-performing images earlier can lift add-to-stay.",
        confidence: "medium",
        projectedImpact: "5\u201310% lift in detail clicks",
        action: "reorder_images",
        applyAllowed: true,
        requiresApproval: true
      });
    }
    if (availabilityChecks > addToStay * 1.5) {
      recommendations.push({
        id: "availability-highlight",
        type: "availability",
        title: "Highlight available alternatives for searched dates",
        explanation: "Guests are checking availability but not committing. Highlight nearby dates or alternative site classes.",
        confidence: "low",
        projectedImpact: "2\u20135% lift in add-to-stay",
        action: "promote_alternates",
        applyAllowed: false,
        requiresApproval: true
      });
    }
    if (dealViews > 5 && dealApplies / Math.max(dealViews, 1) < 0.2) {
      recommendations.push({
        id: "deal-headline",
        type: "deals",
        title: "Rewrite underperforming deal headline",
        explanation: "Deal views are not translating to applies. Try a clearer value statement and limited-time framing.",
        confidence: "medium",
        projectedImpact: "5\u20138% lift in deal applies",
        action: "update_deal_copy",
        applyAllowed: false,
        requiresApproval: true
      });
    }
    recommendations.push({
      id: "content-pool",
      type: "content",
      title: "Add pool/amenity imagery to seasonal pages",
      explanation: "Guests often respond to amenity visuals; adding a pool/amenity image to seasonal pages can increase engagement.",
      confidence: "low",
      projectedImpact: "Small uplift in detail views",
      action: "add_content",
      applyAllowed: false,
      requiresApproval: true
    });
    return { recommendations, windowDays: 7, stats: { addToStay, completes, abandons, imageViews, imageClicks, availabilityChecks, dealViews, dealApplies } };
  }
  async applyRecommendation(dto, actor, scope) {
    if (!dto.campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    if (MOCK_MODE) {
      this.logger.log(`[MOCK] applyRecommendation ${dto.recommendationId}`);
      return { status: "applied", recommendationId: dto.recommendationId, mock: true };
    }
    await this.audit.record({
      campgroundId: dto.campgroundId,
      actorId: actor.id ?? null,
      action: "recommendation.apply",
      entity: dto.type ?? "recommendation",
      entityId: dto.recommendationId,
      before: null,
      after: {
        targetId: dto.targetId ?? null,
        action: dto.action ?? null,
        payload: dto.payload ?? null
      },
      ip: null,
      userAgent: null
    });
    if (dto.action === "apply_pricing_adjustment") {
      const percentRaw = Number(dto.payload?.percentAdjust ?? -5);
      const percentAdjust = Math.max(-30, Math.min(30, Number.isFinite(percentRaw) ? percentRaw : -5));
      const startDate = dto.payload?.startDate ? new Date(dto.payload.startDate) : /* @__PURE__ */ new Date();
      const endDate = dto.payload?.endDate ? new Date(dto.payload.endDate) : void 0;
      const rule = await this.prisma.pricingRule.create({
        data: {
          campgroundId: dto.campgroundId,
          label: dto.payload?.label || "AI pricing adjust",
          ruleType: "percent",
          percentAdjust,
          siteClassId: dto.targetId || dto.payload?.siteClassId || null,
          startDate,
          endDate: endDate ?? null,
          isActive: true
        }
      });
      return { status: "applied", recommendationId: dto.recommendationId, pricingRuleId: rule.id };
    }
    if (dto.action === "reorder_images") {
      const order = Array.isArray(dto.payload?.imageOrder) ? dto.payload?.imageOrder : null;
      if (!order || order.length === 0) {
        throw new import_common187.BadRequestException("imageOrder payload is required");
      }
      const cg = await this.prisma.campground.findUnique({
        where: { id: dto.campgroundId },
        select: { id: true, photos: true, heroImageUrl: true }
      });
      if (!cg) throw new import_common187.BadRequestException("Campground not found");
      const existing = Array.isArray(cg.photos) ? cg.photos : [];
      const ordered = order.filter((p) => existing.includes(p));
      const remaining = existing.filter((p) => !ordered.includes(p));
      const photos = Array.from(/* @__PURE__ */ new Set([...ordered, ...remaining]));
      const updated = await this.prisma.campground.update({
        where: { id: dto.campgroundId },
        data: { photos }
      });
      await this.prisma.analyticsEvent.create({
        data: {
          sessionId: (0, import_crypto17.randomUUID)(),
          eventName: "admin_image_reorder",
          campground: { connect: { id: dto.campgroundId } },
          metadata: { reordered: order.length, total: photos.length }
        }
      });
      return { status: "applied", recommendationId: dto.recommendationId, photos: updated.photos };
    }
    return { status: "applied", recommendationId: dto.recommendationId };
  }
  async proposeRecommendation(dto, actor, scope) {
    if (!dto.campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    if (MOCK_MODE) {
      this.logger.log(`[MOCK] proposeRecommendation ${dto.recommendationId}`);
      return { status: "proposed", recommendationId: dto.recommendationId, mock: true };
    }
    await this.audit.record({
      campgroundId: dto.campgroundId,
      actorId: actor.id ?? null,
      action: "recommendation.propose",
      entity: dto.type ?? "recommendation",
      entityId: dto.recommendationId,
      before: null,
      after: {
        targetId: dto.targetId ?? null,
        payload: dto.payload ?? null
      },
      ip: null,
      userAgent: null
    });
    return { status: "proposed", recommendationId: dto.recommendationId };
  }
  async getFunnel(campgroundId, days = 30) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    const since = /* @__PURE__ */ new Date();
    since.setDate(since.getDate() - days);
    const aggregates = MOCK_MODE ? getMockAggregates(campgroundId, since) : await this.prisma.analyticsDailyAggregate.findMany({
      where: { campgroundId, date: { gte: since } }
    });
    const sum = (event) => aggregates.filter((a) => a.eventName === event).reduce((acc, cur) => acc + (cur.count || 0), 0);
    const views = sum(import_client35.AnalyticsEventName.page_view);
    const addToStay = sum(import_client35.AnalyticsEventName.add_to_stay);
    const starts = sum(import_client35.AnalyticsEventName.reservation_start);
    const abandoned = sum(import_client35.AnalyticsEventName.reservation_abandoned);
    const completed = sum(import_client35.AnalyticsEventName.reservation_completed);
    return {
      windowDays: days,
      steps: { views, addToStay, starts, abandoned, completed },
      conversionRate: views ? completed / views : 0,
      abandonmentRate: starts ? abandoned / starts : 0
    };
  }
  async getImagePerformance(campgroundId, days = 30) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    if (MOCK_MODE) {
      const since = /* @__PURE__ */ new Date();
      since.setDate(since.getDate() - days);
      const events = getMockEvents(campgroundId, since);
      const map = /* @__PURE__ */ new Map();
      for (const e of events) {
        if (!e.imageId) continue;
        const entry = map.get(e.imageId) ?? { views: 0, clicks: 0 };
        if (e.eventName === import_client35.AnalyticsEventName.image_viewed) entry.views += 1;
        if (e.eventName === import_client35.AnalyticsEventName.image_clicked) entry.clicks += 1;
        map.set(e.imageId, entry);
      }
      return Array.from(map.entries()).map(([imageId, stats]) => ({
        imageId,
        views: stats.views,
        clicks: stats.clicks,
        ctr: stats.views ? stats.clicks / stats.views : 0
      })).sort((a, b) => b.views - a.views).slice(0, 20);
    }
    const rows = await this.prisma.$queryRaw`
      SELECT "imageId" as "imageId",
             SUM(CASE WHEN "eventName" = 'image_viewed' THEN 1 ELSE 0 END)::bigint AS views,
             SUM(CASE WHEN "eventName" = 'image_clicked' THEN 1 ELSE 0 END)::bigint AS clicks
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "imageId" IS NOT NULL
        AND "occurredAt" >= NOW() - INTERVAL '${days} day'
      GROUP BY "imageId"
      ORDER BY views DESC
      LIMIT 20
    `;
    return rows.map((row) => ({
      imageId: row.imageId,
      views: Number(row.views),
      clicks: Number(row.clicks),
      ctr: Number(row.views) ? Number(row.clicks) / Number(row.views) : 0
    }));
  }
  async getDealPerformance(campgroundId, days = 30) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    if (MOCK_MODE) {
      const since = /* @__PURE__ */ new Date();
      since.setDate(since.getDate() - days);
      const events = getMockEvents(campgroundId, since);
      const map = /* @__PURE__ */ new Map();
      for (const e of events) {
        if (!e.promotionId) continue;
        const entry = map.get(e.promotionId) ?? { views: 0, applies: 0 };
        if (e.eventName === import_client35.AnalyticsEventName.deal_viewed) entry.views += 1;
        if (e.eventName === import_client35.AnalyticsEventName.deal_applied) entry.applies += 1;
        map.set(e.promotionId, entry);
      }
      return Array.from(map.entries()).map(([promotionId, stats]) => ({
        promotionId,
        views: stats.views,
        applies: stats.applies,
        applyRate: stats.views ? stats.applies / stats.views : 0
      })).sort((a, b) => b.views - a.views).slice(0, 20);
    }
    const rows = await this.prisma.$queryRaw`
      SELECT "promotionId",
             SUM(CASE WHEN "eventName" = 'deal_viewed' THEN 1 ELSE 0 END)::bigint AS views,
             SUM(CASE WHEN "eventName" = 'deal_applied' THEN 1 ELSE 0 END)::bigint AS applies
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "promotionId" IS NOT NULL
        AND "occurredAt" >= NOW() - INTERVAL '${days} day'
      GROUP BY "promotionId"
      ORDER BY views DESC
      LIMIT 20
    `;
    return rows.map((row) => ({
      promotionId: row.promotionId,
      views: Number(row.views),
      applies: Number(row.applies),
      applyRate: Number(row.views) ? Number(row.applies) / Number(row.views) : 0
    }));
  }
  async getAttribution(campgroundId, days = 30) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    if (MOCK_MODE) {
      const since = /* @__PURE__ */ new Date();
      since.setDate(since.getDate() - days);
      const events = getMockEvents(campgroundId, since);
      const map = /* @__PURE__ */ new Map();
      for (const e of events) {
        const ref = e.referrer ?? "direct";
        map.set(ref, (map.get(ref) ?? 0) + 1);
      }
      const total2 = Array.from(map.values()).reduce((acc, cur) => acc + cur, 0);
      return Array.from(map.entries()).map(([referrer, count]) => ({
        referrer: referrer === "direct" ? null : referrer,
        count,
        share: total2 ? count / total2 : 0
      }));
    }
    const rows = await this.prisma.$queryRaw`
      SELECT COALESCE("referrer", 'direct') as referrer, COUNT(*)::bigint as count
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "occurredAt" >= NOW() - INTERVAL '${days} day'
      GROUP BY COALESCE("referrer", 'direct')
      ORDER BY count DESC
    `;
    const total = rows.reduce((acc, r) => acc + Number(r.count), 0);
    return rows.map((row) => ({
      referrer: row.referrer,
      count: Number(row.count),
      share: total ? Number(row.count) / total : 0
    }));
  }
  async getPricingSignals(campgroundId, days = 30) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    const since = /* @__PURE__ */ new Date();
    since.setDate(since.getDate() - days);
    const aggregates = MOCK_MODE ? getMockAggregates(campgroundId, since) : await this.prisma.analyticsDailyAggregate.findMany({
      where: { campgroundId, date: { gte: since } }
    });
    const sum = (event) => aggregates.filter((a) => a.eventName === event).reduce((acc, cur) => acc + (cur.count || 0), 0);
    const availabilityChecks = sum(import_client35.AnalyticsEventName.availability_check);
    const addToStay = sum(import_client35.AnalyticsEventName.add_to_stay);
    const completes = sum(import_client35.AnalyticsEventName.reservation_completed);
    return {
      windowDays: days,
      availabilityChecks,
      addToStay,
      completes,
      conversionFromAvailability: availabilityChecks ? completes / availabilityChecks : 0,
      conversionFromAddToStay: addToStay ? completes / addToStay : 0
    };
  }
  async getAnnualReport(campgroundId, year, format) {
    if (!campgroundId) throw new import_common187.BadRequestException("campgroundId is required");
    const targetYear = year ?? (/* @__PURE__ */ new Date()).getFullYear();
    const start = new Date(Date.UTC(targetYear, 0, 1));
    const end = new Date(Date.UTC(targetYear + 1, 0, 1));
    if (MOCK_MODE) {
      const events = mockStore.events.filter(
        (e) => (e.campgroundId ?? "mock") === (campgroundId ?? "mock") && e.occurredAt >= start && e.occurredAt < end
      );
      const byEvent = /* @__PURE__ */ new Map();
      const dealMap = /* @__PURE__ */ new Map();
      const imgMap = /* @__PURE__ */ new Map();
      for (const e of events) {
        byEvent.set(e.eventName, (byEvent.get(e.eventName) ?? 0) + 1);
        if (e.promotionId) {
          const entry = dealMap.get(e.promotionId) ?? { views: 0, applies: 0 };
          if (e.eventName === import_client35.AnalyticsEventName.deal_viewed) entry.views += 1;
          if (e.eventName === import_client35.AnalyticsEventName.deal_applied) entry.applies += 1;
          dealMap.set(e.promotionId, entry);
        }
        if (e.imageId) {
          const entry = imgMap.get(e.imageId) ?? { views: 0, clicks: 0 };
          if (e.eventName === import_client35.AnalyticsEventName.image_viewed) entry.views += 1;
          if (e.eventName === import_client35.AnalyticsEventName.image_clicked) entry.clicks += 1;
          imgMap.set(e.imageId, entry);
        }
      }
      const summary2 = {
        year: targetYear,
        range: { start, end },
        events: Array.from(byEvent.entries()).map(([eventName, count]) => ({ eventName, count })),
        deals: Array.from(dealMap.entries()).map(([promotionId, stats]) => ({
          promotionId,
          views: stats.views,
          applies: stats.applies
        })),
        images: Array.from(imgMap.entries()).map(([imageId, stats]) => ({
          imageId,
          views: stats.views,
          clicks: stats.clicks
        }))
      };
      if (format === "csv") {
        const lines = [
          ["section", "key", "metric", "value"],
          ...summary2.events.map((e) => ["events", e.eventName, "count", String(e.count)]),
          ...summary2.deals.map((d) => ["deal", d.promotionId, "views", String(d.views)]),
          ...summary2.deals.map((d) => ["deal", d.promotionId, "applies", String(d.applies)]),
          ...summary2.images.map((i) => ["image", i.imageId, "views", String(i.views)]),
          ...summary2.images.map((i) => ["image", i.imageId, "clicks", String(i.clicks)])
        ];
        const csv = lines.map((l) => l.join(",")).join("\n");
        return { year: targetYear, csv };
      }
      return summary2;
    }
    const eventCounts = await this.prisma.$queryRaw`
      SELECT "eventName", COUNT(*)::bigint AS count
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "occurredAt" >= ${start}
        AND "occurredAt" < ${end}
      GROUP BY "eventName"
    `;
    const deals = await this.prisma.$queryRaw`
      SELECT "promotionId",
             SUM(CASE WHEN "eventName" = 'deal_viewed' THEN 1 ELSE 0 END)::bigint AS views,
             SUM(CASE WHEN "eventName" = 'deal_applied' THEN 1 ELSE 0 END)::bigint AS applies
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "promotionId" IS NOT NULL
        AND "occurredAt" >= ${start}
        AND "occurredAt" < ${end}
      GROUP BY "promotionId"
    `;
    const images = await this.prisma.$queryRaw`
      SELECT "imageId",
             SUM(CASE WHEN "eventName" = 'image_viewed' THEN 1 ELSE 0 END)::bigint AS views,
             SUM(CASE WHEN "eventName" = 'image_clicked' THEN 1 ELSE 0 END)::bigint AS clicks
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${campgroundId}
        AND "imageId" IS NOT NULL
        AND "occurredAt" >= ${start}
        AND "occurredAt" < ${end}
      GROUP BY "imageId"
    `;
    const summary = {
      year: targetYear,
      range: { start, end },
      events: eventCounts.map((row) => ({ eventName: row.eventName, count: Number(row.count) })),
      deals: deals.map((row) => ({ promotionId: row.promotionId, views: Number(row.views), applies: Number(row.applies) })),
      images: images.map((row) => ({ imageId: row.imageId, views: Number(row.views), clicks: Number(row.clicks) }))
    };
    if (format === "csv") {
      const lines = [
        ["section", "key", "metric", "value"],
        ...summary.events.map((e) => ["events", e.eventName, "count", String(e.count)]),
        ...summary.deals.map((d) => ["deal", d.promotionId, "views", String(d.views)]),
        ...summary.deals.map((d) => ["deal", d.promotionId, "applies", String(d.applies)]),
        ...summary.images.map((i) => ["image", i.imageId, "views", String(i.views)]),
        ...summary.images.map((i) => ["image", i.imageId, "clicks", String(i.clicks)])
      ];
      const csv = lines.map((l) => l.join(",")).join("\n");
      return { year: targetYear, csv };
    }
    return summary;
  }
};
__decorateClass([
  (0, import_schedule12.Cron)(import_schedule12.CronExpression.EVERY_HOUR)
], AnalyticsService.prototype, "refreshDailyAggregates", 1);
__decorateClass([
  (0, import_schedule12.Cron)(import_schedule12.CronExpression.EVERY_DAY_AT_2AM)
], AnalyticsService.prototype, "enforceRetention", 1);
AnalyticsService = __decorateClass([
  (0, import_common187.Injectable)()
], AnalyticsService);

// src/analytics/analytics.controller.ts
var import_common188 = require("@nestjs/common");
var import_client36 = require("@prisma/client");
var AnalyticsController = class {
  constructor(analyticsService) {
    this.analyticsService = analyticsService;
  }
  async ingestEvent(dto, req) {
    const scope = {
      campgroundId: req?.campgroundId || null,
      organizationId: req?.organizationId || null,
      userId: req?.user?.id || null
    };
    return this.analyticsService.ingest(dto, scope);
  }
  async listRecommendations(campgroundId, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getRecommendations(cgId);
  }
  async applyRecommendation(dto, req) {
    const user = req.user;
    if (!user) throw new Error("Unauthorized");
    const campId = dto.campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    if (!campId) throw new Error("campgroundId required");
    return this.analyticsService.applyRecommendation(dto, req?.user, {
      campgroundId: campId,
      organizationId: req?.organizationId || null,
      userId: req?.user?.id || null
    });
  }
  async proposeRecommendation(dto, req) {
    return this.analyticsService.proposeRecommendation(dto, req?.user, {
      campgroundId: req?.campgroundId || null,
      organizationId: req?.organizationId || null,
      userId: req?.user?.id || null
    });
  }
  async getFunnel(campgroundId, days, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getFunnel(cgId, days ? parseInt(days, 10) : 30);
  }
  async getImagePerformance(campgroundId, days, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getImagePerformance(cgId, days ? parseInt(days, 10) : 30);
  }
  async getDealPerformance(campgroundId, days, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getDealPerformance(cgId, days ? parseInt(days, 10) : 30);
  }
  async getAttribution(campgroundId, days, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getAttribution(cgId, days ? parseInt(days, 10) : 30);
  }
  async getPricingSignals(campgroundId, days, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    return this.analyticsService.getPricingSignals(cgId, days ? parseInt(days, 10) : 30);
  }
  async getAnnualReport(campgroundId, year, format, req) {
    const cgId = campgroundId || req?.campgroundId || req.headers["x-campground-id"];
    const yr = year ? parseInt(year, 10) : void 0;
    return this.analyticsService.getAnnualReport(cgId, yr, format);
  }
};
__decorateClass([
  (0, import_common188.Post)("events"),
  __decorateParam(0, (0, import_common188.Body)()),
  __decorateParam(1, (0, import_common188.Req)())
], AnalyticsController.prototype, "ingestEvent", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("recommendations"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Req)())
], AnalyticsController.prototype, "listRecommendations", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client36.UserRole.owner, import_client36.UserRole.manager),
  (0, import_common188.Post)("recommendations/apply"),
  __decorateParam(0, (0, import_common188.Body)()),
  __decorateParam(1, (0, import_common188.Req)())
], AnalyticsController.prototype, "applyRecommendation", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client36.UserRole.owner, import_client36.UserRole.manager, import_client36.UserRole.marketing, import_client36.UserRole.front_desk),
  (0, import_common188.Post)("recommendations/propose"),
  __decorateParam(0, (0, import_common188.Body)()),
  __decorateParam(1, (0, import_common188.Req)())
], AnalyticsController.prototype, "proposeRecommendation", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/funnel"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("days")),
  __decorateParam(2, (0, import_common188.Req)())
], AnalyticsController.prototype, "getFunnel", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/images"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("days")),
  __decorateParam(2, (0, import_common188.Req)())
], AnalyticsController.prototype, "getImagePerformance", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/deals"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("days")),
  __decorateParam(2, (0, import_common188.Req)())
], AnalyticsController.prototype, "getDealPerformance", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/attribution"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("days")),
  __decorateParam(2, (0, import_common188.Req)())
], AnalyticsController.prototype, "getAttribution", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/pricing"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("days")),
  __decorateParam(2, (0, import_common188.Req)())
], AnalyticsController.prototype, "getPricingSignals", 1);
__decorateClass([
  (0, import_common188.UseGuards)(JwtAuthGuard),
  (0, import_common188.Get)("reports/annual"),
  __decorateParam(0, (0, import_common188.Query)("campgroundId")),
  __decorateParam(1, (0, import_common188.Query)("year")),
  __decorateParam(2, (0, import_common188.Query)("format")),
  __decorateParam(3, (0, import_common188.Req)())
], AnalyticsController.prototype, "getAnnualReport", 1);
AnalyticsController = __decorateClass([
  (0, import_common188.Controller)("analytics")
], AnalyticsController);

// src/analytics/analytics.module.ts
var AnalyticsModule = class {
};
AnalyticsModule = __decorateClass([
  (0, import_common189.Module)({
    providers: [PrismaService, AnalyticsService, AuditService],
    controllers: [AnalyticsController],
    exports: [AnalyticsService]
  })
], AnalyticsModule);

// src/ai/ai.module.ts
var import_common192 = require("@nestjs/common");

// src/ai/ai.service.ts
var import_common190 = require("@nestjs/common");
var import_client37 = require("@prisma/client");
var import_node_fetch4 = __toESM(require("node-fetch"));
var AiService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.logger = new import_common190.Logger(AiService.name);
  }
  async shouldUseMock(campgroundId, forceMock) {
    if (forceMock) return true;
    if (!campgroundId) return true;
    const cg = await this.prisma.campground.findUnique({
      where: { id: campgroundId },
      select: { aiSuggestionsEnabled: true, aiOpenaiApiKey: true }
    });
    if (!cg) return true;
    if (!cg.aiSuggestionsEnabled) return true;
    if (!cg.aiOpenaiApiKey) return true;
    return false;
  }
  async updateSettings(campgroundId, dto) {
    const cg = await this.prisma.campground.findUnique({ where: { id: campgroundId } });
    if (!cg) throw new import_common190.BadRequestException("Campground not found");
    await this.prisma.campground.update({
      where: { id: campgroundId },
      data: {
        aiSuggestionsEnabled: dto.enabled,
        aiOpenaiApiKey: dto.openaiApiKey ?? cg.aiOpenaiApiKey
      }
    });
    return { ok: true, enabled: dto.enabled, hasKey: !!(dto.openaiApiKey ?? cg.aiOpenaiApiKey) };
  }
  async generate(dto) {
    const cg = await this.prisma.campground.findUnique({
      where: { id: dto.campgroundId },
      select: { id: true, name: true, aiSuggestionsEnabled: true, aiOpenaiApiKey: true }
    });
    if (!cg) throw new import_common190.BadRequestException("Campground not found");
    if (!cg.aiSuggestionsEnabled || !cg.aiOpenaiApiKey) {
      throw new import_common190.ForbiddenException("AI suggestions not enabled for this campground");
    }
    const cgId = cg.id;
    const last90 = await this.getEventCounts(cgId, 90);
    const last365 = await this.getEventCounts(cgId, 365);
    const cabins90 = await this.getCabinRollup(cgId, 90);
    const cabins365 = await this.getCabinRollup(cgId, 365);
    const cabins3y = await this.getCabinRollup(cgId, 365 * 3);
    const attribution = await this.prisma.$queryRaw`
      SELECT COALESCE("referrer", 'direct') as referrer, COUNT(*)::bigint as count
      FROM "AnalyticsEvent"
      WHERE "campgroundId" = ${cgId} AND "occurredAt" >= NOW() - INTERVAL '365 day'
      GROUP BY COALESCE("referrer", 'direct')
      ORDER BY count DESC
    `;
    const prompt = `
You are an RV campground revenue and operations assistant.
Return concise, actionable suggestions. DO NOT include any personal guest info. Use aggregates only.
If data is sparse, say so and suggest quick wins. Output 5-8 bullet recommendations.

Campground: ${cg.name}
Focus: ${dto.focus || "overall performance"}

Metrics (last 90d):
- Views: ${last90.page_view}
- Availability checks: ${last90.availability_check}
- Add-to-stay: ${last90.add_to_stay}
- Reservation starts: ${last90.reservation_start}
- Abandoned: ${last90.reservation_abandoned}
- Completed: ${last90.reservation_completed}
- Image views: ${last90.image_viewed}, clicks: ${last90.image_clicked}
- Deal views: ${last90.deal_viewed}, applies: ${last90.deal_applied}
Metrics (last 365d):
- Views: ${last365.page_view}
- Availability checks: ${last365.availability_check}
- Add-to-stay: ${last365.add_to_stay}
- Reservation starts: ${last365.reservation_start}
- Abandoned: ${last365.reservation_abandoned}
- Completed: ${last365.reservation_completed}
- Image views: ${last365.image_viewed}, clicks: ${last365.image_clicked}
- Deal views: ${last365.deal_viewed}, applies: ${last365.deal_applied}
- Referrers (365d): ${attribution.map((r) => `${r.referrer}:${Number(r.count)}`).join(", ")}

Cabins performance (stays/revenue/ADR):
- Last 90d: bookings ${cabins90.bookings}, revenue $${(cabins90.revenueCents / 100).toFixed(0)}, ADR $${cabins90.adr.toFixed(0)}
- Last 365d: bookings ${cabins365.bookings}, revenue $${(cabins365.revenueCents / 100).toFixed(0)}, ADR $${cabins365.adr.toFixed(0)}
- Last 3y: bookings ${cabins3y.bookings}, revenue $${(cabins3y.revenueCents / 100).toFixed(0)}, ADR $${cabins3y.adr.toFixed(0)}

Guidelines:
- Start with a short numeric \u201CWhat we see\u201D summary citing the counts above.
- Then give 4-6 specific actions with expected impact. No navigation/how-to; focus on what to change.
- If data is thin, say \u201CData is thin; suggest lightweight tests.\u201D
- Respect privacy; never request PII.
    `;
    const body = {
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: "You produce concise, high-signal recommendations for campground operators. No PII. Be specific with actions and expected impact." },
        { role: "user", content: prompt }
      ],
      temperature: 0.4,
      max_tokens: 600
    };
    const res = await (0, import_node_fetch4.default)("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${cg.aiOpenaiApiKey}`
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const text = await res.text();
      this.logger.error(`OpenAI error ${res.status}: ${text}`);
      throw new import_common190.BadRequestException("AI suggestion request failed");
    }
    const json = await res.json();
    const content = json?.choices?.[0]?.message?.content || "";
    const usage = json?.usage || {};
    return {
      suggestions: content,
      windowDays: 365,
      usage: {
        promptTokens: usage.prompt_tokens ?? null,
        completionTokens: usage.completion_tokens ?? null,
        totalTokens: usage.total_tokens ?? null
      }
    };
  }
  async ask(dto) {
    const cg = await this.prisma.campground.findUnique({
      where: { id: dto.campgroundId },
      select: { id: true, name: true, aiSuggestionsEnabled: true, aiOpenaiApiKey: true }
    });
    if (!cg) throw new import_common190.BadRequestException("Campground not found");
    if (!cg.aiSuggestionsEnabled || !cg.aiOpenaiApiKey) {
      throw new import_common190.ForbiddenException("AI not enabled for this campground");
    }
    const cgId = cg.id;
    const scrubbedQuestion = dto.question.replace(/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "[phone]").replace(/\b\S+@\S+\.\S+\b/g, "[email]");
    const metrics90 = await this.getEventCounts(cgId, 90);
    const metrics365 = await this.getEventCounts(cgId, 365);
    const prompt = `
You are a campground admin helper for ${cg.name}. Provide concise, data-backed guidance. No PII. If unsure, say so briefly.
User question: "${scrubbedQuestion}"

Analytics (last 90d):
- Views: ${metrics90.page_view}, Add-to-stay: ${metrics90.add_to_stay}, Starts: ${metrics90.reservation_start}, Abandoned: ${metrics90.reservation_abandoned}, Completed: ${metrics90.reservation_completed}
- Availability checks: ${metrics90.availability_check}, Deals views/applies: ${metrics90.deal_viewed}/${metrics90.deal_applied}
- Images views/clicks: ${metrics90.image_viewed}/${metrics90.image_clicked}

Analytics (last 365d):
- Views: ${metrics365.page_view}, Add-to-stay: ${metrics365.add_to_stay}, Starts: ${metrics365.reservation_start}, Abandoned: ${metrics365.reservation_abandoned}, Completed: ${metrics365.reservation_completed}
- Availability checks: ${metrics365.availability_check}, Deals views/applies: ${metrics365.deal_viewed}/${metrics365.deal_applied}
- Images views/clicks: ${metrics365.image_viewed}/${metrics365.image_clicked}

Return:
- Short numeric summary (2-3 sentences) citing the metrics above.
- 3-5 specific actions with expected impact; no navigation/how-to instructions.
- If data is thin, say \u201CData is thin; suggest lightweight tests.\u201D
`;
    const body = {
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: "You assist campground staff with concise answers and next steps. No guest PII. Be specific, short, and actionable." },
        { role: "user", content: prompt }
      ],
      temperature: 0.3,
      max_tokens: 500
    };
    const res = await (0, import_node_fetch4.default)("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${cg.aiOpenaiApiKey}`
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const text = await res.text();
      this.logger.error(`OpenAI ask error ${res.status}: ${text}`);
      throw new import_common190.BadRequestException("AI ask request failed");
    }
    const json = await res.json();
    const content = json?.choices?.[0]?.message?.content || "";
    const usage = json?.usage || {};
    return {
      answer: content,
      usage: {
        promptTokens: usage.prompt_tokens ?? null,
        completionTokens: usage.completion_tokens ?? null,
        totalTokens: usage.total_tokens ?? null
      }
    };
  }
  async recommend(dto, forceMock = false) {
    const useMock = await this.shouldUseMock(dto.campgroundId, forceMock);
    const intent = dto.intent?.trim() || "boost conversions";
    const items = [
      {
        type: "site",
        title: "Riverside pull-through",
        reason: `Matches intent "${intent}" with full hookups and shade; near bathhouse.`,
        cta: "Hold Site 12",
        targetId: "site-12"
      },
      {
        type: "upsell",
        title: "Late checkout + firewood bundle",
        reason: "Common mid-stay ask; bundle yields +$18 margin with zero ops lift.",
        cta: "Add bundle",
        targetId: "bundle-late-firewood"
      },
      {
        type: "message",
        title: "Pre-arrival text",
        reason: "Send arrival tips + wifi + gate code; reduces desk calls by ~18%.",
        cta: "Send template",
        targetId: "template-arrival"
      }
    ];
    return {
      campgroundId: dto.campgroundId,
      guestId: dto.guestId ?? null,
      intent,
      items,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      mode: useMock ? "mock" : "live"
    };
  }
  async pricingSuggest(dto, forceMock = false) {
    const useMock = await this.shouldUseMock(dto.campgroundId, forceMock);
    const demandIndex = dto.demandIndex ?? 0.78;
    const baseRateCents = 12e3;
    const upliftPercent = Math.round(demandIndex * 20);
    const suggestedRateCents = Math.round(baseRateCents * (1 + upliftPercent / 100));
    return {
      campgroundId: dto.campgroundId,
      siteClassId: dto.siteClassId ?? null,
      window: { arrivalDate: dto.arrivalDate ?? null, departureDate: dto.departureDate ?? null },
      baseRateCents,
      suggestedRateCents,
      currency: "USD",
      demandIndex,
      factors: [
        { label: "Occupancy (next 14d)", value: "82%", weight: 0.4 },
        { label: "Pickup last 7d vs prior", value: "+11%", weight: 0.25 },
        { label: "Local events", value: "County fair next weekend", weight: 0.2 },
        { label: "Rules", value: "Weekend +10%, 2-night min", weight: 0.15 }
      ],
      comparableSites: [
        { name: "Premium RV", rateCents: suggestedRateCents + 1500, distanceMiles: 0.4 },
        { name: "Standard RV", rateCents: suggestedRateCents - 1800, distanceMiles: 0.2 }
      ],
      notes: "Stubbed suggestion based on demand, comps, and rules; safe to demo without external keys.",
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      mode: useMock ? "mock" : "live"
    };
  }
  async semanticSearch(dto, forceMock = false) {
    const useMock = await this.shouldUseMock(dto.campgroundId, forceMock);
    const query = dto.query.trim();
    const results = [
      {
        type: "guest",
        id: "guest-alice",
        title: "Alice Johnson",
        snippet: "Prefers shaded pull-through, traveling with 32ft fifth wheel; VIP tier.",
        score: 0.92
      },
      {
        type: "site",
        id: "site-12",
        title: "Riverside pull-through",
        snippet: "Full hookups, near dog park, fits 40ft rigs; great for late checkouts.",
        score: 0.88
      },
      {
        type: "message",
        id: "msg-482",
        title: "Thread: late checkout request",
        snippet: "Guest asked for late checkout due to event; offered $15 add-on.",
        score: 0.83
      }
    ].filter((r) => r.score > 0.1 && query.length > 0);
    return {
      campgroundId: dto.campgroundId ?? null,
      query,
      results,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      mode: useMock ? "mock" : "live"
    };
  }
  async copilot(dto, forceMock = false) {
    const useMock = await this.shouldUseMock(dto.campgroundId, forceMock);
    const action = dto.action.toLowerCase();
    if (action === "adjust_rates") {
      return {
        action,
        preview: "Apply +8% weekend uplift for premium RV sites; keep weekdays flat.",
        steps: ["Preview affected stays", "Notify front desk of rate changes", "Publish to booking channels"],
        impact: "Est. +$420 next 14 days with minimal cannibalization.",
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        mode: useMock ? "mock" : "live"
      };
    }
    if (action === "draft_reply") {
      return {
        action,
        preview: "Thanks for reaching out! We can extend your stay to Monday and add late checkout for $15. Want me to hold Site 12?",
        tone: "friendly",
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        mode: useMock ? "mock" : "live"
      };
    }
    return {
      action,
      preview: "What-if: add 10% rate during county fair and auto-apply late checkout bundle to Saturday departures.",
      steps: ["Simulate ADR/occupancy impact", "Stage pricing rule", "Confirm to apply"],
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      mode: useMock ? "mock" : "live"
    };
  }
  async getEventCounts(campgroundId, days) {
    const counts = await this.prisma.analyticsDailyAggregate.groupBy({
      by: ["eventName"],
      where: { campgroundId, date: { gte: new Date(Date.now() - days * 24 * 60 * 60 * 1e3) } },
      _sum: { count: true }
    });
    const pick = (event) => {
      const found = counts.find((c) => c.eventName === event);
      return found && found._sum && typeof found._sum.count === "number" ? found._sum.count : 0;
    };
    return {
      page_view: pick(import_client37.AnalyticsEventName.page_view),
      availability_check: pick(import_client37.AnalyticsEventName.availability_check),
      add_to_stay: pick(import_client37.AnalyticsEventName.add_to_stay),
      reservation_start: pick(import_client37.AnalyticsEventName.reservation_start),
      reservation_abandoned: pick(import_client37.AnalyticsEventName.reservation_abandoned),
      reservation_completed: pick(import_client37.AnalyticsEventName.reservation_completed),
      image_viewed: pick(import_client37.AnalyticsEventName.image_viewed),
      image_clicked: pick(import_client37.AnalyticsEventName.image_clicked),
      deal_viewed: pick(import_client37.AnalyticsEventName.deal_viewed),
      deal_applied: pick(import_client37.AnalyticsEventName.deal_applied)
    };
  }
  async getCabinRollup(campgroundId, days) {
    const rows = await this.prisma.$queryRaw`
      SELECT
        COUNT(*)::bigint AS bookings,
        COALESCE(SUM(r."totalAmount"), 0)::bigint AS revenue,
        COALESCE(SUM(EXTRACT(epoch FROM (r."departureDate" - r."arrivalDate")) / 86400), 0) AS nights
      FROM "Reservation" r
      JOIN "Site" s ON s.id = r."siteId"
      WHERE r."campgroundId" = ${campgroundId}
        AND s."siteType" = 'cabin'
        AND r."status" = 'confirmed'
        AND r."arrivalDate" >= NOW() - (${days} || ' day')::interval
    `;
    const row = rows[0] || { bookings: 0n, revenue: 0n, nights: 0 };
    const bookings = Number(row.bookings);
    const revenueCents = Number(row.revenue);
    const nights = row.nights || 0;
    const adr = nights > 0 ? revenueCents / nights / 100 : 0;
    return { bookings, revenueCents, adr };
  }
};
AiService = __decorateClass([
  (0, import_common190.Injectable)()
], AiService);

// src/ai/ai.controller.ts
var import_common191 = require("@nestjs/common");
var import_client38 = require("@prisma/client");
var AiController = class {
  constructor(ai) {
    this.ai = ai;
  }
  async updateSettings(dto) {
    return this.ai.updateSettings(dto.campgroundId, dto);
  }
  async generate(dto) {
    return this.ai.generate(dto);
  }
  async ask(dto) {
    return this.ai.ask(dto);
  }
  async recommendations(dto, mock) {
    return this.ai.recommend(dto, mock === "true" || mock === "1");
  }
  async pricing(dto, mock) {
    return this.ai.pricingSuggest(dto, mock === "true" || mock === "1");
  }
  async semanticSearch(dto, mock) {
    return this.ai.semanticSearch(dto, mock === "true" || mock === "1");
  }
  async copilot(dto, mock) {
    return this.ai.copilot(dto, mock === "true" || mock === "1");
  }
};
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager),
  (0, import_common191.Post)("settings"),
  __decorateParam(0, (0, import_common191.Body)())
], AiController.prototype, "updateSettings", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.marketing),
  (0, import_common191.Post)("suggestions"),
  __decorateParam(0, (0, import_common191.Body)())
], AiController.prototype, "generate", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.marketing, import_client38.UserRole.front_desk, import_client38.UserRole.finance),
  (0, import_common191.Post)("ask"),
  __decorateParam(0, (0, import_common191.Body)())
], AiController.prototype, "ask", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.marketing, import_client38.UserRole.front_desk, import_client38.UserRole.finance),
  (0, import_common191.Post)("recommendations"),
  __decorateParam(0, (0, import_common191.Body)()),
  __decorateParam(1, (0, import_common191.Query)("mock"))
], AiController.prototype, "recommendations", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.finance),
  (0, import_common191.Post)("pricing-suggestions"),
  __decorateParam(0, (0, import_common191.Body)()),
  __decorateParam(1, (0, import_common191.Query)("mock"))
], AiController.prototype, "pricing", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.front_desk, import_client38.UserRole.marketing),
  (0, import_common191.Post)("semantic-search"),
  __decorateParam(0, (0, import_common191.Body)()),
  __decorateParam(1, (0, import_common191.Query)("mock"))
], AiController.prototype, "semanticSearch", 1);
__decorateClass([
  Roles(import_client38.UserRole.owner, import_client38.UserRole.manager, import_client38.UserRole.front_desk, import_client38.UserRole.finance, import_client38.UserRole.marketing),
  (0, import_common191.Post)("copilot"),
  __decorateParam(0, (0, import_common191.Body)()),
  __decorateParam(1, (0, import_common191.Query)("mock"))
], AiController.prototype, "copilot", 1);
AiController = __decorateClass([
  (0, import_common191.Controller)("ai"),
  (0, import_common191.UseGuards)(JwtAuthGuard, RolesGuard)
], AiController);

// src/ai/ai.module.ts
var AiModule = class {
};
AiModule = __decorateClass([
  (0, import_common192.Module)({
    providers: [PrismaService, AiService],
    controllers: [AiController]
  })
], AiModule);

// src/push-subscriptions/push-subscriptions.module.ts
var import_common195 = require("@nestjs/common");

// src/push-subscriptions/push-subscriptions.service.ts
var import_common193 = require("@nestjs/common");
var PushSubscriptionsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async upsertSubscription({ subscription, userId, campgroundId, userAgent }) {
    const endpoint = subscription?.endpoint;
    if (!endpoint) {
      throw new import_common193.BadRequestException("subscription.endpoint is required");
    }
    const expirationTime = subscription?.expirationTime ? new Date(subscription.expirationTime) : null;
    return this.prisma.pushSubscription.upsert({
      where: { endpoint },
      update: {
        subscription,
        keys: subscription?.keys ?? null,
        expirationTime: expirationTime ?? void 0,
        userId: userId ?? null,
        campgroundId: campgroundId ?? null,
        userAgent: userAgent ?? null
      },
      create: {
        endpoint,
        subscription,
        keys: subscription?.keys ?? null,
        expirationTime: expirationTime ?? void 0,
        userId: userId ?? null,
        campgroundId: campgroundId ?? null,
        userAgent: userAgent ?? null
      }
    });
  }
};
PushSubscriptionsService = __decorateClass([
  (0, import_common193.Injectable)()
], PushSubscriptionsService);

// src/push-subscriptions/push-subscriptions.controller.ts
var import_common194 = require("@nestjs/common");
var PushSubscriptionsController = class {
  constructor(pushSubscriptions) {
    this.pushSubscriptions = pushSubscriptions;
  }
  async subscribe(body, req) {
    const subscription = body.subscription ?? body;
    const campgroundId = body.campgroundId;
    return this.pushSubscriptions.upsertSubscription({
      subscription,
      campgroundId,
      userId: req.user?.userId,
      userAgent: req.headers["user-agent"] ?? null
    });
  }
};
__decorateClass([
  (0, import_common194.Post)("subscribe"),
  __decorateParam(0, (0, import_common194.Body)()),
  __decorateParam(1, (0, import_common194.Req)())
], PushSubscriptionsController.prototype, "subscribe", 1);
PushSubscriptionsController = __decorateClass([
  (0, import_common194.UseGuards)(JwtAuthGuard),
  (0, import_common194.Controller)("push")
], PushSubscriptionsController);

// src/push-subscriptions/push-subscriptions.module.ts
var PushSubscriptionsModule = class {
};
PushSubscriptionsModule = __decorateClass([
  (0, import_common195.Module)({
    imports: [AuthModule],
    controllers: [PushSubscriptionsController],
    providers: [PushSubscriptionsService, PrismaService]
  })
], PushSubscriptionsModule);

// src/perf/perf.module.ts
var import_common199 = require("@nestjs/common");

// src/perf/perf.controller.ts
var import_common196 = require("@nestjs/common");
var PerfController = class {
  constructor(perfService) {
    this.perfService = perfService;
  }
  getSnapshot() {
    return this.perfService.getSnapshot();
  }
};
__decorateClass([
  (0, import_common196.Get)()
], PerfController.prototype, "getSnapshot", 1);
PerfController = __decorateClass([
  (0, import_common196.Controller)("ops/perf")
], PerfController);

// src/perf/perf.service.ts
var import_common197 = require("@nestjs/common");
var PerfService = class {
  constructor() {
    this.samples = [];
    this.limiterEvents = [];
    this.windowMs = Number(process.env.PERF_WINDOW_MS ?? 3e5);
    // 5 minutes default
    this.maxSamples = 500;
  }
  recordSample(sample) {
    const entry = { ts: sample.ts ?? Date.now(), ...sample };
    this.samples.push(entry);
    if (this.samples.length > this.maxSamples) {
      this.samples.splice(0, this.samples.length - this.maxSamples);
    }
    this.prune(entry.ts);
  }
  recordLimiterHit(type, ts = Date.now()) {
    this.limiterEvents.push({ ts, type });
    this.prune(ts);
  }
  getSnapshot() {
    const now = Date.now();
    this.prune(now);
    const windowStart = now - this.windowMs;
    const windowSamples = this.samples.filter((s) => s.ts >= windowStart);
    const durations = windowSamples.map((s) => s.durationMs).sort((a, b) => a - b);
    const total = windowSamples.length;
    const errors = windowSamples.filter((s) => s.statusCode >= 500).length;
    const limiterWindow = this.limiterEvents.filter((e) => e.ts >= windowStart);
    const limiter = {
      ip: limiterWindow.filter((e) => e.type === "ip").length,
      org: limiterWindow.filter((e) => e.type === "org").length
    };
    return {
      timestamp: new Date(now).toISOString(),
      windowMs: this.windowMs,
      counts: { total, errors },
      latencyMs: {
        p50: this.percentile(durations, 0.5),
        p95: this.percentile(durations, 0.95),
        p99: this.percentile(durations, 0.99)
      },
      errorRate: total === 0 ? 0 : errors / total,
      limiter
    };
  }
  percentile(values, percentile) {
    if (values.length === 0) return null;
    if (values.length === 1) return values[0];
    const index = Math.min(
      values.length - 1,
      Math.floor((values.length - 1) * percentile)
    );
    return values[index];
  }
  prune(now) {
    const cutoff = now - this.windowMs;
    this.samples = this.samples.filter((s) => s.ts >= cutoff);
    this.limiterEvents = this.limiterEvents.filter((e) => e.ts >= cutoff);
  }
};
PerfService = __decorateClass([
  (0, import_common197.Injectable)()
], PerfService);

// src/perf/rate-limit.service.ts
var import_common198 = require("@nestjs/common");
var RateLimitService = class {
  constructor() {
    this.windowMs = Number(process.env.PERF_RATE_LIMIT_WINDOW_MS ?? 6e4);
    this.ipLimit = Number(process.env.PERF_RATE_LIMIT_IP ?? 120);
    this.orgLimit = Number(process.env.PERF_RATE_LIMIT_ORG ?? 240);
    this.ipHits = /* @__PURE__ */ new Map();
    this.orgHits = /* @__PURE__ */ new Map();
  }
  shouldAllow(ip, orgId) {
    const now = Date.now();
    if (ip) this.prune(ip, this.ipHits, now);
    if (orgId) this.prune(orgId, this.orgHits, now);
    if (ip && this.count(ip, this.ipHits) >= this.ipLimit) {
      return { allowed: false, reason: "ip" };
    }
    if (orgId && this.count(orgId, this.orgHits) >= this.orgLimit) {
      return { allowed: false, reason: "org" };
    }
    if (ip) this.push(ip, this.ipHits, now);
    if (orgId) this.push(orgId, this.orgHits, now);
    return { allowed: true };
  }
  prune(key, bucket, now) {
    const cutoff = now - this.windowMs;
    const arr = bucket.get(key);
    if (!arr) return;
    const filtered = arr.filter((ts) => ts >= cutoff);
    if (filtered.length === 0) {
      bucket.delete(key);
    } else {
      bucket.set(key, filtered);
    }
  }
  count(key, bucket) {
    return bucket.get(key)?.length ?? 0;
  }
  push(key, bucket, ts) {
    const arr = bucket.get(key) ?? [];
    arr.push(ts);
    bucket.set(key, arr);
  }
};
RateLimitService = __decorateClass([
  (0, import_common198.Injectable)()
], RateLimitService);

// src/perf/perf.module.ts
var PerfModule = class {
};
PerfModule = __decorateClass([
  (0, import_common199.Module)({
    controllers: [PerfController],
    providers: [PerfService, RateLimitService],
    exports: [PerfService, RateLimitService]
  })
], PerfModule);

// src/integrations/integrations.module.ts
var import_common202 = require("@nestjs/common");

// src/integrations/integrations.controller.ts
var import_common200 = require("@nestjs/common");
var import_client39 = require("@prisma/client");
var IntegrationsController = class {
  constructor(integrations) {
    this.integrations = integrations;
  }
  upsertConnection(body) {
    return this.integrations.upsertConnection(body);
  }
  updateConnection(id, body) {
    return this.integrations.updateConnection(id, body);
  }
  listConnections(campgroundId) {
    return this.integrations.listConnections(campgroundId);
  }
  triggerSync(id, body) {
    return this.integrations.triggerSync(id, body);
  }
  listLogs(id, query) {
    const limit = query.limit ?? 50;
    return this.integrations.listLogs(id, limit, query.cursor);
  }
  listWebhooks(id, query) {
    const limit = query.limit ?? 50;
    return this.integrations.listWebhookEvents(id, limit, query.cursor);
  }
  queueExport(body) {
    return this.integrations.createExportJob(body);
  }
  webhook(provider, body, req, signature, altSignature, campgroundId) {
    const raw = req.rawBody ? req.rawBody.toString() : JSON.stringify(body);
    const providedSignature = signature || altSignature || req.headers["x-hub-signature"];
    return this.integrations.handleWebhook(provider, body, raw, providedSignature, campgroundId);
  }
};
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance),
  (0, import_common200.Post)("connections"),
  __decorateParam(0, (0, import_common200.Body)())
], IntegrationsController.prototype, "upsertConnection", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance),
  (0, import_common200.Patch)("connections/:id"),
  __decorateParam(0, (0, import_common200.Param)("id")),
  __decorateParam(1, (0, import_common200.Body)())
], IntegrationsController.prototype, "updateConnection", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance, import_client39.UserRole.readonly),
  (0, import_common200.Get)("connections"),
  __decorateParam(0, (0, import_common200.Query)("campgroundId"))
], IntegrationsController.prototype, "listConnections", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance),
  (0, import_common200.Post)("connections/:id/sync"),
  __decorateParam(0, (0, import_common200.Param)("id")),
  __decorateParam(1, (0, import_common200.Body)())
], IntegrationsController.prototype, "triggerSync", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance, import_client39.UserRole.readonly),
  (0, import_common200.Get)("connections/:id/logs"),
  __decorateParam(0, (0, import_common200.Param)("id")),
  __decorateParam(1, (0, import_common200.Query)())
], IntegrationsController.prototype, "listLogs", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance, import_client39.UserRole.readonly),
  (0, import_common200.Get)("connections/:id/webhooks"),
  __decorateParam(0, (0, import_common200.Param)("id")),
  __decorateParam(1, (0, import_common200.Query)())
], IntegrationsController.prototype, "listWebhooks", 1);
__decorateClass([
  (0, import_common200.UseGuards)(JwtAuthGuard, RolesGuard),
  Roles(import_client39.UserRole.owner, import_client39.UserRole.manager, import_client39.UserRole.finance),
  (0, import_common200.Post)("exports"),
  __decorateParam(0, (0, import_common200.Body)())
], IntegrationsController.prototype, "queueExport", 1);
__decorateClass([
  (0, import_common200.Post)("webhooks/:provider"),
  __decorateParam(0, (0, import_common200.Param)("provider")),
  __decorateParam(1, (0, import_common200.Body)()),
  __decorateParam(2, (0, import_common200.Req)()),
  __decorateParam(3, (0, import_common200.Headers)("x-signature")),
  __decorateParam(4, (0, import_common200.Headers)("x-hmac-signature")),
  __decorateParam(5, (0, import_common200.Headers)("x-campground-id"))
], IntegrationsController.prototype, "webhook", 1);
IntegrationsController = __decorateClass([
  (0, import_common200.Controller)("integrations")
], IntegrationsController);

// src/integrations/integrations.service.ts
var import_common201 = require("@nestjs/common");
var crypto4 = __toESM(require("crypto"));
var IntegrationsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  prismaClient() {
    return this.prisma;
  }
  upsertConnection(dto) {
    if (!dto.campgroundId) throw new import_common201.BadRequestException("campgroundId is required");
    const prisma = this.prismaClient();
    return prisma.integrationConnection.upsert({
      where: {
        campgroundId_type_provider: {
          campgroundId: dto.campgroundId,
          type: dto.type,
          provider: dto.provider
        }
      },
      create: {
        campgroundId: dto.campgroundId,
        organizationId: dto.organizationId ?? null,
        type: dto.type,
        provider: dto.provider,
        status: dto.status ?? "connected",
        authType: dto.authType ?? null,
        credentials: dto.credentials ?? null,
        settings: dto.settings ?? null,
        webhookSecret: dto.webhookSecret ?? null,
        lastSyncStatus: dto.status ?? null
      },
      update: {
        organizationId: dto.organizationId ?? null,
        status: dto.status ?? void 0,
        authType: dto.authType ?? void 0,
        credentials: dto.credentials ?? void 0,
        settings: dto.settings ?? void 0,
        webhookSecret: dto.webhookSecret ?? void 0
      }
    });
  }
  listConnections(campgroundId) {
    if (!campgroundId) throw new import_common201.BadRequestException("campgroundId is required");
    const prisma = this.prismaClient();
    return prisma.integrationConnection.findMany({
      where: { campgroundId },
      orderBy: { updatedAt: "desc" },
      include: {
        logs: { orderBy: { occurredAt: "desc" }, take: 1 }
      }
    });
  }
  updateConnection(id, dto) {
    const prisma = this.prismaClient();
    return prisma.integrationConnection.update({
      where: { id },
      data: {
        organizationId: dto.organizationId ?? void 0,
        status: dto.status ?? void 0,
        authType: dto.authType ?? void 0,
        credentials: dto.credentials ?? void 0,
        settings: dto.settings ?? void 0,
        webhookSecret: dto.webhookSecret ?? void 0
      }
    });
  }
  async listLogs(connectionId, limit = 50, cursor) {
    const prisma = this.prismaClient();
    const take = Math.min(limit, 200);
    const logs = await prisma.integrationSyncLog.findMany({
      where: { connectionId },
      orderBy: { occurredAt: "desc" },
      take: take + 1,
      ...cursor ? { skip: 1, cursor: { id: cursor } } : {}
    });
    const hasMore = logs.length > take;
    const items = hasMore ? logs.slice(0, take) : logs;
    return { items, nextCursor: hasMore ? items[items.length - 1].id : null };
  }
  async listWebhookEvents(connectionId, limit = 50, cursor) {
    const prisma = this.prismaClient();
    const take = Math.min(limit, 200);
    const events = await prisma.integrationWebhookEvent.findMany({
      where: { connectionId },
      orderBy: { receivedAt: "desc" },
      take: take + 1,
      ...cursor ? { skip: 1, cursor: { id: cursor } } : {}
    });
    const hasMore = events.length > take;
    const items = hasMore ? events.slice(0, take) : events;
    return { items, nextCursor: hasMore ? items[items.length - 1].id : null };
  }
  async recordSyncLog(connectionId, status, message, payload, scope, direction) {
    const prisma = this.prismaClient();
    return prisma.integrationSyncLog.create({
      data: {
        connectionId,
        status,
        message: message ?? null,
        payload: payload ?? null,
        scope: scope ?? "accounting",
        direction: direction ?? "pull"
      }
    });
  }
  async runQboSandboxPull(connection, direction, scope) {
    const token = process.env.QBO_SANDBOX_TOKEN;
    const realmId = connection.settings?.realmId || process.env.QBO_SANDBOX_REALMID;
    const base = process.env.QBO_SANDBOX_BASE || "https://sandbox-quickbooks.api.intuit.com";
    if (!token || !realmId) {
      return { ok: false, reason: "missing_token_or_realm" };
    }
    try {
      const query = encodeURIComponent("select * from Account maxresults 5");
      const res = await fetch(`${base}/v3/company/${realmId}/query?query=${query}`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/json",
          "Content-Type": "application/text"
        }
      });
      if (!res.ok) {
        return { ok: false, reason: `qbo_http_${res.status}` };
      }
      const json = await res.json();
      const accounts = json?.QueryResponse?.Account || [];
      const summary = {
        realmId,
        accountCount: accounts.length,
        sample: accounts.slice(0, 3).map((a) => ({ id: a.Id, name: a.Name, type: a.AccountType }))
      };
      await this.recordSyncLog(connection.id, "success", "QBO sandbox pull complete", summary, scope ?? "accounting", direction ?? "pull");
      await this.prismaClient().integrationConnection.update({
        where: { id: connection.id },
        data: { lastSyncAt: /* @__PURE__ */ new Date(), lastSyncStatus: "success", lastError: null }
      });
      return { ok: true, summary };
    } catch (err) {
      await this.recordSyncLog(connection.id, "failed", err?.message || "QBO sandbox pull failed", null, scope ?? "accounting", direction ?? "pull");
      await this.prismaClient().integrationConnection.update({
        where: { id: connection.id },
        data: { lastSyncAt: /* @__PURE__ */ new Date(), lastSyncStatus: "error", lastError: err?.message ?? "Unknown error" }
      });
      return { ok: false, reason: "exception", error: err?.message };
    }
  }
  async triggerSync(connectionId, body) {
    const prisma = this.prismaClient();
    const connection = await prisma.integrationConnection.findUnique({ where: { id: connectionId } });
    if (!connection) throw new import_common201.BadRequestException("Connection not found");
    await this.recordSyncLog(connectionId, "queued", body?.note ?? "Manual sync queued", null, body.scope ?? connection.type, body.direction ?? "pull");
    const sandboxEnabled = (process.env.INTEGRATIONS_SANDBOX_ENABLED || "true").toLowerCase() !== "false";
    if (sandboxEnabled && connection.provider?.toLowerCase() === "qbo" && connection.type === "accounting") {
      const result = await this.runQboSandboxPull(connection, body.direction, body.scope);
      if (result.ok) {
        return { ok: true, connectionId, status: "success", sandbox: true, summary: result.summary };
      }
      const samplePayload = {
        accounts: [
          { id: "1000", name: "Cash", type: "Asset" },
          { id: "2000", name: "Deferred Revenue", type: "Liability" }
        ],
        realmId: connection.settings?.realmId ?? "sandbox-realm",
        note: "Stubbed because sandbox creds/realm were missing"
      };
      await prisma.integrationSyncLog.create({
        data: {
          connectionId,
          direction: body.direction ?? "pull",
          scope: body.scope ?? "accounting",
          status: "success",
          message: "Sandbox QBO pull (stub) complete",
          payload: samplePayload
        }
      });
      await prisma.integrationConnection.update({
        where: { id: connectionId },
        data: { lastSyncAt: /* @__PURE__ */ new Date(), lastSyncStatus: "success", lastError: null }
      });
      return { ok: true, connectionId, status: "success", sandbox: true, summary: samplePayload };
    }
    return { ok: true, connectionId, status: "queued" };
  }
  async createExportJob(dto) {
    const prisma = this.prismaClient();
    if (!dto.type) throw new import_common201.BadRequestException("type is required");
    const job = await prisma.integrationExportJob.create({
      data: {
        type: dto.type,
        connectionId: dto.connectionId ?? null,
        campgroundId: dto.campgroundId ?? null,
        resource: dto.resource ?? null,
        status: "queued",
        location: dto.location ?? null,
        requestedById: dto.requestedById ?? null,
        filters: dto.filters ?? null
      }
    });
    if (dto.connectionId) {
      await this.recordSyncLog(dto.connectionId, "queued", "Export job queued", { jobId: job.id, resource: dto.resource }, dto.resource ?? "export", "export");
    }
    return job;
  }
  verifyHmac(raw, secret, signature) {
    if (!secret) return true;
    const provided = (signature || "").replace(/^sha256=/i, "");
    if (!provided) return false;
    const computed = crypto4.createHmac("sha256", secret).update(raw).digest("hex");
    if (provided.length !== computed.length) return false;
    return crypto4.timingSafeEqual(Buffer.from(computed), Buffer.from(provided));
  }
  async handleWebhook(provider, body, rawBody, signature, campgroundId) {
    const prisma = this.prismaClient();
    const connection = await prisma.integrationConnection.findFirst({
      where: {
        provider,
        ...campgroundId ? { campgroundId } : {}
      }
    });
    const secret = connection?.webhookSecret || process.env.INTEGRATIONS_WEBHOOK_SECRET || process.env.WEBHOOK_SECRET || "";
    const signatureValid = this.verifyHmac(rawBody, secret, signature);
    const event = await prisma.integrationWebhookEvent.create({
      data: {
        connectionId: connection?.id ?? null,
        provider,
        eventType: body?.type || body?.event || null,
        status: signatureValid ? "received" : "failed",
        signatureValid,
        message: signatureValid ? null : "Invalid signature",
        payload: body ?? null
      }
    });
    if (connection?.id) {
      await this.recordSyncLog(
        connection.id,
        signatureValid ? "queued" : "failed",
        signatureValid ? "Webhook received" : "Webhook signature invalid",
        { webhookEventId: event.id },
        connection.type,
        "webhook"
      );
    }
    return { ok: signatureValid, connectionId: connection?.id ?? null, eventId: event.id };
  }
};
IntegrationsService = __decorateClass([
  (0, import_common201.Injectable)()
], IntegrationsService);

// src/integrations/integrations.module.ts
var IntegrationsModule = class {
};
IntegrationsModule = __decorateClass([
  (0, import_common202.Module)({
    controllers: [IntegrationsController],
    providers: [IntegrationsService, PrismaService]
  })
], IntegrationsModule);

// src/developer-api/developer-api.module.ts
var import_common215 = require("@nestjs/common");

// src/developer-api/api-auth.controller.ts
var import_common203 = require("@nestjs/common");
var import_class_validator2 = require("class-validator");
var TokenRequestDto = class {
};
__decorateClass([
  (0, import_class_validator2.IsString)(),
  (0, import_class_validator2.IsIn)(["client_credentials", "refresh_token"])
], TokenRequestDto.prototype, "grant_type", 2);
__decorateClass([
  (0, import_class_validator2.IsString)(),
  (0, import_class_validator2.IsOptional)()
], TokenRequestDto.prototype, "client_id", 2);
__decorateClass([
  (0, import_class_validator2.IsString)(),
  (0, import_class_validator2.IsOptional)()
], TokenRequestDto.prototype, "client_secret", 2);
__decorateClass([
  (0, import_class_validator2.IsString)(),
  (0, import_class_validator2.IsOptional)()
], TokenRequestDto.prototype, "scope", 2);
__decorateClass([
  (0, import_class_validator2.IsString)(),
  (0, import_class_validator2.IsOptional)()
], TokenRequestDto.prototype, "refresh_token", 2);
var ApiAuthController = class {
  constructor(apiAuth) {
    this.apiAuth = apiAuth;
  }
  async token(body) {
    if (body.grant_type === "client_credentials") {
      if (!body.client_id || !body.client_secret) {
        throw new import_common203.BadRequestException("client_id and client_secret are required");
      }
      return this.apiAuth.issueClientCredentialsToken({
        clientId: body.client_id,
        clientSecret: body.client_secret,
        scope: body.scope
      });
    }
    if (body.grant_type === "refresh_token") {
      if (!body.refresh_token) {
        throw new import_common203.BadRequestException("refresh_token is required");
      }
      return this.apiAuth.refreshAccessToken(body.refresh_token);
    }
    throw new import_common203.BadRequestException("Unsupported grant type");
  }
};
__decorateClass([
  (0, import_common203.Post)("token"),
  __decorateParam(0, (0, import_common203.Body)())
], ApiAuthController.prototype, "token", 1);
ApiAuthController = __decorateClass([
  (0, import_common203.Controller)("oauth")
], ApiAuthController);

// src/developer-api/developer-admin.controller.ts
var import_common204 = require("@nestjs/common");
var import_class_validator3 = require("class-validator");
var CreateClientDto = class {
};
__decorateClass([
  (0, import_class_validator3.IsString)(),
  (0, import_class_validator3.IsNotEmpty)()
], CreateClientDto.prototype, "campgroundId", 2);
__decorateClass([
  (0, import_class_validator3.IsString)(),
  (0, import_class_validator3.IsNotEmpty)()
], CreateClientDto.prototype, "name", 2);
__decorateClass([
  (0, import_class_validator3.IsArray)(),
  (0, import_class_validator3.IsOptional)()
], CreateClientDto.prototype, "scopes", 2);
var ToggleClientDto = class {
};
__decorateClass([
  (0, import_class_validator3.IsBoolean)()
], ToggleClientDto.prototype, "isActive", 2);
var DeveloperAdminController = class {
  constructor(apiAuth) {
    this.apiAuth = apiAuth;
  }
  list(campgroundId) {
    return this.apiAuth.listClients(campgroundId);
  }
  async create(body) {
    return this.apiAuth.createClient(body);
  }
  rotate(id) {
    return this.apiAuth.rotateSecret(id);
  }
  toggle(id, body) {
    return this.apiAuth.setClientActive(id, body.isActive);
  }
  revokeToken(id) {
    return this.apiAuth.revokeToken(id);
  }
  remove(id) {
    return this.apiAuth.deleteClient(id);
  }
};
__decorateClass([
  (0, import_common204.Get)(),
  __decorateParam(0, (0, import_common204.Query)("campgroundId"))
], DeveloperAdminController.prototype, "list", 1);
__decorateClass([
  (0, import_common204.Post)(),
  __decorateParam(0, (0, import_common204.Body)())
], DeveloperAdminController.prototype, "create", 1);
__decorateClass([
  (0, import_common204.Post)(":id/rotate"),
  __decorateParam(0, (0, import_common204.Param)("id"))
], DeveloperAdminController.prototype, "rotate", 1);
__decorateClass([
  (0, import_common204.Patch)(":id/toggle"),
  __decorateParam(0, (0, import_common204.Param)("id")),
  __decorateParam(1, (0, import_common204.Body)())
], DeveloperAdminController.prototype, "toggle", 1);
__decorateClass([
  (0, import_common204.Post)("tokens/:id/revoke"),
  __decorateParam(0, (0, import_common204.Param)("id"))
], DeveloperAdminController.prototype, "revokeToken", 1);
__decorateClass([
  (0, import_common204.Delete)(":id"),
  __decorateParam(0, (0, import_common204.Param)("id"))
], DeveloperAdminController.prototype, "remove", 1);
DeveloperAdminController = __decorateClass([
  (0, import_common204.UseGuards)(JwtAuthGuard),
  (0, import_common204.Controller)("developer/clients")
], DeveloperAdminController);

// src/developer-api/webhook-admin.controller.ts
var import_common205 = require("@nestjs/common");
var import_class_validator4 = require("class-validator");
var CreateWebhookDto = class {
};
__decorateClass([
  (0, import_class_validator4.IsString)(),
  (0, import_class_validator4.IsNotEmpty)()
], CreateWebhookDto.prototype, "campgroundId", 2);
__decorateClass([
  (0, import_class_validator4.IsString)(),
  (0, import_class_validator4.IsOptional)()
], CreateWebhookDto.prototype, "apiClientId", 2);
__decorateClass([
  (0, import_class_validator4.IsUrl)()
], CreateWebhookDto.prototype, "url", 2);
__decorateClass([
  (0, import_class_validator4.IsArray)()
], CreateWebhookDto.prototype, "eventTypes", 2);
__decorateClass([
  (0, import_class_validator4.IsString)(),
  (0, import_class_validator4.IsOptional)()
], CreateWebhookDto.prototype, "description", 2);
var ToggleWebhookDto = class {
};
__decorateClass([
  (0, import_class_validator4.IsBoolean)()
], ToggleWebhookDto.prototype, "isActive", 2);
var WebhookAdminController = class {
  constructor(webhookService) {
    this.webhookService = webhookService;
  }
  listEndpoints(campgroundId) {
    return this.webhookService.listEndpoints(campgroundId);
  }
  createEndpoint(body) {
    return this.webhookService.createEndpoint({
      campgroundId: body.campgroundId,
      apiClientId: body.apiClientId,
      url: body.url,
      description: body.description,
      eventTypes: body.eventTypes
    });
  }
  toggle(id, body) {
    return this.webhookService.toggleEndpoint(id, body.isActive);
  }
  deliveries(campgroundId, limit) {
    const take = limit ? Number(limit) : 50;
    return this.webhookService.listDeliveries(campgroundId, take);
  }
  replay(id) {
    return this.webhookService.replay(id);
  }
};
__decorateClass([
  (0, import_common205.Get)("endpoints"),
  __decorateParam(0, (0, import_common205.Query)("campgroundId"))
], WebhookAdminController.prototype, "listEndpoints", 1);
__decorateClass([
  (0, import_common205.Post)("endpoints"),
  __decorateParam(0, (0, import_common205.Body)())
], WebhookAdminController.prototype, "createEndpoint", 1);
__decorateClass([
  (0, import_common205.Patch)("endpoints/:id/toggle"),
  __decorateParam(0, (0, import_common205.Param)("id")),
  __decorateParam(1, (0, import_common205.Body)())
], WebhookAdminController.prototype, "toggle", 1);
__decorateClass([
  (0, import_common205.Get)("deliveries"),
  __decorateParam(0, (0, import_common205.Query)("campgroundId")),
  __decorateParam(1, (0, import_common205.Query)("limit"))
], WebhookAdminController.prototype, "deliveries", 1);
__decorateClass([
  (0, import_common205.Post)("deliveries/:id/replay"),
  __decorateParam(0, (0, import_common205.Param)("id"))
], WebhookAdminController.prototype, "replay", 1);
WebhookAdminController = __decorateClass([
  (0, import_common205.UseGuards)(JwtAuthGuard),
  (0, import_common205.Controller)("developer/webhooks")
], WebhookAdminController);

// src/developer-api/public-reservations.controller.ts
var import_common209 = require("@nestjs/common");

// src/developer-api/guards/api-token.guard.ts
var import_common206 = require("@nestjs/common");
var import_crypto18 = require("crypto");
var ApiTokenGuard = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  hashToken(token) {
    return (0, import_crypto18.createHash)("sha256").update(token).digest("hex");
  }
  async canActivate(context) {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers["authorization"];
    if (!authHeader || !authHeader.toLowerCase().startsWith("bearer ")) {
      throw new import_common206.UnauthorizedException("Missing bearer token");
    }
    const token = authHeader.split(" ")[1];
    if (!token) throw new import_common206.UnauthorizedException("Missing bearer token");
    const hashed = this.hashToken(token);
    const record = await this.prisma.apiToken.findFirst({
      where: {
        accessTokenHash: hashed,
        revokedAt: null,
        expiresAt: { gt: /* @__PURE__ */ new Date() },
        apiClient: { isActive: true }
      },
      include: { apiClient: true }
    });
    if (!record || !record.apiClient) {
      throw new import_common206.UnauthorizedException("Invalid or expired token");
    }
    const principal = {
      apiClientId: record.apiClientId,
      tokenId: record.id,
      campgroundId: record.apiClient.campgroundId,
      scopes: record.scopes || []
    };
    request.apiPrincipal = principal;
    request.campgroundId = principal.campgroundId;
    return true;
  }
};
ApiTokenGuard = __decorateClass([
  (0, import_common206.Injectable)()
], ApiTokenGuard);

// src/developer-api/guards/api-scope.guard.ts
var import_common208 = require("@nestjs/common");

// src/developer-api/decorators/api-scopes.decorator.ts
var import_common207 = require("@nestjs/common");
var API_SCOPES_KEY = "api_scopes";
var ApiScopes = (...scopes) => (0, import_common207.SetMetadata)(API_SCOPES_KEY, scopes);

// src/developer-api/guards/api-scope.guard.ts
var ApiScopeGuard = class {
  constructor(reflector) {
    this.reflector = reflector;
  }
  canActivate(context) {
    const required = this.reflector.getAllAndOverride(API_SCOPES_KEY, [
      context.getHandler(),
      context.getClass()
    ]) || [];
    if (!required.length) return true;
    const request = context.switchToHttp().getRequest();
    const principal = request.apiPrincipal;
    if (!principal) throw new import_common208.ForbiddenException("Missing token context");
    const allowed = required.every((scope) => principal.scopes.includes(scope));
    if (!allowed) throw new import_common208.ForbiddenException("Insufficient scope");
    return true;
  }
};
ApiScopeGuard = __decorateClass([
  (0, import_common208.Injectable)()
], ApiScopeGuard);

// src/developer-api/public-reservations.controller.ts
var import_class_validator5 = require("class-validator");
var CreateReservationBody = class {
};
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsNotEmpty)()
], CreateReservationBody.prototype, "siteId", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsNotEmpty)()
], CreateReservationBody.prototype, "guestId", 2);
__decorateClass([
  (0, import_class_validator5.IsDateString)()
], CreateReservationBody.prototype, "arrivalDate", 2);
__decorateClass([
  (0, import_class_validator5.IsDateString)()
], CreateReservationBody.prototype, "departureDate", 2);
__decorateClass([
  (0, import_class_validator5.IsNumber)()
], CreateReservationBody.prototype, "adults", 2);
__decorateClass([
  (0, import_class_validator5.IsNumber)(),
  (0, import_class_validator5.IsOptional)()
], CreateReservationBody.prototype, "children", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], CreateReservationBody.prototype, "status", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], CreateReservationBody.prototype, "notes", 2);
var UpdateReservationBody = class {
};
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "siteId", 2);
__decorateClass([
  (0, import_class_validator5.IsDateString)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "arrivalDate", 2);
__decorateClass([
  (0, import_class_validator5.IsDateString)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "departureDate", 2);
__decorateClass([
  (0, import_class_validator5.IsNumber)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "adults", 2);
__decorateClass([
  (0, import_class_validator5.IsNumber)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "children", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "status", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], UpdateReservationBody.prototype, "notes", 2);
var PaymentBody = class {
};
__decorateClass([
  (0, import_class_validator5.IsNumber)()
], PaymentBody.prototype, "amountCents", 2);
__decorateClass([
  (0, import_class_validator5.IsString)(),
  (0, import_class_validator5.IsOptional)()
], PaymentBody.prototype, "method", 2);
var PublicReservationsController2 = class {
  constructor(api) {
    this.api = api;
  }
  list(req) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.listReservations(campgroundId);
  }
  get(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.getReservation(campgroundId, id);
  }
  create(req, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.createReservation(campgroundId, body);
  }
  update(req, id, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.updateReservation(campgroundId, id, body);
  }
  remove(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.deleteReservation(campgroundId, id);
  }
  pay(req, id, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.recordPayment(campgroundId, id, body.amountCents, body.method);
  }
};
__decorateClass([
  (0, import_common209.Get)(),
  ApiScopes("reservations:read"),
  __decorateParam(0, (0, import_common209.Req)())
], PublicReservationsController2.prototype, "list", 1);
__decorateClass([
  (0, import_common209.Get)(":id"),
  ApiScopes("reservations:read"),
  __decorateParam(0, (0, import_common209.Req)()),
  __decorateParam(1, (0, import_common209.Param)("id"))
], PublicReservationsController2.prototype, "get", 1);
__decorateClass([
  (0, import_common209.Post)(),
  ApiScopes("reservations:write"),
  __decorateParam(0, (0, import_common209.Req)()),
  __decorateParam(1, (0, import_common209.Body)())
], PublicReservationsController2.prototype, "create", 1);
__decorateClass([
  (0, import_common209.Patch)(":id"),
  ApiScopes("reservations:write"),
  __decorateParam(0, (0, import_common209.Req)()),
  __decorateParam(1, (0, import_common209.Param)("id")),
  __decorateParam(2, (0, import_common209.Body)())
], PublicReservationsController2.prototype, "update", 1);
__decorateClass([
  (0, import_common209.Delete)(":id"),
  ApiScopes("reservations:write"),
  __decorateParam(0, (0, import_common209.Req)()),
  __decorateParam(1, (0, import_common209.Param)("id"))
], PublicReservationsController2.prototype, "remove", 1);
__decorateClass([
  (0, import_common209.Post)(":id/payments"),
  ApiScopes("reservations:write"),
  __decorateParam(0, (0, import_common209.Req)()),
  __decorateParam(1, (0, import_common209.Param)("id")),
  __decorateParam(2, (0, import_common209.Body)())
], PublicReservationsController2.prototype, "pay", 1);
PublicReservationsController2 = __decorateClass([
  (0, import_common209.Controller)("public/reservations"),
  (0, import_common209.UseGuards)(ApiTokenGuard, ApiScopeGuard)
], PublicReservationsController2);

// src/developer-api/public-guests.controller.ts
var import_common210 = require("@nestjs/common");
var import_class_validator6 = require("class-validator");
var CreateGuestBody = class {
};
__decorateClass([
  (0, import_class_validator6.IsString)()
], CreateGuestBody.prototype, "primaryFirstName", 2);
__decorateClass([
  (0, import_class_validator6.IsString)()
], CreateGuestBody.prototype, "primaryLastName", 2);
__decorateClass([
  (0, import_class_validator6.IsEmail)()
], CreateGuestBody.prototype, "email", 2);
__decorateClass([
  (0, import_class_validator6.IsString)(),
  (0, import_class_validator6.IsOptional)()
], CreateGuestBody.prototype, "phone", 2);
var UpdateGuestBody = class {
};
__decorateClass([
  (0, import_class_validator6.IsString)(),
  (0, import_class_validator6.IsOptional)()
], UpdateGuestBody.prototype, "primaryFirstName", 2);
__decorateClass([
  (0, import_class_validator6.IsString)(),
  (0, import_class_validator6.IsOptional)()
], UpdateGuestBody.prototype, "primaryLastName", 2);
__decorateClass([
  (0, import_class_validator6.IsEmail)(),
  (0, import_class_validator6.IsOptional)()
], UpdateGuestBody.prototype, "email", 2);
__decorateClass([
  (0, import_class_validator6.IsString)(),
  (0, import_class_validator6.IsOptional)()
], UpdateGuestBody.prototype, "phone", 2);
var PublicGuestsController = class {
  constructor(api) {
    this.api = api;
  }
  list(req) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.listGuests(campgroundId);
  }
  get(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.getGuest(campgroundId, id);
  }
  create(req, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.createGuest(campgroundId, body);
  }
  update(req, id, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.updateGuest(campgroundId, id, body);
  }
  remove(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.deleteGuest(campgroundId, id);
  }
};
__decorateClass([
  (0, import_common210.Get)(),
  ApiScopes("guests:read"),
  __decorateParam(0, (0, import_common210.Req)())
], PublicGuestsController.prototype, "list", 1);
__decorateClass([
  (0, import_common210.Get)(":id"),
  ApiScopes("guests:read"),
  __decorateParam(0, (0, import_common210.Req)()),
  __decorateParam(1, (0, import_common210.Param)("id"))
], PublicGuestsController.prototype, "get", 1);
__decorateClass([
  (0, import_common210.Post)(),
  ApiScopes("guests:write"),
  __decorateParam(0, (0, import_common210.Req)()),
  __decorateParam(1, (0, import_common210.Body)())
], PublicGuestsController.prototype, "create", 1);
__decorateClass([
  (0, import_common210.Patch)(":id"),
  ApiScopes("guests:write"),
  __decorateParam(0, (0, import_common210.Req)()),
  __decorateParam(1, (0, import_common210.Param)("id")),
  __decorateParam(2, (0, import_common210.Body)())
], PublicGuestsController.prototype, "update", 1);
__decorateClass([
  (0, import_common210.Delete)(":id"),
  ApiScopes("guests:write"),
  __decorateParam(0, (0, import_common210.Req)()),
  __decorateParam(1, (0, import_common210.Param)("id"))
], PublicGuestsController.prototype, "remove", 1);
PublicGuestsController = __decorateClass([
  (0, import_common210.Controller)("public/guests"),
  (0, import_common210.UseGuards)(ApiTokenGuard, ApiScopeGuard)
], PublicGuestsController);

// src/developer-api/public-sites.controller.ts
var import_common211 = require("@nestjs/common");
var import_class_validator7 = require("class-validator");
var CreateSiteBody = class {
};
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsNotEmpty)()
], CreateSiteBody.prototype, "name", 2);
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsNotEmpty)()
], CreateSiteBody.prototype, "siteNumber", 2);
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsNotEmpty)()
], CreateSiteBody.prototype, "siteType", 2);
__decorateClass([
  (0, import_class_validator7.IsNumber)()
], CreateSiteBody.prototype, "maxOccupancy", 2);
__decorateClass([
  (0, import_class_validator7.IsNumber)(),
  (0, import_class_validator7.IsOptional)()
], CreateSiteBody.prototype, "rigMaxLength", 2);
var UpdateSiteBody = class {
};
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsOptional)()
], UpdateSiteBody.prototype, "name", 2);
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsOptional)()
], UpdateSiteBody.prototype, "siteNumber", 2);
__decorateClass([
  (0, import_class_validator7.IsString)(),
  (0, import_class_validator7.IsOptional)()
], UpdateSiteBody.prototype, "siteType", 2);
__decorateClass([
  (0, import_class_validator7.IsNumber)(),
  (0, import_class_validator7.IsOptional)()
], UpdateSiteBody.prototype, "maxOccupancy", 2);
__decorateClass([
  (0, import_class_validator7.IsNumber)(),
  (0, import_class_validator7.IsOptional)()
], UpdateSiteBody.prototype, "rigMaxLength", 2);
var PublicSitesController = class {
  constructor(api) {
    this.api = api;
  }
  list(req) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.listSites(campgroundId);
  }
  get(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.getSite(campgroundId, id);
  }
  create(req, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.createSite(campgroundId, body);
  }
  update(req, id, body) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.updateSite(campgroundId, id, body);
  }
  remove(req, id) {
    const campgroundId = req.apiPrincipal.campgroundId;
    return this.api.deleteSite(campgroundId, id);
  }
};
__decorateClass([
  (0, import_common211.Get)(),
  ApiScopes("sites:read"),
  __decorateParam(0, (0, import_common211.Req)())
], PublicSitesController.prototype, "list", 1);
__decorateClass([
  (0, import_common211.Get)(":id"),
  ApiScopes("sites:read"),
  __decorateParam(0, (0, import_common211.Req)()),
  __decorateParam(1, (0, import_common211.Param)("id"))
], PublicSitesController.prototype, "get", 1);
__decorateClass([
  (0, import_common211.Post)(),
  ApiScopes("sites:write"),
  __decorateParam(0, (0, import_common211.Req)()),
  __decorateParam(1, (0, import_common211.Body)())
], PublicSitesController.prototype, "create", 1);
__decorateClass([
  (0, import_common211.Patch)(":id"),
  ApiScopes("sites:write"),
  __decorateParam(0, (0, import_common211.Req)()),
  __decorateParam(1, (0, import_common211.Param)("id")),
  __decorateParam(2, (0, import_common211.Body)())
], PublicSitesController.prototype, "update", 1);
__decorateClass([
  (0, import_common211.Delete)(":id"),
  ApiScopes("sites:write"),
  __decorateParam(0, (0, import_common211.Req)()),
  __decorateParam(1, (0, import_common211.Param)("id"))
], PublicSitesController.prototype, "remove", 1);
PublicSitesController = __decorateClass([
  (0, import_common211.Controller)("public/sites"),
  (0, import_common211.UseGuards)(ApiTokenGuard, ApiScopeGuard)
], PublicSitesController);

// src/developer-api/api-auth.service.ts
var import_common212 = require("@nestjs/common");
var import_crypto19 = require("crypto");
var bcrypt3 = __toESM(require("bcryptjs"));
var DEFAULT_SCOPES = [
  "reservations:read",
  "reservations:write",
  "guests:read",
  "guests:write",
  "sites:read",
  "sites:write",
  "webhooks:read",
  "webhooks:write",
  "tokens:read",
  "tokens:write"
];
var ApiAuthService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.accessTtlSeconds = 3600;
  }
  hashToken(token) {
    return (0, import_crypto19.createHash)("sha256").update(token).digest("hex");
  }
  pickScopes(requested, allowed) {
    if (!requested) return allowed;
    const requestedList = requested.split(" ").map((s) => s.trim()).filter(Boolean);
    const allowedSet = new Set(allowed);
    const filtered = requestedList.filter((scope) => allowedSet.has(scope));
    return filtered.length ? filtered : allowed;
  }
  async validateClient(clientId, clientSecret) {
    const client = await this.prisma.apiClient.findUnique({ where: { clientId } });
    if (!client || !client.isActive) throw new import_common212.UnauthorizedException("Invalid client");
    const match = await bcrypt3.compare(clientSecret, client.clientSecretHash);
    if (!match) throw new import_common212.UnauthorizedException("Invalid client");
    return client;
  }
  async persistToken(apiClientId, scopes) {
    const accessToken = (0, import_crypto19.randomBytes)(32).toString("hex");
    const refreshToken = (0, import_crypto19.randomBytes)(48).toString("hex");
    const now = /* @__PURE__ */ new Date();
    const expiresAt = new Date(now.getTime() + this.accessTtlSeconds * 1e3);
    await this.prisma.apiToken.create({
      data: {
        apiClientId,
        accessTokenHash: this.hashToken(accessToken),
        refreshTokenHash: this.hashToken(refreshToken),
        scopes,
        expiresAt
      }
    });
    return { accessToken, refreshToken, expiresAt };
  }
  async issueClientCredentialsToken(opts) {
    const client = await this.validateClient(opts.clientId, opts.clientSecret);
    const scopes = this.pickScopes(opts.scope, client.scopes || []);
    const tokens = await this.persistToken(client.id, scopes);
    return {
      token_type: "Bearer",
      access_token: tokens.accessToken,
      refresh_token: tokens.refreshToken,
      expires_in: this.accessTtlSeconds,
      scope: scopes.join(" "),
      campground_id: client.campgroundId
    };
  }
  async refreshAccessToken(refreshToken) {
    const tokenHash = this.hashToken(refreshToken);
    const token = await this.prisma.apiToken.findFirst({
      where: { refreshTokenHash: tokenHash, revokedAt: null },
      include: { apiClient: true }
    });
    if (!token || !token.apiClient || !token.apiClient.isActive) {
      throw new import_common212.UnauthorizedException("Invalid refresh token");
    }
    const scopes = token.scopes || token.apiClient.scopes || [];
    const tokens = await this.persistToken(token.apiClientId, scopes);
    return {
      token_type: "Bearer",
      access_token: tokens.accessToken,
      refresh_token: tokens.refreshToken,
      expires_in: this.accessTtlSeconds,
      scope: scopes.join(" "),
      campground_id: token.apiClient.campgroundId
    };
  }
  async createClient(input) {
    const clientId = `cg_${(0, import_crypto19.randomBytes)(6).toString("hex")}`;
    const clientSecret = (0, import_crypto19.randomBytes)(24).toString("hex");
    const hashedSecret = await bcrypt3.hash(clientSecret, 12);
    const scopes = input.scopes && input.scopes.length ? input.scopes : DEFAULT_SCOPES;
    const client = await this.prisma.apiClient.create({
      data: {
        campgroundId: input.campgroundId,
        name: input.name,
        clientId,
        clientSecretHash: hashedSecret,
        scopes
      }
    });
    return { client, clientSecret };
  }
  async listClients(campgroundId) {
    return this.prisma.apiClient.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" }
    });
  }
  async rotateSecret(clientId) {
    const secret = (0, import_crypto19.randomBytes)(24).toString("hex");
    const hashedSecret = await bcrypt3.hash(secret, 12);
    const client = await this.prisma.apiClient.update({
      where: { id: clientId },
      data: { clientSecretHash: hashedSecret }
    });
    return { client, clientSecret: secret };
  }
  async setClientActive(clientId, isActive) {
    return this.prisma.apiClient.update({
      where: { id: clientId },
      data: { isActive }
    });
  }
  async revokeToken(tokenId) {
    return this.prisma.apiToken.update({
      where: { id: tokenId },
      data: { revokedAt: /* @__PURE__ */ new Date() }
    });
  }
  async deleteClient(clientId) {
    await this.prisma.apiToken.deleteMany({ where: { apiClientId: clientId } });
    return this.prisma.apiClient.delete({ where: { id: clientId } });
  }
  getDefaultScopes() {
    return DEFAULT_SCOPES;
  }
};
ApiAuthService = __decorateClass([
  (0, import_common212.Injectable)()
], ApiAuthService);

// src/developer-api/webhook.service.ts
var import_common213 = require("@nestjs/common");
var import_crypto20 = require("crypto");
var WebhookService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  computeSignature(secret, payload, timestamp) {
    const toSign = `${timestamp}.${payload}`;
    const digest = (0, import_crypto20.createHmac)("sha256", secret).update(toSign).digest("hex");
    return `t=${timestamp},v1=${digest}`;
  }
  async createEndpoint(input) {
    const secret = `wh_${(0, import_crypto20.randomBytes)(16).toString("hex")}`;
    const endpoint = await this.prisma.webhookEndpoint.create({
      data: {
        campgroundId: input.campgroundId,
        apiClientId: input.apiClientId || null,
        url: input.url,
        description: input.description,
        eventTypes: input.eventTypes,
        secret
      }
    });
    return { endpoint, secret };
  }
  listEndpoints(campgroundId) {
    return this.prisma.webhookEndpoint.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" }
    });
  }
  async toggleEndpoint(id, isActive) {
    return this.prisma.webhookEndpoint.update({
      where: { id },
      data: { isActive, disabledAt: isActive ? null : /* @__PURE__ */ new Date() }
    });
  }
  async emit(eventType, campgroundId, payload) {
    const endpoints = await this.prisma.webhookEndpoint.findMany({
      where: {
        campgroundId,
        isActive: true,
        OR: [{ eventTypes: { has: eventType } }, { eventTypes: { has: "*" } }]
      }
    });
    if (!endpoints.length) return;
    const body = JSON.stringify({ event: eventType, data: payload });
    for (const ep of endpoints) {
      const timestamp = Date.now();
      const signature = this.computeSignature(ep.secret, body, timestamp);
      const delivery = await this.prisma.webhookDelivery.create({
        data: {
          webhookEndpointId: ep.id,
          eventType,
          status: "pending",
          payload,
          signature
        }
      });
      try {
        const res = await fetch(ep.url, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "x-campreserv-signature": signature
          },
          body
        });
        const text = await res.text();
        await this.prisma.webhookDelivery.update({
          where: { id: delivery.id },
          data: {
            status: res.ok ? "delivered" : "failed",
            responseStatus: res.status,
            responseBody: text?.slice(0, 2e3),
            deliveredAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (err) {
        await this.prisma.webhookDelivery.update({
          where: { id: delivery.id },
          data: { status: "failed", errorMessage: err?.message || "Webhook send failed" }
        });
      }
    }
  }
  listDeliveries(campgroundId, limit = 50) {
    return this.prisma.webhookDelivery.findMany({
      where: { webhookEndpoint: { campgroundId } },
      orderBy: { createdAt: "desc" },
      take: limit,
      include: { webhookEndpoint: true }
    });
  }
  async replay(deliveryId) {
    const delivery = await this.prisma.webhookDelivery.findUnique({
      where: { id: deliveryId },
      include: { webhookEndpoint: true }
    });
    if (!delivery || !delivery.webhookEndpoint) {
      throw new import_common213.NotFoundException("Delivery not found");
    }
    const body = JSON.stringify({ event: delivery.eventType, data: delivery.payload });
    const timestamp = Date.now();
    const signature = this.computeSignature(delivery.webhookEndpoint.secret, body, timestamp);
    const replayLog = await this.prisma.webhookDelivery.create({
      data: {
        webhookEndpointId: delivery.webhookEndpointId,
        eventType: delivery.eventType,
        payload: delivery.payload,
        signature,
        status: "pending",
        attempt: (delivery.attempt || 1) + 1,
        replayOfId: delivery.id
      }
    });
    try {
      const res = await fetch(delivery.webhookEndpoint.url, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "x-campreserv-signature": signature
        },
        body
      });
      const text = await res.text();
      await this.prisma.webhookDelivery.update({
        where: { id: replayLog.id },
        data: {
          status: res.ok ? "delivered" : "failed",
          responseStatus: res.status,
          responseBody: text?.slice(0, 2e3),
          deliveredAt: /* @__PURE__ */ new Date()
        }
      });
      return replayLog;
    } catch (err) {
      await this.prisma.webhookDelivery.update({
        where: { id: replayLog.id },
        data: { status: "failed", errorMessage: err?.message || "Replay failed" }
      });
      throw err;
    }
  }
};
WebhookService = __decorateClass([
  (0, import_common213.Injectable)()
], WebhookService);

// src/developer-api/public-api.service.ts
var import_common214 = require("@nestjs/common");
var PublicApiService = class {
  constructor(prisma, webhook, guests) {
    this.prisma = prisma;
    this.webhook = webhook;
    this.guests = guests;
  }
  async assertSiteInCampground(siteId, campgroundId) {
    const site = await this.prisma.site.findUnique({ where: { id: siteId }, select: { campgroundId: true } });
    if (!site || site.campgroundId !== campgroundId) {
      throw new import_common214.BadRequestException("Site does not belong to this campground");
    }
  }
  async assertReservationCampground(reservationId, campgroundId) {
    const reservation = await this.prisma.reservation.findUnique({ where: { id: reservationId }, select: { campgroundId: true } });
    if (!reservation || reservation.campgroundId !== campgroundId) {
      throw new import_common214.NotFoundException("Reservation not found for this campground");
    }
  }
  async listReservations(campgroundId) {
    return this.prisma.reservation.findMany({
      where: { campgroundId },
      orderBy: { createdAt: "desc" },
      include: {
        site: { select: { id: true, name: true, siteNumber: true } },
        guest: { select: { id: true, primaryFirstName: true, primaryLastName: true, email: true } }
      }
    });
  }
  async getReservation(campgroundId, id) {
    const reservation = await this.prisma.reservation.findFirst({
      where: { id, campgroundId },
      include: {
        site: { select: { id: true, name: true, siteNumber: true } },
        guest: { select: { id: true, primaryFirstName: true, primaryLastName: true, email: true } },
        payments: true
      }
    });
    if (!reservation) throw new import_common214.NotFoundException("Reservation not found");
    return reservation;
  }
  async createReservation(campgroundId, input) {
    await this.assertSiteInCampground(input.siteId, campgroundId);
    const created = await this.prisma.reservation.create({
      data: {
        campgroundId,
        siteId: input.siteId,
        guestId: input.guestId,
        arrivalDate: new Date(input.arrivalDate),
        departureDate: new Date(input.departureDate),
        adults: input.adults,
        children: input.children ?? 0,
        status: input.status || "confirmed",
        notes: input.notes || null
      }
    });
    await this.webhook.emit("reservation.created", campgroundId, { reservationId: created.id });
    return created;
  }
  async updateReservation(campgroundId, id, input) {
    await this.assertReservationCampground(id, campgroundId);
    if (input.siteId) {
      await this.assertSiteInCampground(input.siteId, campgroundId);
    }
    const updated = await this.prisma.reservation.update({
      where: { id },
      data: {
        ...input.siteId ? { siteId: input.siteId } : {},
        ...input.arrivalDate ? { arrivalDate: new Date(input.arrivalDate) } : {},
        ...input.departureDate ? { departureDate: new Date(input.departureDate) } : {},
        ...input.adults !== void 0 ? { adults: input.adults } : {},
        ...input.children !== void 0 ? { children: input.children } : {},
        ...input.status ? { status: input.status } : {},
        ...input.notes !== void 0 ? { notes: input.notes } : {}
      }
    });
    await this.webhook.emit("reservation.updated", campgroundId, { reservationId: id });
    return updated;
  }
  async deleteReservation(campgroundId, id) {
    await this.assertReservationCampground(id, campgroundId);
    const deleted = await this.prisma.reservation.delete({ where: { id } });
    await this.webhook.emit("reservation.deleted", campgroundId, { reservationId: id });
    return deleted;
  }
  async recordPayment(campgroundId, reservationId, amountCents, method = "card") {
    await this.assertReservationCampground(reservationId, campgroundId);
    const payment = await this.prisma.payment.create({
      data: {
        campgroundId,
        reservationId,
        amountCents,
        method
      }
    });
    await this.webhook.emit("payment.created", campgroundId, { reservationId, paymentId: payment.id });
    return payment;
  }
  async listGuests(campgroundId) {
    return this.prisma.guest.findMany({
      where: { reservations: { some: { campgroundId } } },
      orderBy: { createdAt: "desc" },
      take: 100
    });
  }
  async getGuest(campgroundId, id) {
    const guest = await this.prisma.guest.findUnique({
      where: { id },
      include: {
        reservations: {
          where: { campgroundId },
          orderBy: { arrivalDate: "desc" },
          include: { site: { select: { id: true, name: true, siteNumber: true } } }
        }
      }
    });
    if (!guest) throw new import_common214.NotFoundException("Guest not found");
    return guest;
  }
  async createGuest(campgroundId, input) {
    const guest = await this.guests.create({
      primaryFirstName: input.primaryFirstName,
      primaryLastName: input.primaryLastName,
      email: input.email,
      phone: input.phone
    });
    await this.webhook.emit("guest.created", campgroundId, { guestId: guest.id });
    return guest;
  }
  async updateGuest(campgroundId, id, input) {
    await this.getGuest(campgroundId, id);
    return this.guests.update(id, input);
  }
  async deleteGuest(campgroundId, id) {
    await this.getGuest(campgroundId, id);
    return this.guests.remove(id);
  }
  async listSites(campgroundId) {
    return this.prisma.site.findMany({
      where: { campgroundId },
      orderBy: { siteNumber: "asc" }
    });
  }
  async getSite(campgroundId, id) {
    const site = await this.prisma.site.findUnique({ where: { id } });
    if (!site || site.campgroundId !== campgroundId) throw new import_common214.NotFoundException("Site not found");
    return site;
  }
  async createSite(campgroundId, input) {
    const created = await this.prisma.site.create({
      data: {
        campgroundId,
        name: input.name,
        siteNumber: input.siteNumber,
        siteType: input.siteType,
        maxOccupancy: input.maxOccupancy,
        rigMaxLength: input.rigMaxLength ?? null
      }
    });
    await this.webhook.emit("site.created", campgroundId, { siteId: created.id });
    return created;
  }
  async updateSite(campgroundId, id, input) {
    await this.getSite(campgroundId, id);
    const updated = await this.prisma.site.update({
      where: { id },
      data: {
        ...input.name ? { name: input.name } : {},
        ...input.siteNumber ? { siteNumber: input.siteNumber } : {},
        ...input.siteType ? { siteType: input.siteType } : {},
        ...input.maxOccupancy !== void 0 ? { maxOccupancy: input.maxOccupancy } : {},
        ...input.rigMaxLength !== void 0 ? { rigMaxLength: input.rigMaxLength } : {}
      }
    });
    await this.webhook.emit("site.updated", campgroundId, { siteId: updated.id });
    return updated;
  }
  async deleteSite(campgroundId, id) {
    await this.getSite(campgroundId, id);
    const deleted = await this.prisma.site.delete({ where: { id } });
    await this.webhook.emit("site.deleted", campgroundId, { siteId: id });
    return deleted;
  }
};
PublicApiService = __decorateClass([
  (0, import_common214.Injectable)()
], PublicApiService);

// src/developer-api/developer-api.module.ts
var DeveloperApiModule = class {
};
DeveloperApiModule = __decorateClass([
  (0, import_common215.Module)({
    controllers: [
      ApiAuthController,
      DeveloperAdminController,
      WebhookAdminController,
      PublicReservationsController2,
      PublicGuestsController,
      PublicSitesController
    ],
    providers: [
      ApiAuthService,
      WebhookService,
      PublicApiService,
      PrismaService,
      GuestsService,
      ApiTokenGuard,
      ApiScopeGuard
    ],
    exports: [WebhookService, ApiAuthService]
  })
], DeveloperApiModule);

// src/privacy/privacy.module.ts
var import_common218 = require("@nestjs/common");

// src/privacy/privacy.controller.ts
var import_common216 = require("@nestjs/common");
var import_client40 = require("@prisma/client");
var PrivacyController = class {
  constructor(privacy) {
    this.privacy = privacy;
  }
  async getSettings(campgroundId) {
    return this.privacy.getSettings(campgroundId);
  }
  async updateSettings(campgroundId, body) {
    return this.privacy.updateSettings(campgroundId, body);
  }
  async recordConsent(campgroundId, body) {
    return this.privacy.recordConsent({
      campgroundId,
      subject: body.subject,
      consentType: body.consentType,
      grantedBy: body.grantedBy,
      method: body.method,
      purpose: body.purpose,
      expiresAt: body.expiresAt ? new Date(body.expiresAt) : void 0,
      metadata: body.metadata ?? void 0
    });
  }
  async listConsents(campgroundId) {
    return this.privacy.listConsents(campgroundId);
  }
  async listTags() {
    return this.privacy.listPiiTags();
  }
  async upsertTag(body) {
    return this.privacy.upsertPiiTag({
      resource: body.resource,
      field: body.field,
      classification: body.classification,
      redactionMode: body.redactionMode,
      createdById: body.createdById ?? null
    });
  }
  async recentRedactions(campgroundId) {
    return this.privacy.listRecentRedactions(campgroundId);
  }
  async preview(campgroundId, body) {
    return this.privacy.previewRedaction(campgroundId, body.resource, body.sample);
  }
  async export(campgroundId, format, res) {
    if (format === "csv" && res) {
      return this.privacy.exportConsentCsv(campgroundId, res);
    }
    return this.privacy.exportConsentBundle(campgroundId);
  }
};
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Get)(),
  __decorateParam(0, (0, import_common216.Param)("campgroundId"))
], PrivacyController.prototype, "getSettings", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Post)(),
  __decorateParam(0, (0, import_common216.Param)("campgroundId")),
  __decorateParam(1, (0, import_common216.Body)())
], PrivacyController.prototype, "updateSettings", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Post)("consents"),
  __decorateParam(0, (0, import_common216.Param)("campgroundId")),
  __decorateParam(1, (0, import_common216.Body)())
], PrivacyController.prototype, "recordConsent", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager, import_client40.UserRole.readonly),
  (0, import_common216.Get)("consents"),
  __decorateParam(0, (0, import_common216.Param)("campgroundId"))
], PrivacyController.prototype, "listConsents", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Get)("pii-tags")
], PrivacyController.prototype, "listTags", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Post)("pii-tags"),
  __decorateParam(0, (0, import_common216.Body)())
], PrivacyController.prototype, "upsertTag", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager, import_client40.UserRole.readonly),
  (0, import_common216.Get)("redactions/recent"),
  __decorateParam(0, (0, import_common216.Param)("campgroundId"))
], PrivacyController.prototype, "recentRedactions", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager, import_client40.UserRole.readonly),
  (0, import_common216.Post)("preview"),
  __decorateParam(0, (0, import_common216.Param)("campgroundId")),
  __decorateParam(1, (0, import_common216.Body)())
], PrivacyController.prototype, "preview", 1);
__decorateClass([
  Roles(import_client40.UserRole.owner, import_client40.UserRole.manager),
  (0, import_common216.Get)("export"),
  __decorateParam(0, (0, import_common216.Param)("campgroundId")),
  __decorateParam(1, (0, import_common216.Query)("format")),
  __decorateParam(2, (0, import_common216.Res)())
], PrivacyController.prototype, "export", 1);
PrivacyController = __decorateClass([
  (0, import_common216.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common216.Controller)("campgrounds/:campgroundId/privacy")
], PrivacyController);

// src/privacy/privacy.service.ts
var import_common217 = require("@nestjs/common");
var PrivacyService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  maskValue(val) {
    if (typeof val !== "string") return val;
    const emailMasked = val.replace(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi, "***@redacted");
    const phoneMasked = emailMasked.replace(/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "***-***-****");
    return phoneMasked;
  }
  scrub(value) {
    if (Array.isArray(value)) return value.map((v) => this.scrub(v));
    if (value && typeof value === "object") {
      return Object.entries(value).reduce((acc, [k, v]) => {
        acc[k] = this.scrub(v);
        return acc;
      }, {});
    }
    return this.maskValue(value);
  }
  applyTagRedactions(sample, tags) {
    if (Array.isArray(sample)) return sample.map((v) => this.applyTagRedactions(v, tags));
    if (sample && typeof sample === "object") {
      const byField = new Map(tags.map((t) => [t.field, t.redactionMode]));
      const out = {};
      for (const [key, value] of Object.entries(sample)) {
        const mode = byField.get(key);
        if (mode === "remove") continue;
        out[key] = mode ? this.maskValue(value) : this.applyTagRedactions(value, tags);
      }
      return out;
    }
    return this.maskValue(sample);
  }
  async getSettings(campgroundId) {
    const existing = await this.prisma.privacySetting.findUnique({ where: { campgroundId } });
    if (existing) return existing;
    return this.prisma.privacySetting.create({
      data: {
        campgroundId,
        redactPII: true,
        consentRequired: true,
        backupRetentionDays: 30,
        keyRotationDays: 90
      }
    });
  }
  async updateSettings(campgroundId, patch) {
    await this.getSettings(campgroundId);
    return this.prisma.privacySetting.update({
      where: { campgroundId },
      data: patch
    });
  }
  async recordConsent(entry) {
    return this.prisma.consentLog.create({
      data: {
        campgroundId: entry.campgroundId,
        subject: entry.subject,
        consentType: entry.consentType,
        grantedBy: entry.grantedBy,
        method: entry.method,
        purpose: entry.purpose ?? null,
        expiresAt: entry.expiresAt ?? null,
        revokedAt: entry.revokedAt ?? null,
        metadata: entry.metadata ?? void 0
      }
    });
  }
  async listConsents(campgroundId) {
    return this.prisma.consentLog.findMany({
      where: { campgroundId },
      orderBy: { grantedAt: "desc" },
      take: 200
    });
  }
  async listPiiTags() {
    return this.prisma.piiFieldTag.findMany({ orderBy: [{ resource: "asc" }, { field: "asc" }] });
  }
  async upsertPiiTag(entry) {
    return this.prisma.piiFieldTag.upsert({
      where: { resource_field: { resource: entry.resource, field: entry.field } },
      create: {
        resource: entry.resource,
        field: entry.field,
        classification: entry.classification,
        redactionMode: entry.redactionMode,
        createdById: entry.createdById ?? null
      },
      update: {
        classification: entry.classification,
        redactionMode: entry.redactionMode
      }
    });
  }
  async previewRedaction(campgroundId, resource, sample) {
    const tags = await this.prisma.piiFieldTag.findMany({
      where: resource ? { resource } : void 0,
      select: { field: true, redactionMode: true, classification: true },
      orderBy: [{ resource: "asc" }, { field: "asc" }],
      take: 100
    });
    const redacted = tags.length ? this.applyTagRedactions(sample, tags) : this.scrub(sample);
    return {
      redacted,
      rulesApplied: tags.map((t) => ({ field: t.field, redactionMode: t.redactionMode, classification: t.classification })),
      campgroundId
    };
  }
  async listRecentRedactions(campgroundId) {
    const logs = await this.prisma.auditLog.findMany({
      where: { campgroundId },
      select: { id: true, action: true, entity: true, entityId: true, before: true, after: true, createdAt: true },
      orderBy: { createdAt: "desc" },
      take: 10
    });
    return logs.map((log) => ({
      id: log.id,
      action: log.action,
      entity: log.entity,
      entityId: log.entityId,
      createdAt: log.createdAt,
      sample: this.scrub({ before: log.before, after: log.after })
    }));
  }
  async exportConsentBundle(campgroundId) {
    const [settings, consents, piiTags] = await Promise.all([
      this.getSettings(campgroundId),
      this.prisma.consentLog.findMany({
        where: { campgroundId },
        orderBy: { grantedAt: "desc" },
        take: 200
      }),
      this.prisma.piiFieldTag.findMany({
        orderBy: [{ resource: "asc" }, { field: "asc" }],
        take: 200
      })
    ]);
    const consentRows = consents.length > 0 ? consents : [
      {
        id: "stub-consent",
        campgroundId,
        subject: "guest@example.com",
        consentType: "marketing",
        grantedBy: "system",
        grantedAt: (/* @__PURE__ */ new Date()).toISOString(),
        purpose: "demo",
        method: "digital",
        expiresAt: null,
        revokedAt: null
      }
    ];
    const piiRows = piiTags.length > 0 ? piiTags : [
      {
        resource: "guest",
        field: "email",
        classification: "sensitive",
        redactionMode: "mask"
      }
    ];
    return {
      exportVersion: "stub",
      campgroundId,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      settings: {
        redactPII: settings.redactPII,
        consentRequired: settings.consentRequired,
        backupRetentionDays: settings.backupRetentionDays,
        keyRotationDays: settings.keyRotationDays
      },
      consents: consentRows.map((c) => ({
        id: c.id ?? null,
        subject: c.subject,
        consentType: c.consentType,
        grantedBy: c.grantedBy,
        grantedAt: c.grantedAt ? new Date(c.grantedAt).toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
        purpose: c.purpose ?? null,
        method: c.method ?? null,
        expiresAt: c.expiresAt ? new Date(c.expiresAt).toISOString() : null,
        revokedAt: c.revokedAt ? new Date(c.revokedAt).toISOString() : null
      })),
      piiTags: piiRows.map((p) => ({
        resource: p.resource,
        field: p.field,
        classification: p.classification,
        redactionMode: p.redactionMode ?? null
      }))
    };
  }
  async exportConsentCsv(campgroundId, res) {
    const bundle = await this.exportConsentBundle(campgroundId);
    const rows = [];
    rows.push(
      [
        "type",
        "campgroundId",
        "subject",
        "consentType",
        "grantedBy",
        "grantedAt",
        "purpose",
        "expiresAt",
        "resource",
        "field",
        "classification",
        "redactionMode",
        "settingKey",
        "settingValue"
      ].join(",")
    );
    const sanitize = (value) => {
      if (value === null || value === void 0) return "";
      return String(value).replace(/,/g, ";");
    };
    for (const consent of bundle.consents) {
      rows.push(
        [
          "consent",
          campgroundId,
          sanitize(consent.subject),
          sanitize(consent.consentType),
          sanitize(consent.grantedBy),
          sanitize(consent.grantedAt),
          sanitize(consent.purpose),
          sanitize(consent.expiresAt),
          "",
          "",
          "",
          "",
          "",
          ""
        ].join(",")
      );
    }
    for (const tag of bundle.piiTags) {
      rows.push(
        [
          "pii_tag",
          campgroundId,
          "",
          "",
          "",
          "",
          "",
          "",
          sanitize(tag.resource),
          sanitize(tag.field),
          sanitize(tag.classification),
          sanitize(tag.redactionMode),
          "",
          ""
        ].join(",")
      );
    }
    rows.push(
      ["setting", campgroundId, "", "", "", "", "", "", "", "", "", "", "redactPII", sanitize(bundle.settings.redactPII)].join(",")
    );
    rows.push(
      [
        "setting",
        campgroundId,
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "consentRequired",
        sanitize(bundle.settings.consentRequired)
      ].join(",")
    );
    rows.push(
      [
        "setting",
        campgroundId,
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "backupRetentionDays",
        sanitize(bundle.settings.backupRetentionDays)
      ].join(",")
    );
    rows.push(
      [
        "setting",
        campgroundId,
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "keyRotationDays",
        sanitize(bundle.settings.keyRotationDays)
      ].join(",")
    );
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", "attachment; filename=privacy-consent-export.csv");
    return res.send(rows.join("\n"));
  }
};
PrivacyService = __decorateClass([
  (0, import_common217.Injectable)()
], PrivacyService);

// src/privacy/privacy.module.ts
var PrivacyModule = class {
};
PrivacyModule = __decorateClass([
  (0, import_common218.Module)({
    controllers: [PrivacyController],
    providers: [PrivacyService, PrismaService],
    exports: [PrivacyService]
  })
], PrivacyModule);

// src/portfolios/portfolios.module.ts
var import_common221 = require("@nestjs/common");

// src/portfolios/portfolios.service.ts
var import_common219 = require("@nestjs/common");
var PortfoliosService = class {
  constructor() {
    this.portfolios = [
      {
        id: "pf-continental",
        name: "Continental Parks",
        homeCurrency: "USD",
        parks: [
          {
            id: "cg-redwood",
            name: "Redwood Ridge",
            region: "US-CA",
            currency: "USD",
            occupancy: 0.82,
            adr: 145,
            revpar: 118.9,
            mtdRevenue: 125e3,
            timezone: "America/Los_Angeles",
            fxToHome: 1,
            taxSummary: "US sales/lodging tax blended 8.5%",
            routing: {
              adminHost: "redwood.admin.campreserv.test",
              guestHost: "stay.redwood.test",
              path: "/campgrounds/cg-redwood"
            }
          },
          {
            id: "cg-lakeview",
            name: "Lakeview Shores",
            region: "CA-BC",
            currency: "CAD",
            occupancy: 0.76,
            adr: 170,
            revpar: 129.2,
            mtdRevenue: 98e3,
            timezone: "America/Vancouver",
            fxToHome: 0.74,
            taxSummary: "GST 5% + PST 7%",
            routing: {
              adminHost: "lakeview.admin.campreserv.test",
              guestHost: "lakeview.travel.test",
              path: "/campgrounds/cg-lakeview"
            }
          },
          {
            id: "cg-alpine",
            name: "Alpine Meadow",
            region: "DE-BY",
            currency: "EUR",
            occupancy: 0.81,
            adr: 130,
            revpar: 105.3,
            mtdRevenue: 87e3,
            timezone: "Europe/Berlin",
            fxToHome: 1.07,
            taxSummary: "VAT 19% included",
            routing: {
              adminHost: "alpine.admin.campreserv.test",
              guestHost: "alpine.stays.test",
              path: "/campgrounds/cg-alpine"
            }
          }
        ]
      },
      {
        id: "pf-sunbelt",
        name: "Sunbelt Resorts",
        homeCurrency: "USD",
        parks: [
          {
            id: "cg-desert",
            name: "Desert Oasis",
            region: "US-AZ",
            currency: "USD",
            occupancy: 0.74,
            adr: 132,
            revpar: 97.7,
            mtdRevenue: 76e3,
            timezone: "America/Phoenix",
            fxToHome: 1,
            taxSummary: "AZ transient tax 11%",
            routing: {
              adminHost: "desert.admin.campreserv.test",
              guestHost: "desertstay.test",
              path: "/campgrounds/cg-desert"
            }
          },
          {
            id: "cg-gulf",
            name: "Gulf Breeze",
            region: "US-FL",
            currency: "USD",
            occupancy: 0.79,
            adr: 155,
            revpar: 122.5,
            mtdRevenue: 89e3,
            timezone: "America/Chicago",
            fxToHome: 1,
            taxSummary: "Tourist + state tax 11.5%",
            routing: {
              adminHost: "gulf.admin.campreserv.test",
              guestHost: "gulfbreeze.test",
              path: "/campgrounds/cg-gulf"
            }
          }
        ]
      }
    ];
    this.selection = {};
  }
  list() {
    const activePortfolioId = this.selection.portfolioId ?? this.portfolios[0]?.id ?? null;
    const activeParkId = this.selection.parkId ?? this.portfolios.find((p) => p.id === activePortfolioId)?.parks[0]?.id ?? this.portfolios[0]?.parks[0]?.id ?? null;
    return {
      portfolios: this.portfolios,
      activePortfolioId,
      activeParkId
    };
  }
  select(portfolioId, parkId) {
    const portfolio = this.portfolios.find((p) => p.id === portfolioId);
    if (!portfolio) {
      return this.list();
    }
    const resolvedParkId = parkId ?? portfolio.parks[0]?.id;
    this.selection = { portfolioId, parkId: resolvedParkId };
    return {
      activePortfolioId: portfolioId,
      activeParkId: resolvedParkId ?? null,
      routes: portfolio.parks.map((park) => ({
        parkId: park.id,
        adminHost: park.routing?.adminHost,
        guestHost: park.routing?.guestHost,
        path: park.routing?.path
      }))
    };
  }
  report(portfolioId) {
    const portfolio = this.portfolios.find((p) => p.id === portfolioId) ?? this.portfolios[0];
    if (!portfolio) return { portfolioId, metrics: [], rollup: null, asOf: (/* @__PURE__ */ new Date()).toISOString() };
    const metrics = portfolio.parks.map((park) => ({
      parkId: park.id,
      name: park.name,
      region: park.region,
      currency: park.currency,
      occupancy: park.occupancy,
      adr: park.adr,
      revpar: park.revpar,
      revenue: park.mtdRevenue,
      revenueHome: park.fxToHome ? Math.round(park.mtdRevenue * park.fxToHome) : park.mtdRevenue,
      taxSummary: park.taxSummary,
      fxToHome: park.fxToHome ?? 1
    }));
    const rollup = metrics.reduce(
      (acc, m) => {
        acc.revenueHome += m.revenueHome;
        acc.occupancy += m.occupancy;
        acc.adr += m.adr;
        acc.revpar += m.revpar;
        return acc;
      },
      { revenueHome: 0, occupancy: 0, adr: 0, revpar: 0 }
    );
    const count = metrics.length || 1;
    return {
      portfolioId: portfolio.id,
      homeCurrency: portfolio.homeCurrency,
      asOf: (/* @__PURE__ */ new Date()).toISOString(),
      metrics,
      rollup: {
        currency: portfolio.homeCurrency,
        revenueHome: Math.round(rollup.revenueHome),
        occupancy: Number((rollup.occupancy / count).toFixed(2)),
        adr: Number((rollup.adr / count).toFixed(2)),
        revpar: Number((rollup.revpar / count).toFixed(2))
      },
      routing: portfolio.parks.map((p) => ({
        parkId: p.id,
        adminHost: p.routing?.adminHost,
        guestHost: p.routing?.guestHost,
        path: p.routing?.path
      })),
      recommendations: [
        {
          id: "fx-hedge",
          title: "CAD exposure trending up",
          impact: "Track CAD \u2192 USD swings for BC parks; consider monthly hedge.",
          area: "Finance"
        },
        {
          id: "eu-vat",
          title: "VAT-inclusive pricing",
          impact: "EU parks already return VAT-inclusive rates; verify guest invoices.",
          area: "Compliance"
        }
      ]
    };
  }
};
PortfoliosService = __decorateClass([
  (0, import_common219.Injectable)()
], PortfoliosService);

// src/portfolios/portfolios.controller.ts
var import_common220 = require("@nestjs/common");
var PortfoliosController = class {
  constructor(portfolios) {
    this.portfolios = portfolios;
  }
  list() {
    return this.portfolios.list();
  }
  report(id) {
    return this.portfolios.report(id);
  }
  select(body, portfolioHeader, parkHeader) {
    const portfolioId = body?.portfolioId || portfolioHeader;
    const parkId = body?.parkId || parkHeader;
    if (!portfolioId) {
      return this.portfolios.list();
    }
    return this.portfolios.select(portfolioId, parkId);
  }
  routes(id) {
    return this.portfolios.report(id).routing;
  }
};
__decorateClass([
  (0, import_common220.Get)()
], PortfoliosController.prototype, "list", 1);
__decorateClass([
  (0, import_common220.Get)(":id/report"),
  __decorateParam(0, (0, import_common220.Param)("id"))
], PortfoliosController.prototype, "report", 1);
__decorateClass([
  (0, import_common220.Post)("select"),
  __decorateParam(0, (0, import_common220.Body)()),
  __decorateParam(1, (0, import_common220.Headers)("x-portfolio-id")),
  __decorateParam(2, (0, import_common220.Headers)("x-park-id"))
], PortfoliosController.prototype, "select", 1);
__decorateClass([
  (0, import_common220.Get)(":id/routes"),
  __decorateParam(0, (0, import_common220.Param)("id"))
], PortfoliosController.prototype, "routes", 1);
PortfoliosController = __decorateClass([
  (0, import_common220.UseGuards)(JwtAuthGuard),
  (0, import_common220.Controller)("portfolios")
], PortfoliosController);

// src/portfolios/portfolios.module.ts
var PortfoliosModule = class {
};
PortfoliosModule = __decorateClass([
  (0, import_common221.Module)({
    controllers: [PortfoliosController],
    providers: [PortfoliosService],
    exports: [PortfoliosService]
  })
], PortfoliosModule);

// src/localization/localization.module.ts
var import_common224 = require("@nestjs/common");

// src/localization/localization.service.ts
var import_common222 = require("@nestjs/common");
var LocalizationService = class {
  constructor() {
    this.locales = [
      {
        code: "en-US",
        label: "English (United States)",
        currency: "USD",
        timezone: "America/Denver",
        dateFormat: "MM/dd/yyyy",
        numberFormat: "1,234.56"
      },
      {
        code: "en-CA",
        label: "English (Canada)",
        currency: "CAD",
        timezone: "America/Toronto",
        dateFormat: "yyyy-MM-dd",
        numberFormat: "1 234,56"
      },
      {
        code: "es-ES",
        label: "Espa\xF1ol (Espa\xF1a)",
        currency: "EUR",
        timezone: "Europe/Madrid",
        dateFormat: "dd/MM/yyyy",
        numberFormat: "1.234,56"
      },
      {
        code: "fr-CA",
        label: "Fran\xE7ais (Canada)",
        currency: "CAD",
        timezone: "America/Montreal",
        dateFormat: "yyyy-MM-dd",
        numberFormat: "1 234,56"
      },
      {
        code: "de-DE",
        label: "Deutsch (Deutschland)",
        currency: "EUR",
        timezone: "Europe/Berlin",
        dateFormat: "dd.MM.yyyy",
        numberFormat: "1.234,56"
      }
    ];
    this.userSettings = /* @__PURE__ */ new Map();
  }
  listLocales() {
    return this.locales;
  }
  getSettings(userKey, orgKey) {
    const key = this.makeKey(userKey, orgKey);
    const existing = this.userSettings.get(key);
    if (existing) return existing;
    const fallback = {
      locale: "en-US",
      currency: "USD",
      timezone: "America/Denver",
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      orgLocale: orgKey ? "en-US" : void 0,
      orgCurrency: orgKey ? "USD" : void 0
    };
    this.userSettings.set(key, fallback);
    return fallback;
  }
  updateSettings(userKey, orgKey, payload) {
    const key = this.makeKey(userKey, orgKey);
    const current = this.getSettings(userKey, orgKey);
    const next = {
      ...current,
      ...payload,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.userSettings.set(key, next);
    return next;
  }
  preview(locale, currency, timezone) {
    const sampleDate = /* @__PURE__ */ new Date("2025-01-15T15:30:00Z");
    const formattedDate = new Intl.DateTimeFormat(locale, {
      dateStyle: "full",
      timeStyle: "short",
      timeZone: timezone
    }).format(sampleDate);
    const formattedNumber = new Intl.NumberFormat(locale, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(98765.4321);
    const formattedCurrency = new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: 2
    }).format(1234.56);
    return {
      sampleDate: sampleDate.toISOString(),
      formattedDate,
      formattedNumber,
      formattedCurrency,
      translatedPhrases: this.translationsFor(locale)
    };
  }
  makeKey(userKey, orgKey) {
    return `${orgKey ?? "org-default"}:${userKey}`;
  }
  translationsFor(locale) {
    switch (locale) {
      case "es-ES":
        return {
          dashboard: "Panel",
          revenue: "Ingresos",
          occupancy: "Ocupaci\xF3n",
          approvals: "Aprobaciones"
        };
      case "fr-CA":
        return {
          dashboard: "Tableau de bord",
          revenue: "Revenu",
          occupancy: "Occupation",
          approvals: "Approbations"
        };
      case "de-DE":
        return {
          dashboard: "\xDCbersicht",
          revenue: "Umsatz",
          occupancy: "Belegung",
          approvals: "Freigaben"
        };
      default:
        return {
          dashboard: "Dashboard",
          revenue: "Revenue",
          occupancy: "Occupancy",
          approvals: "Approvals"
        };
    }
  }
};
LocalizationService = __decorateClass([
  (0, import_common222.Injectable)()
], LocalizationService);

// src/localization/localization.controller.ts
var import_common223 = require("@nestjs/common");
var LocalizationController = class {
  constructor(localization) {
    this.localization = localization;
  }
  locales() {
    return this.localization.listLocales();
  }
  settings(userHeader, orgHeader) {
    const userKey = userHeader || "demo-user";
    return this.localization.getSettings(userKey, orgHeader);
  }
  update(body, userHeader, orgHeader) {
    const userKey = userHeader || "demo-user";
    return this.localization.updateSettings(userKey, orgHeader, body);
  }
  preview(locale = "en-US", currency = "USD", timezone = "America/Denver") {
    return this.localization.preview(locale, currency, timezone);
  }
};
__decorateClass([
  (0, import_common223.Get)("locales")
], LocalizationController.prototype, "locales", 1);
__decorateClass([
  (0, import_common223.Get)("settings"),
  __decorateParam(0, (0, import_common223.Headers)("x-user-id")),
  __decorateParam(1, (0, import_common223.Headers)("x-organization-id"))
], LocalizationController.prototype, "settings", 1);
__decorateClass([
  (0, import_common223.Post)("settings"),
  __decorateParam(0, (0, import_common223.Body)()),
  __decorateParam(1, (0, import_common223.Headers)("x-user-id")),
  __decorateParam(2, (0, import_common223.Headers)("x-organization-id"))
], LocalizationController.prototype, "update", 1);
__decorateClass([
  (0, import_common223.Get)("preview"),
  __decorateParam(0, (0, import_common223.Query)("locale")),
  __decorateParam(1, (0, import_common223.Query)("currency")),
  __decorateParam(2, (0, import_common223.Query)("timezone"))
], LocalizationController.prototype, "preview", 1);
LocalizationController = __decorateClass([
  (0, import_common223.UseGuards)(JwtAuthGuard),
  (0, import_common223.Controller)("localization")
], LocalizationController);

// src/localization/localization.module.ts
var LocalizationModule = class {
};
LocalizationModule = __decorateClass([
  (0, import_common224.Module)({
    controllers: [LocalizationController],
    providers: [LocalizationService],
    exports: [LocalizationService]
  })
], LocalizationModule);

// src/currency-tax/currency-tax.module.ts
var import_common227 = require("@nestjs/common");

// src/currency-tax/currency-tax.service.ts
var import_common225 = require("@nestjs/common");
var CurrencyTaxService = class {
  constructor() {
    this.config = {
      baseCurrency: "USD",
      reportingCurrency: "USD",
      fxProvider: "stub",
      fxRates: [
        { base: "USD", quote: "CAD", rate: 1.34, asOf: (/* @__PURE__ */ new Date()).toISOString() },
        { base: "USD", quote: "EUR", rate: 0.92, asOf: (/* @__PURE__ */ new Date()).toISOString() },
        { base: "CAD", quote: "EUR", rate: 0.69, asOf: (/* @__PURE__ */ new Date()).toISOString() }
      ],
      taxProfiles: [
        { id: "us-default", name: "US sales/lodging", region: "US", type: "sales", rate: 0.085, inclusive: false },
        { id: "ca-gst-pst", name: "GST/PST (BC)", region: "CA-BC", type: "gst", rate: 0.12, inclusive: false, notes: "GST 5% + PST 7%" },
        { id: "eu-vat", name: "EU VAT (DE)", region: "DE", type: "vat", rate: 0.19, inclusive: true }
      ],
      parkCurrencies: [
        { parkId: "cg-redwood", currency: "USD", taxProfileId: "us-default" },
        { parkId: "cg-lakeview", currency: "CAD", taxProfileId: "ca-gst-pst" },
        { parkId: "cg-alpine", currency: "EUR", taxProfileId: "eu-vat" }
      ],
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  getConfig() {
    return this.config;
  }
  updateConfig(payload) {
    this.config = {
      ...this.config,
      ...payload,
      fxRates: payload.fxRates ?? this.config.fxRates,
      taxProfiles: payload.taxProfiles ?? this.config.taxProfiles,
      parkCurrencies: payload.parkCurrencies ?? this.config.parkCurrencies,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    return this.config;
  }
  convert(amount, from, to) {
    if (from === to) {
      return { amount, from, to, rate: 1, converted: amount, asOf: (/* @__PURE__ */ new Date()).toISOString() };
    }
    const direct = this.config.fxRates.find((r) => r.base === from && r.quote === to);
    if (direct) {
      return {
        amount,
        from,
        to,
        rate: direct.rate,
        converted: Number((amount * direct.rate).toFixed(2)),
        asOf: direct.asOf
      };
    }
    const inverse = this.config.fxRates.find((r) => r.base === to && r.quote === from);
    if (inverse) {
      const rate = 1 / inverse.rate;
      return {
        amount,
        from,
        to,
        rate: Number(rate.toFixed(6)),
        converted: Number((amount * rate).toFixed(2)),
        asOf: inverse.asOf
      };
    }
    const base = this.config.baseCurrency;
    const toBase = this.convert(amount, from, base);
    const final = this.convert(toBase.converted, base, to);
    return {
      amount,
      from,
      to,
      rate: Number((toBase.rate * final.rate).toFixed(6)),
      converted: final.converted,
      asOf: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  summary() {
    const exposureByCurrency = this.config.parkCurrencies.reduce((acc, row) => {
      acc[row.currency] = (acc[row.currency] ?? 0) + 1;
      return acc;
    }, {});
    return {
      exposureByCurrency,
      fxRates: this.config.fxRates,
      taxProfiles: this.config.taxProfiles,
      reportingCurrency: this.config.reportingCurrency,
      updatedAt: this.config.updatedAt
    };
  }
};
CurrencyTaxService = __decorateClass([
  (0, import_common225.Injectable)()
], CurrencyTaxService);

// src/currency-tax/currency-tax.controller.ts
var import_common226 = require("@nestjs/common");
var CurrencyTaxController = class {
  constructor(currencyTax) {
    this.currencyTax = currencyTax;
  }
  getConfig() {
    return this.currencyTax.getConfig();
  }
  updateConfig(body) {
    const normalized = {
      ...body,
      fxRates: body.fxRates?.map((r) => ({
        ...r,
        asOf: r.asOf ?? (/* @__PURE__ */ new Date()).toISOString()
      }))
    };
    return this.currencyTax.updateConfig(normalized);
  }
  convert(body) {
    return this.currencyTax.convert(body.amount, body.from, body.to);
  }
  summary() {
    return this.currencyTax.summary();
  }
};
__decorateClass([
  (0, import_common226.Get)()
], CurrencyTaxController.prototype, "getConfig", 1);
__decorateClass([
  (0, import_common226.Post)(),
  __decorateParam(0, (0, import_common226.Body)())
], CurrencyTaxController.prototype, "updateConfig", 1);
__decorateClass([
  (0, import_common226.Post)("convert"),
  __decorateParam(0, (0, import_common226.Body)())
], CurrencyTaxController.prototype, "convert", 1);
__decorateClass([
  (0, import_common226.Get)("summary")
], CurrencyTaxController.prototype, "summary", 1);
CurrencyTaxController = __decorateClass([
  (0, import_common226.UseGuards)(JwtAuthGuard),
  (0, import_common226.Controller)("currency-tax")
], CurrencyTaxController);

// src/currency-tax/currency-tax.module.ts
var CurrencyTaxModule = class {
};
CurrencyTaxModule = __decorateClass([
  (0, import_common227.Module)({
    controllers: [CurrencyTaxController],
    providers: [CurrencyTaxService],
    exports: [CurrencyTaxService]
  })
], CurrencyTaxModule);

// src/gift-cards/gift-cards.module.ts
var import_common230 = require("@nestjs/common");

// src/gift-cards/gift-cards.controller.ts
var import_common228 = require("@nestjs/common");
var import_http_code = require("@nestjs/common/decorators/http/http-code.decorator");
var import_client41 = require("@prisma/client");
var import_class_validator8 = require("class-validator");
var import_class_transformer2 = require("class-transformer");
var RedeemGiftCardDto = class {
};
__decorateClass([
  (0, import_class_validator8.IsString)()
], RedeemGiftCardDto.prototype, "code", 2);
__decorateClass([
  (0, import_class_transformer2.Type)(() => Number),
  (0, import_class_validator8.IsInt)(),
  (0, import_class_validator8.Min)(1)
], RedeemGiftCardDto.prototype, "amountCents", 2);
var GiftCardsController = class {
  constructor(giftCards) {
    this.giftCards = giftCards;
  }
  redeemBooking(bookingId, body) {
    return this.giftCards.redeemAgainstBooking(body.code, body.amountCents, bookingId);
  }
  redeemPosOrder(orderId, body) {
    return this.giftCards.redeemAgainstPosOrder(body.code, body.amountCents, orderId);
  }
};
__decorateClass([
  Roles(import_client41.UserRole.owner, import_client41.UserRole.manager, import_client41.UserRole.finance),
  (0, import_common228.Post)("bookings/:bookingId/gift-cards/redeem"),
  (0, import_http_code.HttpCode)(200),
  __decorateParam(0, (0, import_common228.Param)("bookingId")),
  __decorateParam(1, (0, import_common228.Body)())
], GiftCardsController.prototype, "redeemBooking", 1);
__decorateClass([
  Roles(import_client41.UserRole.owner, import_client41.UserRole.manager, import_client41.UserRole.finance),
  (0, import_common228.Post)("pos/orders/:orderId/gift-cards/redeem"),
  (0, import_http_code.HttpCode)(200),
  __decorateParam(0, (0, import_common228.Param)("orderId")),
  __decorateParam(1, (0, import_common228.Body)())
], GiftCardsController.prototype, "redeemPosOrder", 1);
GiftCardsController = __decorateClass([
  (0, import_common228.Controller)(),
  (0, import_common228.UseGuards)(JwtAuthGuard, RolesGuard)
], GiftCardsController);

// src/gift-cards/gift-cards.service.ts
var import_common229 = require("@nestjs/common");
var GiftCardsService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.memory = /* @__PURE__ */ new Map();
    this.seedInMemory([
      { code: "CAMP-WELCOME-100", balanceCents: 1e4, kind: "gift_card" },
      { code: "STORE-RETURN-50", balanceCents: 5e3, kind: "store_credit" }
    ]);
  }
  /**
   * Test/helper hook to reset the in-memory stub state.
   */
  seedInMemory(cards) {
    this.memory.clear();
    cards.forEach((card) => this.memory.set(card.code, { currency: "usd", ...card }));
  }
  /**
   * Used by smoke tests to assert balance updates without poking at internals.
   */
  getBalance(code) {
    return this.memory.get(code)?.balanceCents ?? null;
  }
  async redeemAgainstBooking(code, amountCents, bookingId) {
    return this.redeem(code, amountCents, { channel: "booking", referenceId: bookingId });
  }
  async redeemAgainstPosOrder(code, amountCents, orderId) {
    return this.redeem(code, amountCents, { channel: "pos", referenceId: orderId });
  }
  async redeem(code, amountCents, context) {
    if (!code) throw new import_common229.BadRequestException("code is required");
    if (!amountCents || amountCents <= 0) throw new import_common229.BadRequestException("amount must be positive");
    const card = await this.loadCard(code);
    if (!card) throw new import_common229.NotFoundException("Gift card or store credit not found");
    if (card.balanceCents < amountCents) throw new import_common229.BadRequestException("Insufficient balance");
    const balanceCents = card.balanceCents - amountCents;
    this.memory.set(code, { ...card, balanceCents });
    const prismaGiftCard = this.prisma?.giftCard;
    if (prismaGiftCard?.update) {
      await prismaGiftCard.update({
        where: { code },
        data: { balanceCents }
      });
    }
    const prismaTxn = this.prisma?.giftCardTransaction;
    if (prismaTxn?.create) {
      await prismaTxn.create({
        data: {
          code,
          amountCents,
          channel: context.channel,
          referenceId: context.referenceId
        }
      });
    }
    return {
      code,
      balanceCents,
      redeemedCents: amountCents,
      channel: context.channel,
      referenceId: context.referenceId
    };
  }
  async loadCard(code) {
    const fromMemory = this.memory.get(code);
    if (fromMemory) return fromMemory;
    const prismaGiftCard = this.prisma?.giftCard;
    if (prismaGiftCard?.findUnique) {
      const found = await prismaGiftCard.findUnique({ where: { code } });
      if (found) {
        this.memory.set(code, found);
        return found;
      }
    }
    return null;
  }
};
GiftCardsService = __decorateClass([
  (0, import_common229.Injectable)()
], GiftCardsService);

// src/gift-cards/gift-cards.module.ts
var GiftCardsModule = class {
};
GiftCardsModule = __decorateClass([
  (0, import_common230.Module)({
    controllers: [GiftCardsController],
    providers: [GiftCardsService, PrismaService],
    exports: [GiftCardsService]
  })
], GiftCardsModule);

// src/backup/backup.module.ts
var import_common233 = require("@nestjs/common");

// src/backup/backup.controller.ts
var import_common231 = require("@nestjs/common");
var import_client42 = require("@prisma/client");
var BackupController = class {
  constructor(backup) {
    this.backup = backup;
  }
  status(campgroundId) {
    return this.backup.getStatus(campgroundId);
  }
  simulate(campgroundId) {
    return this.backup.simulateRestore(campgroundId);
  }
};
__decorateClass([
  Roles(import_client42.UserRole.owner, import_client42.UserRole.manager, import_client42.UserRole.readonly),
  RequireScope({ resource: "backup", action: "read" }),
  (0, import_common231.Get)("status"),
  __decorateParam(0, (0, import_common231.Param)("campgroundId"))
], BackupController.prototype, "status", 1);
__decorateClass([
  Roles(import_client42.UserRole.owner, import_client42.UserRole.manager),
  RequireScope({ resource: "backup", action: "write" }),
  (0, import_common231.Post)("restore-sim"),
  __decorateParam(0, (0, import_common231.Param)("campgroundId"))
], BackupController.prototype, "simulate", 1);
BackupController = __decorateClass([
  (0, import_common231.UseGuards)(JwtAuthGuard, RolesGuard, ScopeGuard),
  (0, import_common231.Controller)("campgrounds/:campgroundId/backup")
], BackupController);

// src/backup/backup.service.ts
var import_common232 = require("@nestjs/common");
var ServiceUnavailableException3 = class extends import_common232.HttpException {
  constructor(message) {
    super(message, import_common232.HttpStatus.SERVICE_UNAVAILABLE);
  }
};
var BackupProvider = class {
};
var HttpBackupProvider = class {
  constructor() {
    this.base = process.env.BACKUP_API_BASE;
    this.token = process.env.BACKUP_API_TOKEN;
    this.retries = Number(process.env.BACKUP_API_RETRIES ?? 2);
    this.timeoutMs = Number(process.env.BACKUP_API_TIMEOUT_MS ?? 5e3);
  }
  headers() {
    const h = { "Content-Type": "application/json" };
    if (this.token) h["Authorization"] = `Bearer ${this.token}`;
    return h;
  }
  ensureConfigured() {
    if (!this.base) {
      const msg = "BACKUP_API_BASE not configured";
      if (process.env.NODE_ENV === "production") {
        throw new ServiceUnavailableException3(msg);
      }
      throw new ServiceUnavailableException3(msg);
    }
  }
  getFetch() {
    const f = globalThis.fetch;
    if (!f) {
      throw new ServiceUnavailableException3("global fetch is unavailable; provide a fetch polyfill");
    }
    return f;
  }
  async fetchWithRetry(url, init) {
    const fetchFn = this.getFetch();
    let attempt = 0;
    let lastError;
    while (attempt <= this.retries) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), this.timeoutMs);
      try {
        const res = await fetchFn(url, { ...init, signal: controller.signal });
        clearTimeout(timer);
        return res;
      } catch (err) {
        clearTimeout(timer);
        lastError = err;
        attempt += 1;
        if (attempt > this.retries) break;
      }
    }
    throw new ServiceUnavailableException3(lastError?.message || "Backup provider request failed");
  }
  async healthCheck() {
    this.ensureConfigured();
    try {
      const res = await this.fetchWithRetry(`${this.base}/health`, { headers: this.headers() });
      return { ok: res.ok, message: res.ok ? "ok" : `provider unhealthy (${res.status})` };
    } catch (err) {
      return { ok: false, message: err?.message || "health check failed" };
    }
  }
  async getLatestBackup(campgroundId) {
    this.ensureConfigured();
    const res = await this.fetchWithRetry(`${this.base}/campgrounds/${campgroundId}/backups/latest`, {
      headers: this.headers()
    });
    if (!res.ok) {
      throw new ServiceUnavailableException3(`Backup provider error ${res.status}`);
    }
    return await res.json();
  }
  async runRestoreDrill(campgroundId) {
    this.ensureConfigured();
    const res = await this.fetchWithRetry(`${this.base}/campgrounds/${campgroundId}/backups/restore-check`, {
      method: "POST",
      headers: this.headers()
    });
    if (!res.ok) {
      const body = await res.text();
      throw new ServiceUnavailableException3(body || `Restore drill failed (${res.status})`);
    }
    return await res.json();
  }
};
var BackupService = class {
  constructor(prisma, provider) {
    this.prisma = prisma;
    this.provider = provider;
    this.statusByCampground = /* @__PURE__ */ new Map();
  }
  seedStatus(campgroundId, retentionDays) {
    const status = {
      campgroundId,
      lastBackupAt: null,
      lastBackupLocation: null,
      lastVerifiedAt: null,
      lastRestoreDrillAt: null,
      retentionDays,
      nextBackupDueAt: null,
      status: "missing",
      providerHealth: { ok: false, message: "No backup record found" },
      restoreSimulation: {
        status: "idle",
        lastRunAt: null,
        message: "No restore drill run"
      }
    };
    return status;
  }
  async resolveRetentionDays(campgroundId) {
    const privacySetting = await this.prisma.privacySetting?.findUnique?.({
      where: { campgroundId }
    });
    return privacySetting?.backupRetentionDays ?? 30;
  }
  async getStatus(campgroundId) {
    const retentionDays = await this.resolveRetentionDays(campgroundId);
    const health = await this.provider.healthCheck();
    const latest = await this.provider.getLatestBackup(campgroundId);
    if (!latest.lastBackupAt) {
      throw new ServiceUnavailableException3("No backup record found for campground");
    }
    const lastBackupAtDate = new Date(latest.lastBackupAt);
    const stale = Date.now() - lastBackupAtDate.getTime() > retentionDays * 24 * 60 * 60 * 1e3;
    const status = {
      campgroundId,
      lastBackupAt: latest.lastBackupAt,
      lastBackupLocation: latest.location,
      lastVerifiedAt: latest.verifiedAt,
      lastRestoreDrillAt: null,
      retentionDays,
      nextBackupDueAt: new Date(lastBackupAtDate.getTime() + retentionDays * 24 * 60 * 60 * 1e3).toISOString(),
      status: stale ? "stale" : "healthy",
      restoreSimulation: {
        status: "idle",
        lastRunAt: null,
        message: "No restore drill run"
      },
      providerHealth: health
    };
    this.statusByCampground.set(campgroundId, status);
    return status;
  }
  async simulateRestore(campgroundId) {
    const retentionDays = await this.resolveRetentionDays(campgroundId);
    const current = await this.getStatus(campgroundId);
    const now = /* @__PURE__ */ new Date();
    const drill = await this.provider.runRestoreDrill(campgroundId);
    if (!drill.ok) {
      throw new ServiceUnavailableException3(drill.message || "Restore drill failed");
    }
    const drillResult = {
      status: "ok",
      lastRunAt: drill.verifiedAt || now.toISOString(),
      message: drill.message || "Restore verification succeeded"
    };
    const updated = {
      ...current,
      retentionDays,
      lastRestoreDrillAt: drillResult.lastRunAt,
      lastVerifiedAt: drill.verifiedAt ?? current.lastVerifiedAt ?? current.lastBackupAt ?? drillResult.lastRunAt,
      restoreSimulation: drillResult,
      status: "healthy"
    };
    this.statusByCampground.set(campgroundId, updated);
    return {
      ...updated,
      startedAt: now.toISOString(),
      completedAt: now.toISOString()
    };
  }
};
BackupService = __decorateClass([
  (0, import_common232.Injectable)()
], BackupService);

// src/backup/backup.module.ts
var BackupModule = class {
};
BackupModule = __decorateClass([
  (0, import_common233.Module)({
    imports: [PermissionsModule],
    controllers: [BackupController],
    providers: [
      BackupService,
      PrismaService,
      {
        provide: BackupProvider,
        useFactory: () => new HttpBackupProvider()
      }
    ],
    exports: [BackupService, BackupProvider]
  })
], BackupModule);

// src/pricing-v2/pricing-v2.module.ts
var import_common235 = require("@nestjs/common");

// src/pricing-v2/pricing-v2.controller.ts
var import_common234 = require("@nestjs/common");
var import_client43 = require("@prisma/client");
var PricingV2Controller = class {
  constructor(pricing) {
    this.pricing = pricing;
  }
  list(campgroundId) {
    return this.pricing.list(campgroundId);
  }
  create(campgroundId, dto) {
    return this.pricing.create(campgroundId, dto);
  }
  update(id, dto) {
    return this.pricing.update(id, dto);
  }
  remove(id) {
    return this.pricing.remove(id);
  }
};
__decorateClass([
  Roles(import_client43.UserRole.owner, import_client43.UserRole.manager),
  (0, import_common234.Get)("campgrounds/:campgroundId/pricing-rules/v2"),
  __decorateParam(0, (0, import_common234.Param)("campgroundId"))
], PricingV2Controller.prototype, "list", 1);
__decorateClass([
  Roles(import_client43.UserRole.owner, import_client43.UserRole.manager),
  (0, import_common234.Post)("campgrounds/:campgroundId/pricing-rules/v2"),
  __decorateParam(0, (0, import_common234.Param)("campgroundId")),
  __decorateParam(1, (0, import_common234.Body)())
], PricingV2Controller.prototype, "create", 1);
__decorateClass([
  Roles(import_client43.UserRole.owner, import_client43.UserRole.manager),
  (0, import_common234.Patch)("pricing-rules/v2/:id"),
  __decorateParam(0, (0, import_common234.Param)("id")),
  __decorateParam(1, (0, import_common234.Body)())
], PricingV2Controller.prototype, "update", 1);
__decorateClass([
  Roles(import_client43.UserRole.owner, import_client43.UserRole.manager),
  (0, import_common234.Delete)("pricing-rules/v2/:id"),
  __decorateParam(0, (0, import_common234.Param)("id"))
], PricingV2Controller.prototype, "remove", 1);
PricingV2Controller = __decorateClass([
  (0, import_common234.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common234.Controller)()
], PricingV2Controller);

// src/pricing-v2/pricing-v2.module.ts
var PricingV2Module = class {
};
PricingV2Module = __decorateClass([
  (0, import_common235.Module)({
    imports: [AuditModule],
    controllers: [PricingV2Controller],
    providers: [PricingV2Service, PrismaService],
    exports: [PricingV2Service]
  })
], PricingV2Module);

// src/deposit-policies/deposit-policies.module.ts
var import_common237 = require("@nestjs/common");

// src/deposit-policies/deposit-policies.controller.ts
var import_common236 = require("@nestjs/common");
var import_client44 = require("@prisma/client");
var DepositPoliciesController = class {
  constructor(depositPolicies) {
    this.depositPolicies = depositPolicies;
  }
  list(campgroundId) {
    return this.depositPolicies.list(campgroundId);
  }
  create(campgroundId, dto) {
    return this.depositPolicies.create(campgroundId, dto);
  }
  update(id, dto) {
    return this.depositPolicies.update(id, dto);
  }
  remove(id) {
    return this.depositPolicies.remove(id);
  }
};
__decorateClass([
  Roles(import_client44.UserRole.owner, import_client44.UserRole.manager, import_client44.UserRole.finance),
  (0, import_common236.Get)("campgrounds/:campgroundId/deposit-policies"),
  __decorateParam(0, (0, import_common236.Param)("campgroundId"))
], DepositPoliciesController.prototype, "list", 1);
__decorateClass([
  Roles(import_client44.UserRole.owner, import_client44.UserRole.manager, import_client44.UserRole.finance),
  (0, import_common236.Post)("campgrounds/:campgroundId/deposit-policies"),
  __decorateParam(0, (0, import_common236.Param)("campgroundId")),
  __decorateParam(1, (0, import_common236.Body)())
], DepositPoliciesController.prototype, "create", 1);
__decorateClass([
  Roles(import_client44.UserRole.owner, import_client44.UserRole.manager, import_client44.UserRole.finance),
  (0, import_common236.Patch)("deposit-policies/:id"),
  __decorateParam(0, (0, import_common236.Param)("id")),
  __decorateParam(1, (0, import_common236.Body)())
], DepositPoliciesController.prototype, "update", 1);
__decorateClass([
  Roles(import_client44.UserRole.owner, import_client44.UserRole.manager, import_client44.UserRole.finance),
  (0, import_common236.Delete)("deposit-policies/:id"),
  __decorateParam(0, (0, import_common236.Param)("id"))
], DepositPoliciesController.prototype, "remove", 1);
DepositPoliciesController = __decorateClass([
  (0, import_common236.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common236.Controller)()
], DepositPoliciesController);

// src/deposit-policies/deposit-policies.module.ts
var DepositPoliciesModule = class {
};
DepositPoliciesModule = __decorateClass([
  (0, import_common237.Module)({
    imports: [AuditModule],
    controllers: [DepositPoliciesController],
    providers: [DepositPoliciesService, PrismaService],
    exports: [DepositPoliciesService]
  })
], DepositPoliciesModule);

// src/upsells/upsells.module.ts
var import_common240 = require("@nestjs/common");

// src/upsells/upsells.controller.ts
var import_common238 = require("@nestjs/common");
var import_client45 = require("@prisma/client");
var UpsellsController = class {
  constructor(upsells) {
    this.upsells = upsells;
  }
  list(campgroundId) {
    return this.upsells.list(campgroundId);
  }
  create(campgroundId, dto) {
    return this.upsells.create(campgroundId, dto);
  }
  update(id, dto) {
    return this.upsells.update(id, dto);
  }
  remove(id) {
    return this.upsells.remove(id);
  }
};
__decorateClass([
  Roles(import_client45.UserRole.owner, import_client45.UserRole.manager),
  (0, import_common238.Get)("campgrounds/:campgroundId/upsells"),
  __decorateParam(0, (0, import_common238.Param)("campgroundId"))
], UpsellsController.prototype, "list", 1);
__decorateClass([
  Roles(import_client45.UserRole.owner, import_client45.UserRole.manager),
  (0, import_common238.Post)("campgrounds/:campgroundId/upsells"),
  __decorateParam(0, (0, import_common238.Param)("campgroundId")),
  __decorateParam(1, (0, import_common238.Body)())
], UpsellsController.prototype, "create", 1);
__decorateClass([
  Roles(import_client45.UserRole.owner, import_client45.UserRole.manager),
  (0, import_common238.Patch)("upsells/:id"),
  __decorateParam(0, (0, import_common238.Param)("id")),
  __decorateParam(1, (0, import_common238.Body)())
], UpsellsController.prototype, "update", 1);
__decorateClass([
  Roles(import_client45.UserRole.owner, import_client45.UserRole.manager),
  (0, import_common238.Delete)("upsells/:id"),
  __decorateParam(0, (0, import_common238.Param)("id"))
], UpsellsController.prototype, "remove", 1);
UpsellsController = __decorateClass([
  (0, import_common238.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common238.Controller)()
], UpsellsController);

// src/upsells/upsells.service.ts
var import_common239 = require("@nestjs/common");
var UpsellsService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
  }
  list(campgroundId) {
    return this.prisma.upsellItem.findMany({
      where: { campgroundId },
      orderBy: [{ active: "desc" }, { createdAt: "desc" }]
    });
  }
  async create(campgroundId, dto, actorId) {
    const item = await this.prisma.upsellItem.create({
      data: {
        ...dto,
        campgroundId,
        siteClassId: dto.siteClassId ?? null,
        description: dto.description ?? null,
        taxCode: dto.taxCode ?? null,
        inventoryTracking: dto.inventoryTracking ?? false
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: actorId ?? null,
      action: "upsell_item.create",
      entity: "UpsellItem",
      entityId: item.id,
      before: null,
      after: item
    });
    return item;
  }
  async update(id, dto, actorId) {
    const existing = await this.prisma.upsellItem.findUnique({ where: { id } });
    if (!existing) throw new import_common239.NotFoundException("Upsell item not found");
    const updated = await this.prisma.upsellItem.update({
      where: { id },
      data: {
        ...dto,
        siteClassId: dto.siteClassId === void 0 ? void 0 : dto.siteClassId ?? null,
        description: dto.description === void 0 ? void 0 : dto.description ?? null,
        taxCode: dto.taxCode === void 0 ? void 0 : dto.taxCode ?? null,
        inventoryTracking: dto.inventoryTracking === void 0 ? void 0 : dto.inventoryTracking
      }
    });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "upsell_item.update",
      entity: "UpsellItem",
      entityId: id,
      before: existing,
      after: updated
    });
    return updated;
  }
  async remove(id, actorId) {
    const existing = await this.prisma.upsellItem.findUnique({ where: { id } });
    if (!existing) throw new import_common239.NotFoundException("Upsell item not found");
    await this.prisma.upsellItem.delete({ where: { id } });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: actorId ?? null,
      action: "upsell_item.delete",
      entity: "UpsellItem",
      entityId: id,
      before: existing,
      after: null
    });
    return existing;
  }
};
UpsellsService = __decorateClass([
  (0, import_common239.Injectable)()
], UpsellsService);

// src/upsells/upsells.module.ts
var UpsellsModule = class {
};
UpsellsModule = __decorateClass([
  (0, import_common240.Module)({
    imports: [AuditModule],
    controllers: [UpsellsController],
    providers: [UpsellsService, PrismaService],
    exports: [UpsellsService]
  })
], UpsellsModule);

// src/auto-collect/auto-collect.module.ts
var import_common242 = require("@nestjs/common");

// src/auto-collect/auto-collect.service.ts
var import_common241 = require("@nestjs/common");
var import_schedule13 = require("@nestjs/schedule");
var import_client46 = require("@prisma/client");
var AutoCollectService = class {
  constructor(prisma, idempotency, stripeService) {
    this.prisma = prisma;
    this.idempotency = idempotency;
    this.stripeService = stripeService;
    this.logger = new import_common241.Logger(AutoCollectService.name);
  }
  async processAutoCollects() {
    const now = /* @__PURE__ */ new Date();
    this.logger.log(`[AutoCollect] Starting sweep at ${now.toISOString()}`);
    const dueReservations = await this.prisma.reservation.findMany({
      where: {
        status: { in: [import_client46.ReservationStatus.pending, import_client46.ReservationStatus.confirmed] },
        balanceAmount: { gt: 0 },
        nextAutoCollectAttemptAt: { lte: now }
      },
      include: {
        campground: {
          select: {
            id: true,
            stripeAccountId: true,
            defaultDepositPolicyId: true,
            applicationFeeFlatCents: true,
            perBookingFeeCents: true
          }
        },
        site: {
          select: { siteClassId: true }
        }
      },
      take: 100
      // Process in batches
    });
    this.logger.log(`[AutoCollect] Found ${dueReservations.length} reservations due`);
    for (const reservation of dueReservations) {
      await this.attemptCollection(reservation);
    }
  }
  /**
   * Attempt to collect balance for a single reservation.
   */
  async attemptCollection(reservation) {
    const idempotencyKey = `auto-collect:${reservation.id}:${Date.now()}`;
    try {
      const existing = await this.idempotency.start(idempotencyKey, {
        reservationId: reservation.id,
        amountCents: reservation.balanceAmount
      }, reservation.campgroundId);
      if (existing.status === "succeeded") {
        this.logger.log(`[AutoCollect] Already processed ${reservation.id}`);
        return existing.responseJson;
      }
      const stripeAccountId = reservation.campground?.stripeAccountId;
      if (!stripeAccountId) {
        this.logger.warn(`[AutoCollect] No Stripe account for campground ${reservation.campgroundId}`);
        await this.scheduleNextAttempt(reservation, "no_stripe_account");
        return;
      }
      const policy = await this.getDepositPolicy(reservation);
      const retryPlan = policy?.retryPlanId ? await this.prisma.autoCollectSchedule.findUnique({ where: { id: policy.retryPlanId } }) : null;
      if (retryPlan?.cutoffHoursBeforeArrival) {
        const hoursUntilArrival = (reservation.arrivalDate.getTime() - Date.now()) / (1e3 * 60 * 60);
        if (hoursUntilArrival < retryPlan.cutoffHoursBeforeArrival) {
          this.logger.warn(`[AutoCollect] Past cutoff for ${reservation.id}, skipping`);
          await this.clearNextAttempt(reservation.id);
          await this.idempotency.complete(idempotencyKey, { status: "past_cutoff" });
          return;
        }
      }
      const applicationFeeCents = reservation.campground?.perBookingFeeCents ?? reservation.campground?.applicationFeeFlatCents ?? 200;
      const intent = await this.stripeService.createPaymentIntent(
        reservation.balanceAmount,
        "usd",
        {
          reservationId: reservation.id,
          campgroundId: reservation.campgroundId,
          source: "auto_collect",
          type: "balance_due"
        },
        stripeAccountId,
        applicationFeeCents,
        "automatic",
        ["card"],
        idempotencyKey
      );
      this.logger.log(`[AutoCollect] Created intent ${intent.id} for ${reservation.id}`);
      if (intent.status === "succeeded") {
        await this.recordSuccessfulPayment(reservation, intent);
        await this.idempotency.complete(idempotencyKey, {
          status: "succeeded",
          intentId: intent.id,
          amountCents: reservation.balanceAmount
        });
      } else {
        await this.scheduleNextAttempt(reservation, intent.status, retryPlan);
        await this.idempotency.complete(idempotencyKey, {
          status: "requires_action",
          intentId: intent.id
        });
      }
    } catch (error) {
      this.logger.error(`[AutoCollect] Failed for ${reservation.id}: ${error.message}`);
      await this.idempotency.fail(idempotencyKey);
      const policy = await this.getDepositPolicy(reservation);
      const retryPlan = policy?.retryPlanId ? await this.prisma.autoCollectSchedule.findUnique({ where: { id: policy.retryPlanId } }) : null;
      await this.scheduleNextAttempt(reservation, "error", retryPlan);
    }
  }
  async getDepositPolicy(reservation) {
    const siteClassId = reservation.site?.siteClassId;
    if (siteClassId) {
      const siteClassPolicy = await this.prisma.depositPolicy.findFirst({
        where: { campgroundId: reservation.campgroundId, siteClassId, active: true }
      });
      if (siteClassPolicy) return siteClassPolicy;
    }
    if (reservation.campground?.defaultDepositPolicyId) {
      return this.prisma.depositPolicy.findUnique({
        where: { id: reservation.campground.defaultDepositPolicyId }
      });
    }
    return this.prisma.depositPolicy.findFirst({
      where: { campgroundId: reservation.campgroundId, siteClassId: null, active: true }
    });
  }
  async recordSuccessfulPayment(reservation, intent) {
    const newPaid = (reservation.paidAmount ?? 0) + reservation.balanceAmount;
    await this.prisma.reservation.update({
      where: { id: reservation.id },
      data: {
        paidAmount: newPaid,
        balanceAmount: 0,
        paymentStatus: newPaid >= reservation.totalAmount ? "paid" : "partial",
        nextAutoCollectAttemptAt: null
      }
    });
    await this.prisma.payment.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        amountCents: reservation.balanceAmount,
        method: "card",
        direction: "charge",
        note: "Auto-collected balance",
        stripePaymentIntentId: intent.id
      }
    });
    await this.prisma.ledgerEntry.create({
      data: {
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        glCode: "CASH",
        account: "Cash",
        description: `Auto-collect ${intent.id}`,
        amountCents: reservation.balanceAmount,
        direction: "debit",
        occurredAt: /* @__PURE__ */ new Date()
      }
    });
    this.logger.log(`[AutoCollect] Successfully collected ${reservation.balanceAmount} cents for ${reservation.id}`);
  }
  async scheduleNextAttempt(reservation, reason, retryPlan) {
    const maxAttempts = retryPlan?.maxAttempts ?? 3;
    const backoffStrategy = retryPlan?.backoffStrategy ?? import_client46.BackoffStrategy.exponential;
    const baseDelayHours = retryPlan?.retryDelayHours ?? 24;
    const attemptCount = 1;
    if (attemptCount >= maxAttempts) {
      this.logger.warn(`[AutoCollect] Max attempts reached for ${reservation.id}`);
      await this.clearNextAttempt(reservation.id);
      return;
    }
    let delayHours;
    switch (backoffStrategy) {
      case import_client46.BackoffStrategy.exponential:
        delayHours = baseDelayHours * Math.pow(2, attemptCount - 1);
        break;
      case import_client46.BackoffStrategy.linear:
        delayHours = baseDelayHours * attemptCount;
        break;
      case import_client46.BackoffStrategy.fixed:
      default:
        delayHours = baseDelayHours;
    }
    const nextAttempt = new Date(Date.now() + delayHours * 60 * 60 * 1e3);
    await this.prisma.reservation.update({
      where: { id: reservation.id },
      data: { nextAutoCollectAttemptAt: nextAttempt }
    });
    this.logger.log(`[AutoCollect] Scheduled retry for ${reservation.id} at ${nextAttempt.toISOString()} (reason: ${reason})`);
  }
  async clearNextAttempt(reservationId) {
    await this.prisma.reservation.update({
      where: { id: reservationId },
      data: { nextAutoCollectAttemptAt: null }
    });
  }
  /**
   * Manual trigger for a specific reservation (e.g., from admin UI)
   */
  async runAttempt(reservationId, attemptNo, payload = {}) {
    const key = `auto-collect:${reservationId}:${attemptNo}`;
    const existing = await this.idempotency.start(key, payload, payload?.campgroundId);
    if (existing.status === "succeeded") {
      return existing.responseJson;
    }
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      include: {
        campground: { select: { id: true, stripeAccountId: true } },
        site: { select: { siteClassId: true } }
      }
    });
    if (!reservation) {
      await this.idempotency.fail(key);
      return { error: "Reservation not found" };
    }
    await this.attemptCollection(reservation);
    return { reservationId, attemptNo, status: "processed" };
  }
};
__decorateClass([
  (0, import_schedule13.Cron)(import_schedule13.CronExpression.EVERY_HOUR)
], AutoCollectService.prototype, "processAutoCollects", 1);
AutoCollectService = __decorateClass([
  (0, import_common241.Injectable)()
], AutoCollectService);

// src/auto-collect/auto-collect.module.ts
var AutoCollectModule = class {
};
AutoCollectModule = __decorateClass([
  (0, import_common242.Module)({
    providers: [AutoCollectService, PrismaService, IdempotencyService, StripeService],
    exports: [AutoCollectService]
  })
], AutoCollectModule);

// src/tasks/tasks.module.ts
var import_common245 = require("@nestjs/common");

// src/tasks/tasks.controller.ts
var import_common243 = require("@nestjs/common");
var TasksController = class {
  constructor(tasksService) {
    this.tasksService = tasksService;
  }
  create(createTaskDto) {
    return this.tasksService.create(createTaskDto);
  }
  findAll(tenantId, siteId, state, slaStatus, type, assignedToUserId) {
    return this.tasksService.findAll(tenantId, {
      siteId,
      state,
      slaStatus,
      type,
      assignedToUserId
    });
  }
  findOne(id) {
    return this.tasksService.findOne(id);
  }
  update(id, updateTaskDto) {
    return this.tasksService.update(id, updateTaskDto);
  }
  remove(id) {
    return this.tasksService.remove(id);
  }
};
__decorateClass([
  (0, import_common243.Post)(),
  __decorateParam(0, (0, import_common243.Body)())
], TasksController.prototype, "create", 1);
__decorateClass([
  (0, import_common243.Get)(),
  __decorateParam(0, (0, import_common243.Query)("tenantId")),
  __decorateParam(1, (0, import_common243.Query)("siteId")),
  __decorateParam(2, (0, import_common243.Query)("state")),
  __decorateParam(3, (0, import_common243.Query)("slaStatus")),
  __decorateParam(4, (0, import_common243.Query)("type")),
  __decorateParam(5, (0, import_common243.Query)("assignedToUserId"))
], TasksController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common243.Get)(":id"),
  __decorateParam(0, (0, import_common243.Param)("id"))
], TasksController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common243.Patch)(":id"),
  __decorateParam(0, (0, import_common243.Param)("id")),
  __decorateParam(1, (0, import_common243.Body)())
], TasksController.prototype, "update", 1);
__decorateClass([
  (0, import_common243.Delete)(":id"),
  __decorateParam(0, (0, import_common243.Param)("id"))
], TasksController.prototype, "remove", 1);
TasksController = __decorateClass([
  (0, import_common243.UseGuards)(JwtAuthGuard),
  (0, import_common243.Controller)("tasks")
], TasksController);

// src/tasks/tasks.service.ts
var import_common244 = require("@nestjs/common");
var TasksService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  /**
   * Compute SLA status based on current time vs due date
   */
  computeSlaStatus(slaDueAt, state) {
    if (!slaDueAt || state === "done" || state === "failed" || state === "expired") {
      return "on_track";
    }
    const now = Date.now();
    const due = slaDueAt.getTime();
    const remaining = due - now;
    if (remaining < 0) return "breached";
    const totalWindow = due - (due - 24 * 60 * 60 * 1e3);
    if (remaining < totalWindow * 0.3) return "at_risk";
    return "on_track";
  }
  async create(data) {
    const slaDueAt = data.slaDueAt ? new Date(data.slaDueAt) : null;
    const slaStatus = this.computeSlaStatus(slaDueAt, "pending");
    return this.prisma.task.create({
      data: {
        tenantId: data.tenantId,
        type: data.type,
        state: "pending",
        priority: data.priority,
        siteId: data.siteId,
        reservationId: data.reservationId,
        assignedToUserId: data.assignedToUserId,
        assignedToTeamId: data.assignedToTeamId,
        slaDueAt,
        slaStatus,
        checklist: data.checklist,
        notes: data.notes,
        source: data.source,
        createdBy: data.createdBy
      }
    });
  }
  async findAll(tenantId, filters) {
    return this.prisma.task.findMany({
      where: {
        tenantId,
        siteId: filters?.siteId,
        state: filters?.state,
        slaStatus: filters?.slaStatus,
        type: filters?.type,
        assignedToUserId: filters?.assignedToUserId
      },
      orderBy: [{ slaDueAt: "asc" }, { createdAt: "desc" }]
    });
  }
  async findOne(id) {
    return this.prisma.task.findUnique({ where: { id } });
  }
  async update(id, data) {
    const existing = await this.prisma.task.findUnique({ where: { id } });
    if (!existing) throw new Error("Task not found");
    const slaDueAt = data.slaDueAt ? new Date(data.slaDueAt) : existing.slaDueAt;
    const state = data.state ?? existing.state;
    const slaStatus = this.computeSlaStatus(slaDueAt, state);
    const updated = await this.prisma.task.update({
      where: { id },
      data: {
        state,
        priority: data.priority,
        slaDueAt,
        slaStatus,
        assignedToUserId: data.assignedToUserId,
        assignedToTeamId: data.assignedToTeamId,
        checklist: data.checklist,
        photos: data.photos,
        notes: data.notes
      }
    });
    if (updated.type === "turnover" && updated.state === "done" && updated.reservationId) {
      await this.markSiteReady(updated.reservationId);
    }
    return updated;
  }
  async markSiteReady(reservationId) {
    const reservation = await this.prisma.reservation.update({
      where: { id: reservationId },
      data: {
        siteReady: true,
        siteReadyAt: /* @__PURE__ */ new Date()
      },
      include: {
        guest: true,
        campground: true,
        site: true
      }
    });
    try {
      await this.prisma.communication.create({
        data: {
          campgroundId: reservation.campgroundId,
          guestId: reservation.guestId,
          reservationId: reservation.id,
          type: "email",
          subject: `Your site is ready at ${reservation.campground.name}`,
          body: `Good news! Site ${reservation.site.siteNumber} is now ready for your arrival.`,
          status: "queued",
          direction: "outbound"
        }
      });
    } catch (err) {
      console.error("Failed to create site-ready communication:", err);
    }
  }
  async remove(id) {
    return this.prisma.task.delete({ where: { id } });
  }
  /**
   * Cron job: update SLA statuses and expire overdue pending tasks
   */
  async sweepSlaStatuses() {
    const pendingTasks = await this.prisma.task.findMany({
      where: { state: { in: ["pending", "in_progress"] } }
    });
    for (const task of pendingTasks) {
      const newStatus = this.computeSlaStatus(task.slaDueAt, task.state);
      const shouldExpire = task.state === "pending" && task.slaDueAt && task.slaDueAt.getTime() < Date.now();
      await this.prisma.task.update({
        where: { id: task.id },
        data: {
          slaStatus: newStatus,
          state: shouldExpire ? "expired" : task.state
        }
      });
    }
  }
};
TasksService = __decorateClass([
  (0, import_common244.Injectable)()
], TasksService);

// src/tasks/tasks.module.ts
var TasksModule = class {
};
TasksModule = __decorateClass([
  (0, import_common245.Module)({
    imports: [PrismaModule],
    controllers: [TasksController],
    providers: [TasksService],
    exports: [TasksService]
  })
], TasksModule);

// src/self-checkin/self-checkin.module.ts
var import_common248 = require("@nestjs/common");

// src/self-checkin/self-checkin.controller.ts
var import_common246 = require("@nestjs/common");
var SelfCheckinController = class {
  constructor(selfCheckinService) {
    this.selfCheckinService = selfCheckinService;
  }
  getStatus(id) {
    return this.selfCheckinService.getStatus(id);
  }
  selfCheckin(id, body) {
    return this.selfCheckinService.selfCheckin(id, body);
  }
  selfCheckout(id, body) {
    return this.selfCheckinService.selfCheckout(id, body);
  }
};
__decorateClass([
  (0, import_common246.Get)("checkin-status"),
  __decorateParam(0, (0, import_common246.Param)("id"))
], SelfCheckinController.prototype, "getStatus", 1);
__decorateClass([
  (0, import_common246.Post)("self-checkin"),
  __decorateParam(0, (0, import_common246.Param)("id")),
  __decorateParam(1, (0, import_common246.Body)())
], SelfCheckinController.prototype, "selfCheckin", 1);
__decorateClass([
  (0, import_common246.UseGuards)(JwtAuthGuard),
  (0, import_common246.Post)("self-checkout"),
  __decorateParam(0, (0, import_common246.Param)("id")),
  __decorateParam(1, (0, import_common246.Body)())
], SelfCheckinController.prototype, "selfCheckout", 1);
SelfCheckinController = __decorateClass([
  (0, import_common246.Controller)("reservations/:id")
], SelfCheckinController);

// src/self-checkin/self-checkin.service.ts
var import_common247 = require("@nestjs/common");
var import_client47 = require("@prisma/client");
var SelfCheckinService = class {
  constructor(prisma, signatures, audit, accessControl) {
    this.prisma = prisma;
    this.signatures = signatures;
    this.audit = audit;
    this.accessControl = accessControl;
  }
  async attachWaiverArtifacts(reservationId, guestId, evidence) {
    const ops = [];
    if (evidence.request && (!evidence.request.reservationId || !evidence.request.guestId)) {
      ops.push(
        this.prisma.signatureRequest?.update?.({
          where: { id: evidence.request.id },
          data: {
            reservationId: evidence.request.reservationId ?? reservationId,
            guestId: evidence.request.guestId ?? guestId
          }
        })
      );
    }
    if (evidence.artifact && (!evidence.artifact.reservationId || !evidence.artifact.guestId)) {
      ops.push(
        this.prisma.signatureArtifact?.update?.({
          where: { id: evidence.artifact.id },
          data: {
            reservationId: evidence.artifact.reservationId ?? reservationId,
            guestId: evidence.artifact.guestId ?? guestId
          }
        })
      );
    }
    if (evidence.digital && (!evidence.digital.reservationId || !evidence.digital.guestId)) {
      ops.push(
        this.prisma.digitalWaiver?.update?.({
          where: { id: evidence.digital.id },
          data: {
            reservationId: evidence.digital.reservationId ?? reservationId,
            guestId: evidence.digital.guestId ?? guestId
          }
        })
      );
    }
    if (ops.length) {
      try {
        await Promise.all(ops);
      } catch (err) {
        console.warn("Failed to attach waiver artifacts to reservation", err);
      }
    }
  }
  async hasSignedWaiver(reservationId, guestId) {
    const [signedRequest, digitalWaiver] = await Promise.all([
      this.prisma.signatureRequest.findFirst?.({
        where: {
          documentType: "waiver",
          status: "signed",
          OR: [{ reservationId }, { reservationId: null, guestId }]
        },
        include: { artifact: true },
        orderBy: { signedAt: "desc" }
      }),
      this.prisma.digitalWaiver.findFirst?.({
        where: {
          OR: [{ reservationId }, { reservationId: null, guestId }],
          status: "signed"
        },
        orderBy: { signedAt: "desc" }
      })
    ]);
    const signedArtifact = signedRequest?.artifact ?? await this.prisma.signatureArtifact?.findFirst?.({
      where: {
        pdfUrl: { not: null },
        OR: [{ reservationId }, { reservationId: null, guestId }]
      }
    });
    const hasEvidence = Boolean(signedRequest || signedArtifact || digitalWaiver);
    if (hasEvidence) {
      await this.attachWaiverArtifacts(reservationId, guestId, {
        request: signedRequest ?? void 0,
        artifact: signedArtifact ?? void 0,
        digital: digitalWaiver ?? void 0
      });
    }
    return hasEvidence;
  }
  async attachIdVerification(reservationId, guestId, match) {
    if (!match || match.reservationId && match.guestId) return;
    try {
      await this.prisma.idVerification?.update?.({
        where: { id: match.id },
        data: {
          reservationId: match.reservationId ?? reservationId,
          guestId: match.guestId ?? guestId
        }
      });
    } catch (err) {
      console.warn("Failed to attach ID verification to reservation", err);
    }
  }
  async hasVerifiedId(reservationId, guestId) {
    const now = /* @__PURE__ */ new Date();
    const match = await this.prisma.idVerification.findFirst?.({
      where: {
        status: "verified",
        OR: [
          { reservationId },
          {
            guestId,
            OR: [{ expiresAt: null }, { expiresAt: { gt: now } }]
          }
        ]
      },
      orderBy: { verifiedAt: "desc" }
    });
    if (match) {
      await this.attachIdVerification(reservationId, guestId, match);
      return true;
    }
    return false;
  }
  /**
   * Validate prerequisites for self check-in
   */
  async validateCheckinPrerequisites(reservationId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      include: { site: true, guest: true, campground: true }
    });
    if (!reservation) {
      return { valid: false, reason: "reservation_not_found", reasons: ["reservation_not_found"] };
    }
    const reasons = [];
    if (reservation.paymentRequired && reservation.paymentStatus !== "paid") {
      reasons.push("payment_required");
    }
    if (reservation.idVerificationRequired) {
      const verified = await this.hasVerifiedId(reservation.id, reservation.guestId);
      if (!verified) reasons.push("id_verification_required");
    }
    if (reservation.waiverRequired) {
      const signed = await this.hasSignedWaiver(reservation.id, reservation.guestId);
      if (!signed) reasons.push("waiver_required");
    }
    if (!reservation.siteReady) {
      reasons.push("site_not_ready");
    }
    const outOfOrderTicket = await this.prisma.maintenanceTicket.findFirst({
      where: {
        siteId: reservation.siteId,
        outOfOrder: true,
        status: { notIn: ["closed"] }
      }
    });
    if (outOfOrderTicket) {
      reasons.push("site_out_of_order");
    }
    if (reasons.length) {
      return { valid: false, reason: reasons[0], reasons, reservation };
    }
    return { valid: true, reservation };
  }
  /**
   * Perform self check-in
   */
  async selfCheckin(reservationId, options) {
    const validation = await this.validateCheckinPrerequisites(reservationId);
    const isOverride = Boolean(options?.override);
    if (!validation.valid && !isOverride) {
      const reservation2 = validation.reservation ?? await this.prisma.reservation.findUnique({
        where: { id: reservationId },
        include: { campground: true, guest: true }
      });
      const checkInStatus = validation.reason === "waiver_required" ? import_client47.CheckInStatus.pending_waiver : validation.reason === "id_verification_required" ? import_client47.CheckInStatus.pending_id : validation.reason === "payment_required" ? import_client47.CheckInStatus.pending_payment : import_client47.CheckInStatus.failed;
      const updatedReservation = reservation2 ? await this.prisma.reservation.update({
        where: { id: reservationId },
        data: { checkInStatus },
        include: { campground: true, guest: true }
      }) : null;
      let signingUrl;
      if (validation.reason === "waiver_required" && validation.reservation) {
        const signatureResult = await this.signatures.autoSendForReservation(validation.reservation);
        signingUrl = signatureResult?.signingUrl;
      }
      try {
        if (updatedReservation) {
          await this.prisma.communication.create({
            data: {
              campgroundId: updatedReservation.campgroundId,
              guestId: updatedReservation.guestId,
              reservationId: updatedReservation.id,
              type: "email",
              subject: `Check-in issue at ${updatedReservation.campground.name}`,
              body: `We couldn't complete your check-in. Reason: ${validation.reason?.replace("_", " ")}. Please contact the front desk.`,
              status: "queued",
              direction: "outbound"
            }
          });
        }
      } catch (err) {
        console.error("Failed to create checkin-failed communication:", err);
      }
      return { status: "failed", reason: validation.reason, signingUrl };
    }
    if (isOverride && !validation.valid && validation.reservation) {
      try {
        await this.audit.record({
          campgroundId: validation.reservation.campgroundId,
          actorId: options?.actorId ?? null,
          action: "checkin.override",
          entity: "Reservation",
          entityId: reservationId,
          before: { unmet: validation.reasons ?? [] },
          after: { override: true, reason: options?.overrideReason ?? null }
        });
      } catch (err) {
        console.error("Failed to audit check-in override", err);
      }
    }
    const now = /* @__PURE__ */ new Date();
    const reservation = await this.prisma.reservation.update({
      where: { id: reservationId },
      data: {
        checkInStatus: import_client47.CheckInStatus.completed,
        selfCheckInAt: now,
        lateArrivalFlag: options?.lateArrival ?? false,
        status: "checked_in"
      },
      include: { campground: true, guest: true, site: true }
    });
    try {
      await this.accessControl.autoGrantForReservation(reservationId, options?.actorId ?? null);
    } catch (err) {
      console.error("Failed to auto-grant access on self-checkin", err);
    }
    try {
      await this.prisma.communication.create({
        data: {
          campgroundId: reservation.campgroundId,
          guestId: reservation.guestId,
          reservationId: reservation.id,
          type: "email",
          subject: `Welcome to ${reservation.campground.name}!`,
          body: `You're all checked in to site ${reservation.site.siteNumber}. Enjoy your stay!`,
          status: "queued",
          direction: "outbound"
        }
      });
    } catch (err) {
      console.error("Failed to create checkin-success communication:", err);
    }
    return { status: "completed", selfCheckInAt: now };
  }
  /**
   * Perform self checkout
   */
  async selfCheckout(reservationId, options) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId }
    });
    if (!reservation) {
      return { status: "failed", reason: "reservation_not_found" };
    }
    if (reservation.balanceAmount > 0 && !options?.override) {
      await this.prisma.reservation.update({
        where: { id: reservationId },
        data: { checkOutStatus: "failed" }
      });
      return { status: "failed", reason: "payment_capture_failed" };
    }
    const now = /* @__PURE__ */ new Date();
    const updatedReservation = await this.prisma.reservation.update({
      where: { id: reservationId },
      data: {
        checkOutStatus: "completed",
        selfCheckOutAt: now,
        status: "checked_out"
      },
      include: { campground: true, guest: true, site: true }
    });
    try {
      await this.accessControl.revokeAllForReservation(reservationId, "checked_out", options?.actorId ?? null);
    } catch (err) {
      console.error("Failed to revoke access on self-checkout", err);
    }
    try {
      await this.prisma.communication.create({
        data: {
          campgroundId: updatedReservation.campgroundId,
          guestId: updatedReservation.guestId,
          reservationId: updatedReservation.id,
          type: "email",
          subject: `Thank you for staying at ${updatedReservation.campground.name}!`,
          body: `You've successfully checked out. Final charges: $${(updatedReservation.totalAmount / 100).toFixed(2)}. We hope to see you again!`,
          status: "queued",
          direction: "outbound"
        }
      });
    } catch (err) {
      console.error("Failed to create checkout-success communication:", err);
    }
    if (options?.damageNotes || options?.damagePhotos?.length) {
      try {
        await this.prisma.task.create({
          data: {
            tenantId: updatedReservation.campgroundId,
            type: "inspection",
            state: "pending",
            siteId: updatedReservation.siteId,
            reservationId: updatedReservation.id,
            slaStatus: "on_track",
            notes: `Damage reported: ${options.damageNotes || "See photos"}`,
            photos: options.damagePhotos ? JSON.stringify(options.damagePhotos) : void 0,
            source: "auto_turnover",
            createdBy: "system"
          }
        });
      } catch (err) {
        console.error("Failed to create damage inspection task:", err);
      }
    }
    return { status: "completed", selfCheckOutAt: now };
  }
  /**
   * Get check-in/out status for a reservation
   */
  async getStatus(reservationId) {
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: {
        id: true,
        checkInStatus: true,
        checkOutStatus: true,
        siteReady: true,
        siteReadyAt: true,
        selfCheckInAt: true,
        selfCheckOutAt: true,
        idVerificationRequired: true,
        waiverRequired: true,
        paymentRequired: true,
        lateArrivalFlag: true,
        paymentStatus: true,
        balanceAmount: true
      }
    });
    if (!reservation) {
      throw new import_common247.BadRequestException("Reservation not found");
    }
    return reservation;
  }
};
SelfCheckinService = __decorateClass([
  (0, import_common247.Injectable)()
], SelfCheckinService);

// src/self-checkin/self-checkin.module.ts
var SelfCheckinModule = class {
};
SelfCheckinModule = __decorateClass([
  (0, import_common248.Module)({
    imports: [PrismaModule, SignaturesModule, AuditModule, AccessControlModule],
    controllers: [SelfCheckinController],
    providers: [SelfCheckinService],
    exports: [SelfCheckinService]
  })
], SelfCheckinModule);

// src/groups/groups.module.ts
var import_common253 = require("@nestjs/common");

// src/groups/groups.controller.ts
var import_common249 = require("@nestjs/common");
var GroupsController = class {
  constructor(groupsService) {
    this.groupsService = groupsService;
  }
  create(createGroupDto) {
    return this.groupsService.create(createGroupDto);
  }
  findAll(tenantId) {
    return this.groupsService.findAll(tenantId);
  }
  findOne(id) {
    return this.groupsService.findOne(id);
  }
  update(id, updateGroupDto) {
    return this.groupsService.update(id, updateGroupDto);
  }
  remove(id) {
    return this.groupsService.remove(id);
  }
};
__decorateClass([
  (0, import_common249.Post)(),
  __decorateParam(0, (0, import_common249.Body)())
], GroupsController.prototype, "create", 1);
__decorateClass([
  (0, import_common249.Get)(),
  __decorateParam(0, (0, import_common249.Query)("tenantId"))
], GroupsController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common249.Get)(":id"),
  __decorateParam(0, (0, import_common249.Param)("id"))
], GroupsController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common249.Patch)(":id"),
  __decorateParam(0, (0, import_common249.Param)("id")),
  __decorateParam(1, (0, import_common249.Body)())
], GroupsController.prototype, "update", 1);
__decorateClass([
  (0, import_common249.Delete)(":id"),
  __decorateParam(0, (0, import_common249.Param)("id"))
], GroupsController.prototype, "remove", 1);
GroupsController = __decorateClass([
  (0, import_common249.UseGuards)(JwtAuthGuard),
  (0, import_common249.Controller)("groups")
], GroupsController);

// src/groups/groups.service.ts
var import_common250 = require("@nestjs/common");
var GroupsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async create(data) {
    const group = await this.prisma.group.create({
      data: {
        tenantId: data.tenantId,
        sharedPayment: data.sharedPayment ?? false,
        sharedComm: data.sharedComm ?? false,
        primaryReservationId: data.primaryReservationId
      }
    });
    if (data.reservationIds?.length) {
      await this.prisma.reservation.updateMany({
        where: { id: { in: data.reservationIds } },
        data: {
          groupId: group.id,
          groupRole: "member"
        }
      });
      if (data.primaryReservationId) {
        await this.prisma.reservation.update({
          where: { id: data.primaryReservationId },
          data: { groupRole: "primary" }
        });
      }
    }
    return this.findOne(group.id);
  }
  async findAll(tenantId) {
    const groups = await this.prisma.group.findMany({
      where: { tenantId },
      orderBy: { createdAt: "desc" }
    });
    const enriched = await Promise.all(
      groups.map(async (group) => {
        const count = await this.prisma.reservation.count({
          where: { groupId: group.id }
        });
        return { ...group, reservationCount: count };
      })
    );
    return enriched;
  }
  async findOne(id) {
    const group = await this.prisma.group.findUnique({
      where: { id }
    });
    if (!group) return null;
    const reservations = await this.prisma.reservation.findMany({
      where: { groupId: id },
      select: {
        id: true,
        groupRole: true,
        arrivalDate: true,
        departureDate: true,
        status: true,
        guestId: true,
        siteId: true
      }
    });
    const guestIds = reservations.map((r) => r.guestId);
    const siteIds = reservations.map((r) => r.siteId);
    const guests = await this.prisma.guest.findMany({
      where: { id: { in: guestIds } },
      select: { id: true, primaryFirstName: true, primaryLastName: true, email: true }
    });
    const sites = await this.prisma.site.findMany({
      where: { id: { in: siteIds } },
      select: { id: true, name: true, siteNumber: true }
    });
    const guestMap = new Map(guests.map((g) => [g.id, g]));
    const siteMap = new Map(sites.map((s) => [s.id, s]));
    const enrichedReservations = reservations.map((r) => ({
      ...r,
      guest: guestMap.get(r.guestId),
      site: siteMap.get(r.siteId)
    }));
    return { ...group, reservations: enrichedReservations };
  }
  async update(id, data) {
    await this.prisma.group.update({
      where: { id },
      data: {
        sharedPayment: data.sharedPayment,
        sharedComm: data.sharedComm
      }
    });
    if (data.addReservationIds?.length) {
      await this.prisma.reservation.updateMany({
        where: { id: { in: data.addReservationIds } },
        data: {
          groupId: id,
          groupRole: "member"
        }
      });
    }
    if (data.removeReservationIds?.length) {
      await this.prisma.reservation.updateMany({
        where: { id: { in: data.removeReservationIds } },
        data: {
          groupId: null,
          groupRole: null
        }
      });
    }
    return this.findOne(id);
  }
  async remove(id) {
    await this.prisma.reservation.updateMany({
      where: { groupId: id },
      data: { groupId: null, groupRole: null }
    });
    return this.prisma.group.delete({ where: { id } });
  }
};
GroupsService = __decorateClass([
  (0, import_common250.Injectable)()
], GroupsService);

// src/groups/blocks.controller.ts
var import_common251 = require("@nestjs/common");
var BlocksController = class {
  constructor(blocksService) {
    this.blocksService = blocksService;
  }
  create(createBlockDto) {
    return this.blocksService.create(createBlockDto);
  }
  findAll(tenantId, state) {
    return this.blocksService.findAll(tenantId, state);
  }
  findOne(blockId) {
    return this.blocksService.findOne(blockId);
  }
  update(blockId, updateBlockDto) {
    return this.blocksService.update(blockId, updateBlockDto);
  }
  release(blockId) {
    return this.blocksService.release(blockId);
  }
  remove(blockId) {
    return this.blocksService.remove(blockId);
  }
};
__decorateClass([
  (0, import_common251.Post)(),
  __decorateParam(0, (0, import_common251.Body)())
], BlocksController.prototype, "create", 1);
__decorateClass([
  (0, import_common251.Get)(),
  __decorateParam(0, (0, import_common251.Query)("tenantId")),
  __decorateParam(1, (0, import_common251.Query)("state"))
], BlocksController.prototype, "findAll", 1);
__decorateClass([
  (0, import_common251.Get)(":blockId"),
  __decorateParam(0, (0, import_common251.Param)("blockId"))
], BlocksController.prototype, "findOne", 1);
__decorateClass([
  (0, import_common251.Patch)(":blockId"),
  __decorateParam(0, (0, import_common251.Param)("blockId")),
  __decorateParam(1, (0, import_common251.Body)())
], BlocksController.prototype, "update", 1);
__decorateClass([
  (0, import_common251.Patch)(":blockId/release"),
  __decorateParam(0, (0, import_common251.Param)("blockId"))
], BlocksController.prototype, "release", 1);
__decorateClass([
  (0, import_common251.Delete)(":blockId"),
  __decorateParam(0, (0, import_common251.Param)("blockId"))
], BlocksController.prototype, "remove", 1);
BlocksController = __decorateClass([
  (0, import_common251.UseGuards)(JwtAuthGuard),
  (0, import_common251.Controller)("blocks")
], BlocksController);

// src/groups/blocks.service.ts
var import_common252 = require("@nestjs/common");
var BlocksService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  /**
   * Check for availability conflicts with existing reservations or blocks
   */
  async checkConflicts(tenantId, siteIds, windowStart, windowEnd, excludeBlockId) {
    const conflictingReservations = await this.prisma.reservation.findMany({
      where: {
        siteId: { in: siteIds },
        status: { in: ["confirmed", "checked_in"] },
        arrivalDate: { lt: windowEnd },
        departureDate: { gt: windowStart }
      },
      select: { siteId: true }
    });
    const conflictingBlocks = await this.prisma.inventoryBlock.findMany({
      where: {
        tenantId,
        state: "active",
        windowStart: { lt: windowEnd },
        windowEnd: { gt: windowStart },
        blockId: excludeBlockId ? { not: excludeBlockId } : void 0
      }
    });
    const conflictingSitesFromBlocks = conflictingBlocks.flatMap((b) => b.sites || []).filter((s) => siteIds.includes(s));
    const allConflicts = [
      .../* @__PURE__ */ new Set([
        ...conflictingReservations.map((r) => r.siteId),
        ...conflictingSitesFromBlocks
      ])
    ];
    return {
      hasConflict: allConflicts.length > 0,
      conflictingSites: allConflicts
    };
  }
  async create(data) {
    const windowStart = new Date(data.windowStart);
    const windowEnd = new Date(data.windowEnd);
    const conflicts = await this.checkConflicts(
      data.tenantId,
      data.sites,
      windowStart,
      windowEnd
    );
    if (conflicts.hasConflict) {
      throw new import_common252.ConflictException({
        error: "conflict",
        sites: conflicts.conflictingSites,
        window: { start: windowStart, end: windowEnd }
      });
    }
    const existing = await this.prisma.inventoryBlock.findUnique({
      where: { lockId: data.lockId }
    });
    if (existing) {
      return existing;
    }
    return this.prisma.inventoryBlock.create({
      data: {
        tenantId: data.tenantId,
        sites: data.sites,
        windowStart,
        windowEnd,
        reason: data.reason,
        state: "active",
        lockId: data.lockId,
        createdBy: data.createdBy
      }
    });
  }
  async findAll(tenantId, state) {
    return this.prisma.inventoryBlock.findMany({
      where: {
        tenantId,
        state
      },
      orderBy: { createdAt: "desc" }
    });
  }
  async findOne(blockId) {
    return this.prisma.inventoryBlock.findUnique({ where: { blockId } });
  }
  async update(blockId, data) {
    const existing = await this.prisma.inventoryBlock.findUnique({
      where: { blockId }
    });
    if (!existing) {
      throw new Error("Block not found");
    }
    if (data.windowStart || data.windowEnd) {
      const newStart = data.windowStart ? new Date(data.windowStart) : existing.windowStart;
      const newEnd = data.windowEnd ? new Date(data.windowEnd) : existing.windowEnd;
      const conflicts = await this.checkConflicts(
        existing.tenantId,
        existing.sites,
        newStart,
        newEnd,
        blockId
      );
      if (conflicts.hasConflict) {
        throw new import_common252.ConflictException({
          error: "conflict",
          sites: conflicts.conflictingSites,
          window: { start: newStart, end: newEnd }
        });
      }
    }
    return this.prisma.inventoryBlock.update({
      where: { blockId },
      data: {
        state: data.state,
        windowStart: data.windowStart ? new Date(data.windowStart) : void 0,
        windowEnd: data.windowEnd ? new Date(data.windowEnd) : void 0,
        reason: data.reason
      }
    });
  }
  async release(blockId) {
    return this.prisma.inventoryBlock.update({
      where: { blockId },
      data: { state: "released" }
    });
  }
  async remove(blockId) {
    return this.prisma.inventoryBlock.delete({ where: { blockId } });
  }
};
BlocksService = __decorateClass([
  (0, import_common252.Injectable)()
], BlocksService);

// src/groups/groups.module.ts
var GroupsModule = class {
};
GroupsModule = __decorateClass([
  (0, import_common253.Module)({
    imports: [PrismaModule],
    controllers: [GroupsController, BlocksController],
    providers: [GroupsService, BlocksService],
    exports: [GroupsService, BlocksService]
  })
], GroupsModule);

// src/notification-triggers/notification-triggers.module.ts
var import_common256 = require("@nestjs/common");

// src/notification-triggers/notification-triggers.controller.ts
var import_common254 = require("@nestjs/common");
var import_client48 = require("@prisma/client");
var NotificationTriggersController = class {
  constructor(service) {
    this.service = service;
  }
  list(campgroundId) {
    return this.service.list(campgroundId);
  }
  create(campgroundId, body) {
    return this.service.create(campgroundId, body);
  }
  update(id, body) {
    return this.service.update(id, body);
  }
  delete(id) {
    return this.service.delete(id);
  }
};
__decorateClass([
  Roles(import_client48.UserRole.owner, import_client48.UserRole.manager),
  (0, import_common254.Get)(),
  __decorateParam(0, (0, import_common254.Param)("campgroundId"))
], NotificationTriggersController.prototype, "list", 1);
__decorateClass([
  Roles(import_client48.UserRole.owner, import_client48.UserRole.manager),
  (0, import_common254.Post)(),
  __decorateParam(0, (0, import_common254.Param)("campgroundId")),
  __decorateParam(1, (0, import_common254.Body)())
], NotificationTriggersController.prototype, "create", 1);
__decorateClass([
  Roles(import_client48.UserRole.owner, import_client48.UserRole.manager),
  (0, import_common254.Patch)(":id"),
  __decorateParam(0, (0, import_common254.Param)("id")),
  __decorateParam(1, (0, import_common254.Body)())
], NotificationTriggersController.prototype, "update", 1);
__decorateClass([
  Roles(import_client48.UserRole.owner, import_client48.UserRole.manager),
  (0, import_common254.Delete)(":id"),
  __decorateParam(0, (0, import_common254.Param)("id"))
], NotificationTriggersController.prototype, "delete", 1);
NotificationTriggersController = __decorateClass([
  (0, import_common254.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common254.Controller)("campgrounds/:campgroundId/notification-triggers")
], NotificationTriggersController);

// src/notification-triggers/notification-triggers.service.ts
var import_common255 = require("@nestjs/common");
var import_schedule14 = require("@nestjs/schedule");
var NotificationTriggersService = class {
  constructor(prisma, emailService, smsService) {
    this.prisma = prisma;
    this.emailService = emailService;
    this.smsService = smsService;
    this.logger = new import_common255.Logger(NotificationTriggersService.name);
  }
  /**
   * Get all triggers for a campground
   */
  async list(campgroundId) {
    return this.prisma.notificationTrigger.findMany({
      where: { campgroundId },
      orderBy: [{ event: "asc" }, { createdAt: "desc" }],
      include: { template: true }
    });
  }
  /**
   * Create a new trigger
   */
  async create(campgroundId, data) {
    return this.prisma.notificationTrigger.create({
      data: {
        campgroundId,
        event: data.event,
        channel: data.channel,
        enabled: data.enabled ?? true,
        templateId: data.templateId ?? null,
        delayMinutes: data.delayMinutes ?? 0,
        conditions: data.conditions ?? null
      }
    });
  }
  /**
   * Update a trigger
   */
  async update(id, data) {
    return this.prisma.notificationTrigger.update({
      where: { id },
      data: {
        ...data,
        conditions: data.conditions
      }
    });
  }
  /**
   * Delete a trigger
   */
  async delete(id) {
    return this.prisma.notificationTrigger.delete({
      where: { id }
    });
  }
  /**
   * Fire a trigger event
   */
  async fire(event, payload) {
    this.logger.log(`Firing trigger event: ${event} for campground ${payload.campgroundId}`);
    const triggers = await this.prisma.notificationTrigger.findMany({
      where: {
        campgroundId: payload.campgroundId,
        event,
        enabled: true
      },
      include: { template: true }
    });
    if (triggers.length === 0) {
      this.logger.debug(`No triggers configured for event ${event}`);
      return { fired: 0 };
    }
    let fired = 0;
    for (const trigger of triggers) {
      if (trigger.conditions && !this.matchesConditions(trigger.conditions, payload)) {
        continue;
      }
      if (trigger.delayMinutes > 0) {
        await this.scheduleNotification(trigger, payload);
      } else {
        await this.sendNotification(trigger, payload);
      }
      fired++;
    }
    return { fired };
  }
  /**
   * Check if payload matches trigger conditions
   */
  matchesConditions(conditions, payload) {
    for (const [key, value] of Object.entries(conditions)) {
      const payloadValue = payload[key] ?? payload.customData?.[key];
      if (typeof value === "object" && value !== null) {
        if (value.gt !== void 0 && !(payloadValue > value.gt)) return false;
        if (value.lt !== void 0 && !(payloadValue < value.lt)) return false;
        if (value.eq !== void 0 && payloadValue !== value.eq) return false;
        if (value.in !== void 0 && !value.in.includes(payloadValue)) return false;
      } else if (payloadValue !== value) {
        return false;
      }
    }
    return true;
  }
  /**
   * Schedule a notification for later
   */
  async scheduleNotification(trigger, payload) {
    const sendAt = new Date(Date.now() + trigger.delayMinutes * 60 * 1e3);
    await this.prisma.scheduledNotification.create({
      data: {
        campgroundId: payload.campgroundId,
        triggerId: trigger.id,
        event: trigger.event,
        channel: trigger.channel,
        payload,
        sendAt,
        status: "pending"
      }
    });
    this.logger.log(`Scheduled notification for ${sendAt.toISOString()}`);
  }
  /**
   * Send a notification immediately
   */
  async sendNotification(trigger, payload) {
    const template = trigger.template;
    if (!payload.guestEmail) {
      this.logger.warn(`Cannot send notification: no guest email provided`);
      return;
    }
    const campground = await this.prisma.campground.findUnique({
      where: { id: payload.campgroundId },
      select: { name: true }
    });
    const subject = template?.subject ? this.interpolate(template.subject, payload, campground) : this.getDefaultSubject(trigger.event, campground?.name);
    const html = template?.html ? this.interpolate(template.html, payload, campground) : this.getDefaultHtml(trigger.event, payload, campground?.name);
    if (trigger.channel === "email" || trigger.channel === "both") {
      await this.emailService.sendEmail({
        to: payload.guestEmail,
        subject,
        html,
        campgroundId: payload.campgroundId,
        reservationId: payload.reservationId,
        guestId: payload.guestId
      });
    }
    if ((trigger.channel === "sms" || trigger.channel === "both") && payload.customData?.phone) {
      const smsBody = this.stripHtml(html).substring(0, 160);
      const result = await this.smsService.sendSms({
        to: payload.customData.phone,
        body: smsBody,
        campgroundId: payload.campgroundId,
        reservationId: payload.reservationId
      });
      if (!result.success) {
        this.logger.warn(`SMS send returned: ${result.fallback || result.provider}`);
      }
    }
    this.logger.log(`Sent ${trigger.channel} notification for ${trigger.event}`);
  }
  /**
   * Strip HTML tags for SMS
   */
  stripHtml(html) {
    return html.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
  }
  /**
   * Interpolate template variables
   */
  interpolate(template, payload, campground) {
    const vars = {
      "{{guest_name}}": payload.guestName || "Guest",
      "{{campground_name}}": campground?.name || "our campground",
      "{{site_number}}": payload.siteNumber || "",
      "{{arrival_date}}": payload.arrivalDate?.toLocaleDateString() || "",
      "{{departure_date}}": payload.departureDate?.toLocaleDateString() || "",
      "{{amount}}": payload.amountCents ? `$${(payload.amountCents / 100).toFixed(2)}` : "",
      "{{reservation_id}}": payload.reservationId || ""
    };
    let result = template;
    for (const [key, value] of Object.entries(vars)) {
      result = result.replace(new RegExp(key, "g"), value);
    }
    return result;
  }
  /**
   * Get default subject for event
   */
  getDefaultSubject(event, campgroundName) {
    const name = campgroundName || "our campground";
    const subjects = {
      reservation_created: `Reservation Confirmed at ${name}`,
      reservation_confirmed: `Your Reservation is Confirmed - ${name}`,
      reservation_cancelled: `Reservation Cancelled - ${name}`,
      payment_received: `Payment Received - ${name}`,
      payment_failed: `Payment Issue - Action Required - ${name}`,
      checkin_reminder: `Check-in Reminder - ${name}`,
      checkout_reminder: `Check-out Reminder - ${name}`,
      site_ready: `Your Site is Ready! - ${name}`,
      balance_due: `Balance Due Reminder - ${name}`,
      review_request: `How was your stay at ${name}?`,
      waitlist_match: `Good News! A site is available at ${name}`,
      group_update: `Group Booking Update - ${name}`
    };
    return subjects[event] || `Update from ${name}`;
  }
  /**
   * Get default HTML for event
   */
  getDefaultHtml(event, payload, campgroundName) {
    const name = campgroundName || "our campground";
    const guestName = payload.guestName || "Guest";
    const templates = {
      reservation_created: `
        <h1>Reservation Confirmed!</h1>
        <p>Dear ${guestName},</p>
        <p>Your reservation at <strong>${name}</strong> has been confirmed.</p>
        ${payload.siteNumber ? `<p><strong>Site:</strong> ${payload.siteNumber}</p>` : ""}
        ${payload.arrivalDate ? `<p><strong>Check-in:</strong> ${payload.arrivalDate.toLocaleDateString()}</p>` : ""}
        ${payload.departureDate ? `<p><strong>Check-out:</strong> ${payload.departureDate.toLocaleDateString()}</p>` : ""}
        <p>We look forward to seeing you!</p>
      `,
      reservation_confirmed: `
        <h1>Your Reservation is Confirmed</h1>
        <p>Dear ${guestName},</p>
        <p>Your reservation at ${name} is confirmed and ready.</p>
      `,
      reservation_cancelled: `
        <h1>Reservation Cancelled</h1>
        <p>Dear ${guestName},</p>
        <p>Your reservation at ${name} has been cancelled.</p>
        <p>If this was a mistake, please contact us immediately.</p>
      `,
      payment_received: `
        <h1>Payment Received</h1>
        <p>Dear ${guestName},</p>
        <p>We've received your payment of ${payload.amountCents ? `$${(payload.amountCents / 100).toFixed(2)}` : "your payment"}.</p>
        <p>Thank you!</p>
      `,
      payment_failed: `
        <h1>Payment Issue</h1>
        <p>Dear ${guestName},</p>
        <p>We were unable to process your payment. Please update your payment method.</p>
      `,
      checkin_reminder: `
        <h1>Check-in Reminder</h1>
        <p>Dear ${guestName},</p>
        <p>Your stay at ${name} begins tomorrow!</p>
        ${payload.siteNumber ? `<p>You'll be at <strong>Site ${payload.siteNumber}</strong>.</p>` : ""}
      `,
      checkout_reminder: `
        <h1>Check-out Reminder</h1>
        <p>Dear ${guestName},</p>
        <p>Your checkout is tomorrow. Please vacate by 11:00 AM.</p>
      `,
      site_ready: `
        <h1>Your Site is Ready!</h1>
        <p>Dear ${guestName},</p>
        <p>Great news! Site ${payload.siteNumber} is cleaned and ready for your arrival.</p>
      `,
      balance_due: `
        <h1>Balance Due Reminder</h1>
        <p>Dear ${guestName},</p>
        <p>You have an outstanding balance of ${payload.amountCents ? `$${(payload.amountCents / 100).toFixed(2)}` : "some amount"} for your reservation.</p>
      `,
      review_request: `
        <h1>How was your stay?</h1>
        <p>Dear ${guestName},</p>
        <p>Thank you for staying at ${name}! We'd love to hear about your experience.</p>
      `,
      waitlist_match: `
        <h1>Site Available!</h1>
        <p>Dear ${guestName},</p>
        <p>A site matching your preferences is now available. Book now before it's gone!</p>
      `,
      group_update: `
        <h1>Group Booking Update</h1>
        <p>Dear ${guestName},</p>
        <p>There's been an update to your group booking at ${name}.</p>
      `
    };
    return templates[event] || `<p>Update from ${name}</p>`;
  }
  async processScheduledNotifications() {
    this.logger.debug("Processing scheduled notifications...");
    const now = /* @__PURE__ */ new Date();
    const pending = await this.prisma.scheduledNotification.findMany({
      where: {
        status: "pending",
        sendAt: { lte: now }
      },
      include: { trigger: { include: { template: true } } },
      take: 50
    });
    for (const notification of pending) {
      try {
        await this.sendNotification(notification.trigger, notification.payload);
        await this.prisma.scheduledNotification.update({
          where: { id: notification.id },
          data: { status: "sent", sentAt: /* @__PURE__ */ new Date() }
        });
      } catch (err) {
        this.logger.error(`Failed to send scheduled notification ${notification.id}: ${err}`);
        await this.prisma.scheduledNotification.update({
          where: { id: notification.id },
          data: { status: "failed" }
        });
      }
    }
    return { processed: pending.length };
  }
};
__decorateClass([
  (0, import_schedule14.Cron)(import_schedule14.CronExpression.EVERY_MINUTE)
], NotificationTriggersService.prototype, "processScheduledNotifications", 1);
NotificationTriggersService = __decorateClass([
  (0, import_common255.Injectable)()
], NotificationTriggersService);

// src/notification-triggers/notification-triggers.module.ts
var NotificationTriggersModule = class {
};
NotificationTriggersModule = __decorateClass([
  (0, import_common256.Module)({
    imports: [PrismaModule, EmailModule, SmsModule],
    controllers: [NotificationTriggersController],
    providers: [NotificationTriggersService],
    exports: [NotificationTriggersService]
  })
], NotificationTriggersModule);

// src/stored-value/stored-value.module.ts
var import_common259 = require("@nestjs/common");

// src/stored-value/stored-value.controller.ts
var import_common257 = require("@nestjs/common");
var StoredValueController = class {
  constructor(service) {
    this.service = service;
  }
  issue(dto, req) {
    return this.service.issue(dto, req.headers["idempotency-key"], req.user);
  }
  redeem(dto, req) {
    return this.service.redeem(dto, req.headers["idempotency-key"], req.user);
  }
  capture(id, req) {
    return this.service.captureHold(id, req.headers["idempotency-key"], req.user);
  }
  release(id, req) {
    return this.service.releaseHold(id, req.headers["idempotency-key"], req.user);
  }
  adjust(dto, req) {
    return this.service.adjust(dto, req.headers["idempotency-key"], req.user);
  }
  balance(id) {
    return this.service.balanceByAccount(id);
  }
  balanceByCode(code) {
    return this.service.balanceByCode(code);
  }
};
__decorateClass([
  (0, import_common257.Post)("issue"),
  __decorateParam(0, (0, import_common257.Body)()),
  __decorateParam(1, (0, import_common257.Req)())
], StoredValueController.prototype, "issue", 1);
__decorateClass([
  (0, import_common257.Post)("redeem"),
  __decorateParam(0, (0, import_common257.Body)()),
  __decorateParam(1, (0, import_common257.Req)())
], StoredValueController.prototype, "redeem", 1);
__decorateClass([
  (0, import_common257.Post)("holds/:id/capture"),
  __decorateParam(0, (0, import_common257.Param)("id")),
  __decorateParam(1, (0, import_common257.Req)())
], StoredValueController.prototype, "capture", 1);
__decorateClass([
  (0, import_common257.Post)("holds/:id/release"),
  __decorateParam(0, (0, import_common257.Param)("id")),
  __decorateParam(1, (0, import_common257.Req)())
], StoredValueController.prototype, "release", 1);
__decorateClass([
  (0, import_common257.Post)("adjust"),
  __decorateParam(0, (0, import_common257.Body)()),
  __decorateParam(1, (0, import_common257.Req)())
], StoredValueController.prototype, "adjust", 1);
__decorateClass([
  (0, import_common257.Get)(":id/balance"),
  __decorateParam(0, (0, import_common257.Param)("id"))
], StoredValueController.prototype, "balance", 1);
__decorateClass([
  (0, import_common257.Get)("code/:code/balance"),
  __decorateParam(0, (0, import_common257.Param)("code"))
], StoredValueController.prototype, "balanceByCode", 1);
StoredValueController = __decorateClass([
  (0, import_common257.UseGuards)(JwtAuthGuard),
  (0, import_common257.Controller)("stored-value")
], StoredValueController);

// src/stored-value/stored-value.service.ts
var import_common258 = require("@nestjs/common");
var import_client49 = require("@prisma/client");
var import_crypto21 = __toESM(require("crypto"));
var StoredValueService = class {
  constructor(prisma, idempotency, observability) {
    this.prisma = prisma;
    this.idempotency = idempotency;
    this.observability = observability;
  }
  async issue(dto, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? dto.tenantId ?? null, tenantId: actor?.tenantId ?? dto.tenantId ?? null };
    const existing = await this.guardIdempotency(
      idempotencyKey,
      dto,
      scope,
      "stored-value/issue",
      dto.referenceId ?? dto.code ?? dto.customerId ?? null
    );
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const campgroundId = scope.campgroundId ?? null;
    const now = /* @__PURE__ */ new Date();
    try {
      await this.validateTaxableLoad(campgroundId, dto.taxableLoad);
      const result = await this.prisma.$transaction(async (tx) => {
        const codeValue = dto.code || this.generateCode();
        const pinValue = dto.codeOptions?.pin || this.generatePinIfRequested(dto.codeOptions);
        const existingAccount = dto.reloadAccountId ? await tx.storedValueAccount.findUnique({ where: { id: dto.reloadAccountId } }) : null;
        if (existingAccount) {
          this.ensureActive(existingAccount);
          this.ensureCurrency(existingAccount, dto.currency);
          this.ensureTaxableFlag(existingAccount.metadata, dto.taxableLoad);
        }
        const account = existingAccount ?? await tx.storedValueAccount.create({
          data: {
            campgroundId: campgroundId ?? dto.tenantId,
            type: dto.type,
            currency: dto.currency.toLowerCase(),
            status: import_client49.StoredValueStatus.active,
            issuedAt: now,
            expiresAt: dto.expiresAt ? new Date(dto.expiresAt) : null,
            createdBy: actor?.id,
            createdVia: "api",
            metadata: this.mergeMetadata(dto.metadata, dto.taxableLoad)
          }
        });
        if (codeValue) {
          await tx.storedValueCode.create({
            data: {
              accountId: account.id,
              code: codeValue,
              pinHash: pinValue ? this.hashPin(pinValue) : void 0
            }
          });
        }
        const { balanceCents: currentBalance } = await this.getBalances(tx, account.id);
        const before = currentBalance;
        const after = before + dto.amountCents;
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.issue,
            amountCents: dto.amountCents,
            currency: dto.currency.toLowerCase(),
            beforeBalanceCents: before,
            afterBalanceCents: after,
            referenceType: "stored_value_issue",
            referenceId: account.id,
            idempotencyKey: idempotencyKey ?? `issue-${account.id}-${now.getTime()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            channel: dto.metadata?.channel ?? "staff",
            reason: dto.taxableLoad ? "taxable_load" : "nontaxable_load"
          }
        });
        return {
          accountId: account.id,
          balanceCents: after,
          expiresAt: account.expiresAt,
          code: codeValue,
          pinRequired: Boolean(pinValue),
          pin: dto.codeOptions?.pin ? void 0 : pinValue
          // only return generated pins, never echo provided
        };
      });
      if (dto.taxableLoad) {
        await this.assertLiabilityRollForward(campgroundId);
      }
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async reload(dto, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(
      idempotencyKey,
      dto,
      scope,
      "stored-value/reload",
      dto.referenceId ?? dto.accountId
    );
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const account = await this.prisma.storedValueAccount.findUnique({ where: { id: dto.accountId } });
    if (!account) throw new import_common258.NotFoundException("Account not found");
    this.ensureActive(account);
    this.ensureCurrency(account, dto.currency);
    this.ensureTaxableFlag(account.metadata, dto.taxableLoad);
    const now = /* @__PURE__ */ new Date();
    try {
      await this.validateTaxableLoad(scope.campgroundId ?? account.campgroundId ?? null, dto.taxableLoad);
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents } = await this.getBalances(tx, account.id);
        const after = balanceCents + dto.amountCents;
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.issue,
            amountCents: dto.amountCents,
            currency: account.currency,
            beforeBalanceCents: balanceCents,
            afterBalanceCents: after,
            referenceType: dto.referenceType ?? "stored_value_reload",
            referenceId: dto.referenceId ?? dto.accountId,
            idempotencyKey: idempotencyKey ?? `reload-${account.id}-${now.getTime()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            channel: "staff",
            reason: dto.taxableLoad ? "taxable_load" : "nontaxable_load"
          }
        });
        return { accountId: account.id, balanceCents: after };
      });
      if (dto.taxableLoad) {
        await this.assertLiabilityRollForward(scope.campgroundId ?? account.campgroundId ?? null);
      }
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async redeem(dto, idempotencyKey, actor) {
    const started = Date.now();
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, dto, scope, "stored-value/redeem", `${dto.referenceType}:${dto.referenceId}`);
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const account = await this.getAccount(dto);
    this.ensureActive(account);
    this.ensureCurrency(account, dto.currency);
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents, availableCents } = await this.getBalances(tx, account.id);
        if (!dto.holdOnly && availableCents < dto.amountCents) {
          throw new import_common258.BadRequestException("Insufficient balance");
        }
        if (!dto.holdOnly) {
          const alreadyRedeemed = await tx.storedValueLedger.findFirst({
            where: {
              accountId: account.id,
              referenceType: dto.referenceType,
              referenceId: dto.referenceId,
              direction: import_client49.StoredValueDirection.redeem
            }
          });
          if (alreadyRedeemed) {
            throw new import_common258.ConflictException("Gift card already redeemed for this reference");
          }
        }
        if (dto.holdOnly) {
          const hold = await tx.storedValueHold.create({
            data: {
              accountId: account.id,
              amountCents: dto.amountCents,
              status: "open",
              expiresAt: new Date(Date.now() + 15 * 60 * 1e3),
              // 15 min default
              referenceType: dto.referenceType,
              referenceId: dto.referenceId,
              idempotencyKey: idempotencyKey ?? `hold-${account.id}-${Date.now()}`
            }
          });
          return { accountId: account.id, availableCents: availableCents - dto.amountCents, holdId: hold.id };
        }
        const before = balanceCents;
        const after = before - dto.amountCents;
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.redeem,
            amountCents: dto.amountCents,
            currency: account.currency,
            beforeBalanceCents: before,
            afterBalanceCents: after,
            referenceType: dto.referenceType,
            referenceId: dto.referenceId,
            idempotencyKey: idempotencyKey ?? `redeem-${account.id}-${Date.now()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            channel: dto.channel ?? "pos"
          }
        });
        return { accountId: account.id, balanceCents: after };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      this.observability.recordRedeemOutcome(true, Date.now() - started, {
        campgroundId: actor?.campgroundId ?? dto.referenceId,
        referenceType: dto.referenceType
      });
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      this.observability.recordRedeemOutcome(false, Date.now() - started, {
        error: err?.message ?? "redeem_failed",
        campgroundId: actor?.campgroundId ?? dto.referenceId
      });
      throw err;
    }
  }
  async captureHold(holdId, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, { holdId }, scope, "stored-value/hold-capture");
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const hold = await this.prisma.storedValueHold.findUnique({ where: { id: holdId } });
    if (!hold) throw new import_common258.NotFoundException("Hold not found");
    if (hold.status !== "open") throw new import_common258.ConflictException("Hold not open");
    if (hold.expiresAt < /* @__PURE__ */ new Date()) throw new import_common258.ConflictException("Hold expired");
    const account = await this.prisma.storedValueAccount.findUnique({ where: { id: hold.accountId } });
    if (!account) throw new import_common258.NotFoundException("Account not found");
    this.ensureActive(account);
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents, availableCents } = await this.getBalances(tx, account.id);
        if (availableCents < 0) throw new import_common258.BadRequestException("Insufficient available balance");
        const before = balanceCents;
        const after = before - hold.amountCents;
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.hold_capture,
            amountCents: hold.amountCents,
            currency: account.currency,
            beforeBalanceCents: before,
            afterBalanceCents: after,
            referenceType: hold.referenceType,
            referenceId: hold.referenceId,
            idempotencyKey: idempotencyKey ?? `hold-capture-${hold.id}`,
            actorType: actor?.role,
            actorId: actor?.id
          }
        });
        await tx.storedValueHold.update({
          where: { id: hold.id },
          data: { status: "captured" }
        });
        return { accountId: account.id, balanceCents: after };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async refundToCredit(dto, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(
      idempotencyKey,
      dto,
      scope,
      "stored-value/refund",
      dto.referenceId ?? `${dto.accountId}:${dto.amountCents}`
    );
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const account = await this.prisma.storedValueAccount.findUnique({ where: { id: dto.accountId } });
    if (!account) throw new import_common258.NotFoundException("Account not found");
    this.ensureActive(account);
    this.ensureCurrency(account, dto.currency);
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents } = await this.getBalances(tx, account.id);
        const after = balanceCents + dto.amountCents;
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.refund,
            amountCents: dto.amountCents,
            currency: account.currency,
            beforeBalanceCents: balanceCents,
            afterBalanceCents: after,
            referenceType: dto.referenceType ?? "stored_value_refund",
            referenceId: dto.referenceId ?? dto.accountId,
            idempotencyKey: idempotencyKey ?? `refund-${account.id}-${Date.now()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            reason: "refund_to_credit"
          }
        });
        return { accountId: account.id, balanceCents: after };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async voidOrChargeback(dto, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, dto, scope, "stored-value/void", dto.referenceId ?? dto.accountId);
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const account = await this.prisma.storedValueAccount.findUnique({ where: { id: dto.accountId } });
    if (!account) throw new import_common258.NotFoundException("Account not found");
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents } = await this.getBalances(tx, account.id);
        if (balanceCents <= 0) {
          await tx.storedValueAccount.update({ where: { id: account.id }, data: { status: import_client49.StoredValueStatus.frozen } });
          return { accountId: account.id, balanceCents };
        }
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.expire,
            amountCents: balanceCents,
            currency: account.currency,
            beforeBalanceCents: balanceCents,
            afterBalanceCents: 0,
            referenceType: "void_or_chargeback",
            referenceId: dto.referenceId ?? account.id,
            idempotencyKey: idempotencyKey ?? `void-${account.id}-${Date.now()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            reason: dto.reason ?? "void"
          }
        });
        await tx.storedValueAccount.update({
          where: { id: account.id },
          data: { status: import_client49.StoredValueStatus.frozen }
        });
        return { accountId: account.id, balanceCents: 0, status: "frozen" };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async releaseHold(holdId, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, { holdId }, scope, "stored-value/hold-release");
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const hold = await this.prisma.storedValueHold.findUnique({ where: { id: holdId } });
    if (!hold) throw new import_common258.NotFoundException("Hold not found");
    if (hold.status !== "open") throw new import_common258.ConflictException("Hold not open");
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        await tx.storedValueHold.update({
          where: { id: hold.id },
          data: { status: "released" }
        });
        return { holdId: hold.id, status: "released" };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  /**
   * Sweep and expire open holds past their TTL.
   */
  async expireOpenHolds(cutoff) {
    const now = cutoff ?? /* @__PURE__ */ new Date();
    const expiredIds = await this.prisma.storedValueHold.findMany({
      where: { status: "open", expiresAt: { lt: now } },
      select: { id: true }
    });
    if (!expiredIds.length) return { released: 0 };
    await this.prisma.storedValueHold.updateMany({
      where: { id: { in: expiredIds.map((h) => h.id) } },
      data: { status: "expired" }
    });
    return { released: expiredIds.length };
  }
  /**
   * Sweep expired accounts and move remaining balance to expire ledger, marking account expired.
   */
  async expireBalances(cutoff) {
    const now = cutoff ?? /* @__PURE__ */ new Date();
    const accounts = await this.prisma.storedValueAccount.findMany({
      where: { status: import_client49.StoredValueStatus.active, expiresAt: { not: null, lt: now } },
      select: { id: true, campgroundId: true, currency: true, expiresAt: true }
    });
    if (!accounts.length) return { expired: 0, zeroed: 0 };
    let expiredCount = 0;
    let zeroedCount = 0;
    for (const acc of accounts) {
      await this.prisma.$transaction(async (tx) => {
        const { balanceCents } = await this.getBalances(tx, acc.id);
        if (balanceCents <= 0) {
          await tx.storedValueAccount.update({
            where: { id: acc.id },
            data: { status: import_client49.StoredValueStatus.expired }
          });
          zeroedCount += 1;
          return;
        }
        await tx.storedValueLedger.create({
          data: {
            campgroundId: acc.campgroundId,
            accountId: acc.id,
            direction: import_client49.StoredValueDirection.expire,
            amountCents: balanceCents,
            currency: acc.currency,
            beforeBalanceCents: balanceCents,
            afterBalanceCents: 0,
            referenceType: "expire",
            referenceId: acc.id,
            idempotencyKey: `expire-${acc.id}-${now.getTime()}`
          }
        });
        await tx.storedValueAccount.update({
          where: { id: acc.id },
          data: { status: import_client49.StoredValueStatus.expired }
        });
        expiredCount += 1;
      });
    }
    return { expired: expiredCount, zeroed: zeroedCount };
  }
  async adjust(dto, idempotencyKey, actor) {
    const scope = { campgroundId: actor?.campgroundId ?? null, tenantId: actor?.tenantId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, dto, scope, "stored-value/adjust");
    if (existing?.status === import_client49.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client49.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common258.ConflictException("Request already in progress");
    }
    const account = await this.prisma.storedValueAccount.findUnique({ where: { id: dto.accountId } });
    if (!account) throw new import_common258.NotFoundException("Account not found");
    this.ensureActive(account);
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        const { balanceCents } = await this.getBalances(tx, account.id);
        const after = balanceCents + dto.deltaCents;
        if (after < 0) throw new import_common258.BadRequestException("Adjustment would result in negative balance");
        await tx.storedValueLedger.create({
          data: {
            campgroundId: account.campgroundId,
            accountId: account.id,
            direction: import_client49.StoredValueDirection.adjust,
            amountCents: dto.deltaCents,
            currency: account.currency,
            beforeBalanceCents: balanceCents,
            afterBalanceCents: after,
            referenceType: "adjustment",
            referenceId: dto.accountId,
            idempotencyKey: idempotencyKey ?? `adjust-${dto.accountId}-${Date.now()}`,
            actorType: actor?.role,
            actorId: actor?.id,
            reason: dto.reason
          }
        });
        return { accountId: account.id, balanceCents: after };
      });
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async balanceByAccount(accountId) {
    await this.idempotency.throttleScope(void 0, void 0, "lookup").catch((err) => {
      this.observability.recordRedeemOutcome(false, void 0, { error: err?.message ?? "throttled_lookup", accountId });
      throw err;
    });
    const { balanceCents, availableCents } = await this.getBalances(this.prisma, accountId);
    return { accountId, balanceCents, availableCents };
  }
  async balanceByCode(code) {
    await this.idempotency.throttleScope(void 0, void 0, "lookup").catch((err) => {
      this.observability.recordRedeemOutcome(false, void 0, { error: err?.message ?? "throttled_lookup", code });
      throw err;
    });
    const account = await this.prisma.storedValueCode.findUnique({
      where: { code },
      select: { accountId: true }
    });
    if (!account) return { code, balanceCents: 0 };
    return this.balanceByAccount(account.accountId);
  }
  async liabilitySnapshot(campgroundId, opts) {
    const accounts = await this.prisma.storedValueAccount.findMany({
      where: { campgroundId },
      select: { id: true, metadata: true }
    });
    if (!accounts.length) return { campgroundId, taxableCents: 0, nonTaxableCents: 0, totalCents: 0 };
    const accountIds = accounts.map((a) => a.id);
    const ledger = await this.prisma.storedValueLedger.findMany({
      where: { accountId: { in: accountIds } },
      select: { accountId: true, direction: true, amountCents: true }
    });
    const balancesByAccount = /* @__PURE__ */ new Map();
    for (const row of ledger) {
      const current = balancesByAccount.get(row.accountId) ?? 0;
      balancesByAccount.set(row.accountId, current + this.directionToSigned(row.direction, row.amountCents));
    }
    let taxableCents = 0;
    let nonTaxableCents = 0;
    for (const acc of accounts) {
      const bal = balancesByAccount.get(acc.id) ?? 0;
      if (this.isTaxable(acc.metadata)) {
        taxableCents += bal;
      } else {
        nonTaxableCents += bal;
      }
    }
    const rollForwardCents = ledger.reduce(
      (sum, row) => sum + this.directionToSigned(row.direction, row.amountCents),
      0
    );
    const totalCents = taxableCents + nonTaxableCents;
    const driftCents = rollForwardCents - totalCents;
    const rollForwardOk = driftCents === 0;
    if (opts?.enforce && !rollForwardOk) {
      throw new import_common258.ConflictException(`Liability roll-forward drift detected (${driftCents} cents)`);
    }
    return { campgroundId, taxableCents, nonTaxableCents, totalCents, rollForwardCents, driftCents, rollForwardOk };
  }
  directionToSigned(direction, amount) {
    if ([import_client49.StoredValueDirection.issue, import_client49.StoredValueDirection.refund, import_client49.StoredValueDirection.adjust].includes(direction)) return amount;
    if ([import_client49.StoredValueDirection.redeem, import_client49.StoredValueDirection.expire, import_client49.StoredValueDirection.hold_capture].includes(direction)) return -Math.abs(amount);
    return 0;
  }
  async getBalances(tx, accountId) {
    const ledger = await tx.storedValueLedger.findMany({
      where: { accountId },
      select: { direction: true, amountCents: true }
    });
    const balanceCents = ledger.reduce(
      (sum, row) => sum + this.directionToSigned(row.direction, row.amountCents),
      0
    );
    const openHolds = await tx.storedValueHold.aggregate({
      where: { accountId, status: "open" },
      _sum: { amountCents: true }
    });
    const held = openHolds._sum.amountCents ?? 0;
    return { balanceCents, availableCents: balanceCents - held };
  }
  async guardIdempotency(key, body, scope, endpoint, sequence) {
    if (!key) return null;
    return this.idempotency.start(key, body ?? {}, scope.campgroundId ?? null, {
      tenantId: scope.tenantId ?? null,
      endpoint,
      sequence,
      rateAction: "apply"
    });
  }
  ensureActive(account) {
    if (account.status !== import_client49.StoredValueStatus.active) {
      throw new import_common258.ForbiddenException("Stored value account not active");
    }
    if (account.expiresAt && account.expiresAt < /* @__PURE__ */ new Date()) {
      throw new import_common258.ForbiddenException("Stored value account expired");
    }
  }
  ensureCurrency(account, currency) {
    if (account.currency !== currency.toLowerCase()) {
      throw new import_common258.BadRequestException("Currency mismatch");
    }
  }
  ensureTaxableFlag(metadata, incoming) {
    if (incoming === void 0 || incoming === null) return;
    const existing = this.isTaxable(metadata);
    if (existing !== incoming) {
      throw new import_common258.ConflictException("Taxable load flag mismatch");
    }
  }
  async validateTaxableLoad(campgroundId, taxableLoad) {
    if (!taxableLoad) return;
    if (!campgroundId) {
      throw new import_common258.BadRequestException("taxable_load requires campground context");
    }
    const activeRate = await this.prisma.taxRule.findFirst({
      where: { campgroundId, type: import_client49.TaxRuleType.rate, isActive: true }
    });
    if (!activeRate) {
      throw new import_common258.BadRequestException("Taxable load requires an active tax rule");
    }
  }
  isTaxable(metadata) {
    if (!metadata) return false;
    return Boolean(metadata.taxableLoad);
  }
  mergeMetadata(metadata, taxableLoad) {
    const merged = { ...metadata ?? {} };
    if (taxableLoad !== void 0) {
      merged.taxableLoad = taxableLoad;
    }
    return merged;
  }
  async assertLiabilityRollForward(campgroundId) {
    if (!campgroundId) return;
    await this.liabilitySnapshot(campgroundId, { enforce: true });
  }
  async getAccount(dto) {
    if (!dto.accountId && !dto.code) {
      throw new import_common258.BadRequestException("accountId or code required");
    }
    if (dto.accountId) {
      const acc = await this.prisma.storedValueAccount.findUnique({ where: { id: dto.accountId } });
      if (!acc) throw new import_common258.NotFoundException("Account not found");
      const pinCode = await this.prisma.storedValueCode.findFirst({
        where: { accountId: dto.accountId, pinHash: { not: null } },
        select: { pinHash: true }
      });
      if (pinCode?.pinHash) {
        if (!dto.pin) throw new import_common258.ForbiddenException("PIN required");
        if (!this.verifyPin(dto.pin, pinCode.pinHash)) throw new import_common258.ForbiddenException("Invalid PIN");
      }
      return acc;
    }
    const code = await this.prisma.storedValueCode.findUnique({
      where: { code: dto.code },
      select: {
        pinHash: true,
        account: true
      }
    });
    if (!code?.account) throw new import_common258.NotFoundException("Account not found");
    if (code.pinHash) {
      if (!dto.pin) throw new import_common258.ForbiddenException("PIN required");
      if (!this.verifyPin(dto.pin, code.pinHash)) throw new import_common258.ForbiddenException("Invalid PIN");
    }
    return code.account;
  }
  hashPin(pin) {
    const salt = import_crypto21.default.randomBytes(16).toString("hex");
    const hash4 = import_crypto21.default.pbkdf2Sync(pin, salt, 1e4, 32, "sha256").toString("hex");
    return `${salt}:${hash4}`;
  }
  verifyPin(pin, stored) {
    const [salt, hash4] = stored.split(":");
    if (!salt || !hash4) return false;
    const candidate = import_crypto21.default.pbkdf2Sync(pin, salt, 1e4, 32, "sha256").toString("hex");
    return import_crypto21.default.timingSafeEqual(Buffer.from(candidate, "hex"), Buffer.from(hash4, "hex"));
  }
  generateCode(length = 16) {
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    const bytes = import_crypto21.default.randomBytes(length);
    let code = "";
    for (let i = 0; i < length; i++) {
      code += alphabet[bytes[i] % alphabet.length];
    }
    return code;
  }
  generatePinIfRequested(codeOptions) {
    if (codeOptions?.pin) return codeOptions.pin;
    if (!codeOptions?.generatePin) return void 0;
    const pin = Math.floor(1e5 + Math.random() * 9e5).toString();
    return pin;
  }
};
StoredValueService = __decorateClass([
  (0, import_common258.Injectable)()
], StoredValueService);

// src/stored-value/stored-value.module.ts
var StoredValueModule = class {
};
StoredValueModule = __decorateClass([
  (0, import_common259.Module)({
    controllers: [StoredValueController],
    providers: [StoredValueService, PrismaService, IdempotencyService],
    exports: [StoredValueService]
  })
], StoredValueModule);

// src/pos/pos.module.ts
var import_common268 = require("@nestjs/common");

// src/pos/pos.controller.ts
var import_common260 = require("@nestjs/common");
var PosController = class {
  constructor(service) {
    this.service = service;
  }
  createCart(dto, req) {
    return this.service.createCart(dto, req.user);
  }
  updateCart(id, dto, req) {
    return this.service.updateCart(id, dto, req.user);
  }
  checkout(id, dto, req) {
    return this.service.checkout(id, dto, req.headers["idempotency-key"], req.user);
  }
  replay(payload, req) {
    return this.service.replayOffline(payload, req.headers["idempotency-key"], req.user);
  }
  createReturn(dto, req) {
    return this.service.createReturn(dto, req.headers["idempotency-key"], req.user);
  }
};
__decorateClass([
  (0, import_common260.Post)("carts"),
  __decorateParam(0, (0, import_common260.Body)()),
  __decorateParam(1, (0, import_common260.Req)())
], PosController.prototype, "createCart", 1);
__decorateClass([
  (0, import_common260.Patch)("carts/:id"),
  __decorateParam(0, (0, import_common260.Param)("id")),
  __decorateParam(1, (0, import_common260.Body)()),
  __decorateParam(2, (0, import_common260.Req)())
], PosController.prototype, "updateCart", 1);
__decorateClass([
  (0, import_common260.Post)("carts/:id/checkout"),
  __decorateParam(0, (0, import_common260.Param)("id")),
  __decorateParam(1, (0, import_common260.Body)()),
  __decorateParam(2, (0, import_common260.Req)())
], PosController.prototype, "checkout", 1);
__decorateClass([
  (0, import_common260.Post)("offline/replay"),
  __decorateParam(0, (0, import_common260.Body)()),
  __decorateParam(1, (0, import_common260.Req)())
], PosController.prototype, "replay", 1);
__decorateClass([
  (0, import_common260.Post)("returns"),
  __decorateParam(0, (0, import_common260.Body)()),
  __decorateParam(1, (0, import_common260.Req)())
], PosController.prototype, "createReturn", 1);
PosController = __decorateClass([
  (0, import_common260.UseGuards)(JwtAuthGuard),
  (0, import_common260.Controller)("pos")
], PosController);

// src/pos/pos.service.ts
var import_common261 = require("@nestjs/common");
var import_client50 = require("@prisma/client");
var import_crypto22 = __toESM(require("crypto"));
var PosService = class {
  constructor(prisma, idempotency, storedValue, stripe, till, observability, providerIntegrations, audit, email) {
    this.prisma = prisma;
    this.idempotency = idempotency;
    this.storedValue = storedValue;
    this.stripe = stripe;
    this.till = till;
    this.observability = observability;
    this.providerIntegrations = providerIntegrations;
    this.audit = audit;
    this.email = email;
    this.logger = new import_common261.Logger(PosService.name);
  }
  async createCart(dto, actor) {
    return this.prisma.posCart.create({
      data: {
        campgroundId: actor?.campgroundId,
        terminalId: dto.terminalId,
        currency: actor?.currency ?? "usd",
        pricingVersion: dto.pricingVersion,
        taxVersion: dto.taxVersion,
        items: {
          create: dto.items.map((item) => ({
            productId: item.productId,
            qty: item.qty,
            unitPriceCents: item.overridePriceCents ?? 0,
            totalCents: (item.overridePriceCents ?? 0) * item.qty
          }))
        }
      },
      include: { items: true }
    });
  }
  async updateCart(cartId, dto, actor) {
    const ops = {};
    if (dto.add) {
      ops.create = dto.add.map((item) => ({
        productId: item.productId,
        qty: item.qty,
        unitPriceCents: item.overridePriceCents ?? 0,
        totalCents: (item.overridePriceCents ?? 0) * item.qty
      }));
    }
    if (dto.update) {
      ops.update = dto.update.map((item) => ({
        where: { id: item.cartItemId },
        data: {
          qty: item.qty,
          unitPriceCents: item.overridePriceCents ?? void 0
        }
      }));
    }
    if (dto.remove) {
      ops.deleteMany = dto.remove.map((item) => ({ id: item.cartItemId }));
    }
    return this.prisma.posCart.update({
      where: { id: cartId },
      data: {
        items: ops
      },
      include: { items: true }
    });
  }
  async checkout(cartId, dto, idempotencyKey, actor) {
    const existing = await this.guardIdempotency(idempotencyKey, { cartId, dto }, actor, "pos/checkout");
    if (existing?.status === import_client50.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client50.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common261.ConflictException("Request already in progress");
    }
    const cart = await this.prisma.posCart.findUnique({
      where: { id: cartId },
      include: { items: { include: { product: true } }, payments: true }
    });
    if (!cart) throw new import_common261.NotFoundException("Cart not found");
    if (cart.status !== import_client50.PosCartStatus.open) throw new import_common261.ConflictException("Cart not open");
    const expected = this.reprice(cart);
    const expectedTotal = expected.totalCents;
    const tenderTotal = dto.payments.reduce((sum, p) => sum + p.amountCents, 0);
    const delta = tenderTotal - expectedTotal;
    const tolerance = 1;
    if (Math.abs(delta) > tolerance) {
      const resp = await this.prisma.posCart.update({
        where: { id: cartId },
        data: { needsReview: true },
        include: { items: true, payments: true }
      });
      const response = {
        cartId,
        status: "needs_review",
        reason: "tender_mismatch",
        cart: resp,
        expectedTotal,
        tenderTotal,
        delta,
        expectedBreakdown: expected
      };
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response);
      return response;
    }
    const hasCash = dto.payments.some((p) => p.method === "cash");
    const cashTillSession = hasCash ? await this.till.findOpenSessionForTerminal(actor?.campgroundId ?? null, cart.terminalId) : null;
    if (hasCash && !cashTillSession) {
      throw new import_common261.BadRequestException("No open till session for this terminal");
    }
    try {
      const result = await this.prisma.$transaction(async (tx) => {
        for (const p of dto.payments.filter((p2) => p2.method === "gift" || p2.method === "store_credit")) {
          await this.storedValue.redeem(
            {
              code: dto.giftCode,
              amountCents: p.amountCents,
              currency: cart.currency,
              referenceType: "pos_cart",
              referenceId: cartId
            },
            p.idempotencyKey,
            actor
          );
        }
        for (const p of dto.payments.filter((p2) => p2.method !== "gift" && p2.method !== "store_credit")) {
          if (p.method === "charge_to_site") {
            await tx.posPayment.create({
              data: {
                cartId,
                method: p.method,
                amountCents: p.amountCents,
                currency: p.currency.toLowerCase(),
                status: import_client50.PosPaymentStatus.pending,
                idempotencyKey: p.idempotencyKey,
                referenceType: p.referenceType,
                referenceId: p.referenceId
              }
            });
            continue;
          }
          if (p.method === "card") {
            const providerPayment = await this.providerIntegrations.routePayment(
              actor?.campgroundId ?? null,
              cart.terminalId ?? null,
              {
                amountCents: p.amountCents,
                currency: p.currency,
                idempotencyKey: p.idempotencyKey,
                cartId,
                metadata: { referenceType: p.referenceType, referenceId: p.referenceId }
              }
            );
            if (providerPayment) {
              const status = providerPayment.status === "succeeded" ? import_client50.PosPaymentStatus.succeeded : providerPayment.status === "failed" ? import_client50.PosPaymentStatus.failed : import_client50.PosPaymentStatus.pending;
              await tx.posPayment.create({
                data: {
                  cartId,
                  method: p.method,
                  amountCents: p.amountCents,
                  currency: p.currency.toLowerCase(),
                  status,
                  idempotencyKey: p.idempotencyKey,
                  referenceType: p.referenceType,
                  referenceId: p.referenceId,
                  processorIds: providerPayment.processorIds ?? { provider: providerPayment.provider }
                }
              });
              await this.audit.record({
                campgroundId: actor?.campgroundId ?? cart.campgroundId,
                actorId: actor?.id ?? null,
                action: "pos.payment.external",
                entity: "pos_cart",
                entityId: cartId,
                after: { provider: providerPayment.provider, status }
              });
              continue;
            }
            const stripeAccountId = process.env.STRIPE_ACCOUNT_ID;
            if (!this.stripe.isConfigured() || !stripeAccountId) {
              throw new import_common261.BadRequestException("Card processing not configured");
            }
            const intent = await this.stripe.createPaymentIntent(
              p.amountCents,
              p.currency.toLowerCase(),
              { cartId, source: "pos" },
              stripeAccountId,
              0,
              "automatic",
              void 0,
              p.idempotencyKey
            );
            await tx.posPayment.create({
              data: {
                cartId,
                method: p.method,
                amountCents: p.amountCents,
                currency: p.currency.toLowerCase(),
                status: import_client50.PosPaymentStatus.succeeded,
                idempotencyKey: p.idempotencyKey,
                referenceType: p.referenceType,
                referenceId: p.referenceId,
                processorIds: { intentId: intent.id }
              }
            });
            continue;
          }
          const payment = await tx.posPayment.create({
            data: {
              cartId,
              method: p.method,
              amountCents: p.amountCents,
              currency: p.currency.toLowerCase(),
              status: import_client50.PosPaymentStatus.succeeded,
              idempotencyKey: p.idempotencyKey,
              referenceType: p.referenceType,
              referenceId: p.referenceId
            }
          });
          if (p.method === "cash" && cashTillSession) {
            await tx.tillMovement.create({
              data: {
                sessionId: cashTillSession.id,
                type: import_client50.TillMovementType.cash_sale,
                amountCents: p.amountCents,
                currency: payment.currency,
                actorUserId: actor?.id,
                sourceCartId: cartId,
                note: `cart:${cartId}`
              }
            });
          }
        }
        await tx.posCart.update({
          where: { id: cartId },
          data: {
            status: import_client50.PosCartStatus.checked_out,
            netCents: expected.netCents,
            taxCents: expected.taxCents,
            feeCents: expected.feeCents,
            grossCents: expected.totalCents,
            needsReview: false
          }
        });
        return {
          cartId,
          status: "checked_out",
          totalCents: expected.totalCents,
          breakdown: expected
        };
      });
      const receiptEmail = actor?.email ?? actor?.guestEmail ?? null;
      if (receiptEmail) {
        try {
          const lineItems = (cart.items ?? []).map((i) => ({
            label: i?.product?.name ?? i.productId,
            amountCents: i.totalCents ?? 0
          }));
          await this.email.sendPaymentReceipt({
            guestEmail: receiptEmail,
            guestName: actor?.name ?? actor?.displayName ?? "Guest",
            campgroundName: actor?.campgroundName ?? "Campground",
            amountCents: expected.totalCents,
            paymentMethod: dto.payments.map((p) => p.method).join(", "),
            source: "pos",
            lineItems,
            taxCents: expected.taxCents,
            feeCents: expected.feeCents,
            totalCents: expected.totalCents,
            kind: "pos"
          });
        } catch (emailErr) {
          this.logger.warn(`POS receipt email failed for cart ${cartId}: ${emailErr}`);
        }
      }
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, result);
      return result;
    } catch (err) {
      if (idempotencyKey) await this.idempotency.fail(idempotencyKey);
      throw err;
    }
  }
  async replayOffline(dto, idempotencyKey, actor) {
    const started = Date.now();
    const scope = this.scopeKey(actor);
    if (dto.clientTxId) {
      const seqExisting = await this.idempotency.findBySequence(scope, "pos/offline/replay", dto.clientTxId);
      if (seqExisting?.responseJson) {
        this.logger.warn(`Duplicate offline replay detected for seq ${dto.clientTxId} scope ${scope}`);
        return seqExisting.responseJson;
      }
      if (seqExisting?.status === import_client50.IdempotencyStatus.inflight) {
        throw new import_common261.ConflictException("Replay already in progress");
      }
      if (seqExisting) {
        this.logger.warn(`Replay seq ${dto.clientTxId} already processed without snapshot for scope ${scope}`);
      }
    }
    const existing = await this.guardIdempotency(idempotencyKey, dto, actor, "pos/offline/replay", dto.clientTxId, dto.recordedTotalsHash);
    if (existing?.status === import_client50.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client50.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common261.ConflictException("Request already in progress");
    }
    const cartId = dto.payload?.cartId;
    if (!cartId) {
      const response2 = {
        clientTxId: dto.clientTxId,
        status: "needs_review",
        reason: "missing_cart_id",
        recordedTotalsHash: dto.recordedTotalsHash
      };
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response2);
      return response2;
    }
    const cart = await this.prisma.posCart.findUnique({
      where: { id: cartId },
      include: { items: true }
    });
    if (!cart) {
      const response2 = { clientTxId: dto.clientTxId, status: "needs_review", reason: "cart_not_found" };
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response2);
      return response2;
    }
    const expected = this.reprice(cart);
    const expectedHash = this.hashTotals(expected);
    if (!dto.recordedTotalsHash) {
      const response2 = {
        clientTxId: dto.clientTxId,
        status: "needs_review",
        reason: "missing_recorded_totals_hash",
        cartId,
        expectedBreakdown: expected,
        expectedHash
      };
      if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response2);
      return response2;
    }
    const matches = dto.recordedTotalsHash === expectedHash;
    const response = matches ? {
      clientTxId: dto.clientTxId,
      status: "accepted",
      cartId,
      expectedBreakdown: expected
    } : {
      clientTxId: dto.clientTxId,
      status: "needs_review",
      reason: "totals_mismatch",
      cartId,
      expectedBreakdown: expected,
      expectedHash,
      recordedTotalsHash: dto.recordedTotalsHash
    };
    if (response.status === "needs_review") {
      await this.prisma.posCart.update({ where: { id: cartId }, data: { needsReview: true } }).catch(() => null);
    }
    const payloadHash = dto.payload ? import_crypto22.default.createHash("sha256").update(JSON.stringify(dto.payload)).digest("hex") : void 0;
    const tender = this.extractTender(dto.payload);
    const items = this.extractItems(dto.payload);
    try {
      const offlineId = dto.clientTxId ? `offline_${dto.clientTxId}` : void 0;
      if (offlineId) {
        await this.prisma.posOfflineReplay.upsert({
          where: { id: offlineId },
          update: {
            recordedTotalsHash: dto.recordedTotalsHash ?? null,
            expectedHash,
            payloadHash,
            status: response.status,
            reason: response.reason ?? null,
            payload: dto.payload,
            tender,
            items,
            expectedBreakdown: expected,
            campgroundId: actor?.campgroundId ?? null,
            cartId
          },
          create: {
            id: offlineId,
            clientTxId: dto.clientTxId ?? null,
            cartId,
            campgroundId: actor?.campgroundId ?? null,
            recordedTotalsHash: dto.recordedTotalsHash ?? null,
            expectedHash,
            payloadHash,
            status: response.status,
            reason: response.reason ?? null,
            payload: dto.payload,
            tender,
            items,
            expectedBreakdown: expected
          }
        });
      } else {
        await this.prisma.posOfflineReplay.create({
          data: {
            clientTxId: dto.clientTxId ?? null,
            cartId,
            campgroundId: actor?.campgroundId ?? null,
            recordedTotalsHash: dto.recordedTotalsHash ?? null,
            expectedHash,
            payloadHash,
            status: response.status,
            reason: response.reason ?? null,
            payload: dto.payload,
            tender,
            items,
            expectedBreakdown: expected
          }
        });
      }
    } catch (persistErr) {
      this.logger.warn(`Failed to persist offline replay ${dto.clientTxId ?? "unknown"}: ${persistErr}`);
    }
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response);
    this.observability.recordOfflineReplay(response.status === "accepted", Date.now() - started, {
      clientTxId: dto.clientTxId,
      cartId,
      status: response.status,
      campgroundId: actor?.campgroundId ?? null
    });
    return response;
  }
  async createReturn(dto, idempotencyKey, actor) {
    const existing = await this.guardIdempotency(idempotencyKey, dto, actor, "pos/returns");
    if (existing?.status === import_client50.IdempotencyStatus.succeeded && existing.responseJson) return existing.responseJson;
    if (existing?.status === import_client50.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common261.ConflictException("Request already in progress");
    }
    const cart = await this.prisma.posCart.findUnique({
      where: { id: dto.originalCartId },
      include: { items: true }
    });
    if (!cart) throw new import_common261.NotFoundException("Original cart not found");
    if (cart.status !== import_client50.PosCartStatus.checked_out) throw new import_common261.ConflictException("Only checked out carts can be returned");
    const itemsToReverse = dto.items?.length ? cart.items.filter((i) => dto.items?.some((sel) => sel.cartItemId === i.id)) : cart.items;
    if (!itemsToReverse.length) {
      throw new import_common261.BadRequestException("No items to return");
    }
    let net = 0;
    let tax = 0;
    let fee = 0;
    let gross = 0;
    const details = [];
    for (const item of itemsToReverse) {
      const sel = dto.items?.find((s) => s.cartItemId === item.id);
      const qty = sel?.qty ?? item.qty ?? 1;
      const unit = item.unitPriceCents ?? (item.totalCents && item.qty ? item.totalCents / item.qty : item.totalCents);
      const lineNet = unit * qty;
      const lineTax = (item.taxCents ?? 0) * (qty / (item.qty || qty));
      const lineFee = (item.feeCents ?? 0) * (qty / (item.qty || qty));
      const lineTotal = lineNet + lineTax + lineFee;
      net += lineNet;
      tax += lineTax;
      fee += lineFee;
      gross += lineTotal;
      details.push({ cartItemId: item.id, qty, lineNet, lineTax, lineFee, lineTotal });
    }
    const returnRecord = await this.prisma.posReturn.create({
      data: {
        originalCartId: cart.id,
        status: "pending",
        reasonCode: dto.reasonCode,
        restock: dto.restock ?? false,
        netCents: Math.round(net),
        taxCents: Math.round(tax),
        feeCents: Math.round(fee),
        grossCents: Math.round(gross)
      }
    });
    const response = {
      status: "needs_review",
      reason: "return_pending_refund",
      originalCartId: cart.id,
      returnId: returnRecord.id,
      totals: {
        netCents: Math.round(net),
        taxCents: Math.round(tax),
        feeCents: Math.round(fee),
        grossCents: Math.round(gross)
      },
      items: details
    };
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response);
    return response;
  }
  scopeKey(actor) {
    return actor?.tenantId ?? actor?.campgroundId ?? "global";
  }
  async guardIdempotency(key, body, actor, endpoint, sequence, checksum) {
    if (!key) return null;
    return this.idempotency.start(key, body ?? {}, actor?.campgroundId ?? null, {
      tenantId: actor?.tenantId ?? null,
      endpoint,
      sequence,
      rateAction: "apply",
      checksum: checksum ?? void 0,
      requestBody: body ?? {}
    });
  }
  // TODO: Replace with full pricing/tax/fee engine
  reprice(cart) {
    let net = 0;
    let tax = 0;
    let fee = 0;
    for (const i of cart.items) {
      const base = i.unitPriceCents && i.qty ? i.unitPriceCents * i.qty : i.totalCents;
      net += base;
      tax += i.taxCents ?? 0;
      fee += i.feeCents ?? 0;
    }
    return { netCents: net, taxCents: tax, feeCents: fee, totalCents: net + tax + fee };
  }
  extractTender(payload) {
    const payments = Array.isArray(payload?.payments) ? payload.payments : [];
    return payments.map((p) => ({
      method: p?.method ?? p?.type ?? "unknown",
      amountCents: p?.amountCents ?? p?.amount ?? 0,
      referenceId: p?.referenceId ?? p?.id ?? null,
      tipCents: p?.tipCents ?? 0
    }));
  }
  extractItems(payload) {
    const items = Array.isArray(payload?.items) ? payload.items : [];
    return items.map((i) => ({
      productId: i?.productId ?? i?.id ?? null,
      qty: i?.qty ?? 1,
      unitPriceCents: i?.unitPriceCents ?? null,
      taxCents: i?.taxCents ?? 0,
      feeCents: i?.feeCents ?? 0,
      totalCents: i?.totalCents ?? i?.amountCents ?? 0,
      description: i?.name ?? i?.description ?? null
    }));
  }
  hashTotals(breakdown) {
    const json = JSON.stringify(breakdown);
    return import_crypto22.default.createHash("sha256").update(json).digest("hex");
  }
};
PosService = __decorateClass([
  (0, import_common261.Injectable)()
], PosService);

// src/pos/till.service.ts
var import_common262 = require("@nestjs/common");
var OVER_SHORT_ALERT_TOLERANCE_CENTS = 500;
var MOVEMENT_DUPLICATE_WINDOW_MINUTES = 10;
var TillMovementType2 = {
  cash_sale: "cash_sale",
  cash_refund: "cash_refund",
  paid_in: "paid_in",
  paid_out: "paid_out",
  adjustment: "adjustment"
};
var TillSessionStatus = {
  open: "open",
  closed: "closed"
};
var TillService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
  }
  async open(dto, actor) {
    if (!actor?.campgroundId || !actor?.id) throw new import_common262.BadRequestException("Missing actor context");
    if (!dto.terminalId) throw new import_common262.BadRequestException("Terminal is required to open a till");
    const existing = await this.prisma.tillSession.findFirst({
      where: {
        campgroundId: actor.campgroundId,
        status: TillSessionStatus.open,
        OR: [{ terminalId: dto.terminalId }, { openedByUserId: actor.id }]
      }
    });
    if (existing) throw new import_common262.BadRequestException("A till is already open for this user or terminal");
    const session = await this.prisma.tillSession.create({
      data: {
        campgroundId: actor.campgroundId,
        terminalId: dto.terminalId,
        openingFloatCents: dto.openingFloatCents,
        currency: dto.currency,
        notes: dto.notes,
        openedByUserId: actor.id
      }
    });
    await this.audit.record({
      campgroundId: actor.campgroundId,
      actorId: actor.id,
      action: "till_opened",
      entity: "till_session",
      entityId: session.id,
      after: {
        openingFloatCents: dto.openingFloatCents,
        terminalId: dto.terminalId,
        currency: dto.currency,
        notes: dto.notes ?? null
      }
    });
    return session;
  }
  async get(id, actor) {
    if (!actor?.campgroundId) throw new import_common262.BadRequestException("Missing actor context");
    const session = await this.prisma.tillSession.findFirst({
      where: { id, campgroundId: actor.campgroundId },
      include: { movements: true, openedBy: true, closedBy: true, terminal: true }
    });
    if (!session) throw new import_common262.NotFoundException("Till session not found");
    const expected = this.computeExpected(session.openingFloatCents, session.movements);
    return { ...session, computedExpectedCloseCents: expected, overShortCents: session.overShortCents };
  }
  async list(params, actor) {
    if (!actor?.campgroundId) throw new import_common262.BadRequestException("Missing actor context");
    return this.prisma.tillSession.findMany({
      where: {
        campgroundId: actor.campgroundId,
        status: params.status
      },
      orderBy: { openedAt: "desc" },
      take: 50
    });
  }
  async close(id, dto, actor) {
    if (!actor?.campgroundId || !actor?.id) throw new import_common262.BadRequestException("Missing actor context");
    const session = await this.prisma.tillSession.findFirst({
      where: { id, campgroundId: actor.campgroundId },
      include: { movements: true }
    });
    if (!session) throw new import_common262.NotFoundException("Till session not found");
    if (session.status === TillSessionStatus.closed) throw new import_common262.BadRequestException("Till already closed");
    const expected = this.computeExpected(session.openingFloatCents, session.movements);
    const overShort = dto.countedCloseCents - expected;
    const toleranceBreached = Math.abs(overShort) > OVER_SHORT_ALERT_TOLERANCE_CENTS;
    const updated = await this.prisma.tillSession.update({
      where: { id },
      data: {
        status: TillSessionStatus.closed,
        expectedCloseCents: expected,
        countedCloseCents: dto.countedCloseCents,
        overShortCents: overShort,
        closedAt: /* @__PURE__ */ new Date(),
        closedByUserId: actor.id,
        notes: dto.notes ?? session.notes
      }
    });
    await this.audit.record({
      campgroundId: actor.campgroundId,
      actorId: actor.id,
      action: toleranceBreached ? "till_closed_alert" : "till_closed",
      entity: "till_session",
      entityId: id,
      before: {
        status: session.status,
        expectedCloseCents: session.expectedCloseCents ?? expected,
        countedCloseCents: session.countedCloseCents ?? null,
        overShortCents: session.overShortCents ?? null
      },
      after: {
        status: updated.status,
        expectedCloseCents: expected,
        countedCloseCents: dto.countedCloseCents,
        overShortCents: overShort,
        toleranceBreached
      }
    });
    return { ...updated, overShortToleranceBreached: toleranceBreached };
  }
  async paidIn(id, dto, actor) {
    return this.recordMovement(id, TillMovementType2.paid_in, dto, actor, void 0, void 0, {
      requireReason: true,
      preventDuplicate: true
    });
  }
  async paidOut(id, dto, actor) {
    return this.recordMovement(id, TillMovementType2.paid_out, dto, actor, void 0, void 0, {
      requireReason: true,
      preventDuplicate: true,
      enforceNonNegative: true
    });
  }
  async recordCashSale(sessionId, amountCents, currency, cartId, actor) {
    return this.recordMovement(
      sessionId,
      TillMovementType2.cash_sale,
      { amountCents, note: cartId ? `cart:${cartId}` : void 0 },
      actor,
      currency,
      cartId ?? void 0
    );
  }
  async recordCashRefund(sessionId, amountCents, currency, cartId, actor) {
    return this.recordMovement(
      sessionId,
      TillMovementType2.cash_refund,
      { amountCents, note: cartId ? `cart:${cartId}` : void 0 },
      actor,
      currency,
      cartId ?? void 0,
      { enforceNonNegative: true, preventDuplicate: true }
    );
  }
  async findOpenSessionForTerminal(campgroundId, terminalId) {
    if (!campgroundId || !terminalId) return null;
    return this.prisma.tillSession.findFirst({
      where: { campgroundId, terminalId, status: TillSessionStatus.open }
    });
  }
  async recordMovement(sessionId, type, dto, actor, currencyOverride, sourceCartId, options) {
    if (!actor?.id) throw new import_common262.BadRequestException("Missing actor context");
    const session = await this.prisma.tillSession.findUnique({ where: { id: sessionId }, include: { movements: true } });
    if (!session) throw new import_common262.NotFoundException("Till session not found");
    if (session.status !== TillSessionStatus.open) throw new import_common262.BadRequestException("Till is not open");
    if (!session.terminalId) throw new import_common262.BadRequestException("Till is not assigned to a terminal");
    const currency = currencyOverride ?? session.currency;
    if (currency.toLowerCase() !== session.currency.toLowerCase()) {
      throw new import_common262.BadRequestException("Till currency mismatch");
    }
    if ((type === TillMovementType2.paid_in || type === TillMovementType2.paid_out) && options?.requireReason && !dto.reasonCode) {
      throw new import_common262.BadRequestException("reasonCode is required for paid-in/out movements");
    }
    const noteParts = [];
    if (dto.reasonCode) noteParts.push(`reason:${dto.reasonCode}`);
    if (dto.note) noteParts.push(dto.note);
    if (dto.referenceId) noteParts.push(`ref:${dto.referenceId}`);
    const finalNote = noteParts.length ? noteParts.join(" | ") : dto.note;
    const movements = session.movements ?? [];
    const expectedBefore = this.computeExpected(session.openingFloatCents, movements);
    const subtractive = type === TillMovementType2.cash_refund || type === TillMovementType2.paid_out;
    const nextExpected = subtractive ? expectedBefore - dto.amountCents : expectedBefore + dto.amountCents;
    if (options?.enforceNonNegative && nextExpected < 0) {
      throw new import_common262.BadRequestException("Movement would result in negative till balance");
    }
    if (options?.preventDuplicate) {
      const duplicate = movements.find((m) => {
        if (sourceCartId && m.sourceCartId === sourceCartId && m.type === type) return true;
        if (dto.reasonCode && m.type === type && (m.note ?? "").includes(`reason:${dto.reasonCode}`)) return true;
        if (dto.referenceId && m.type === type && (m.note ?? "").includes(`ref:${dto.referenceId}`)) return true;
        return false;
      });
      if (duplicate) throw new import_common262.BadRequestException("Duplicate or reversal movement detected");
      const recentCutoff = Date.now() - MOVEMENT_DUPLICATE_WINDOW_MINUTES * 60 * 1e3;
      const hasRecentSameAmount = movements.some(
        (m) => m.type === type && m.amountCents === dto.amountCents && m.createdAt && new Date(m.createdAt).getTime() >= recentCutoff
      );
      if (hasRecentSameAmount) throw new import_common262.BadRequestException("Recent duplicate movement detected");
    }
    const movement = await this.prisma.tillMovement.create({
      data: {
        sessionId,
        type,
        amountCents: dto.amountCents,
        currency,
        actorUserId: actor.id,
        note: finalNote,
        sourceCartId
      }
    });
    const anomaly = nextExpected < 0 || dto.amountCents > expectedBefore + OVER_SHORT_ALERT_TOLERANCE_CENTS;
    await this.audit.record({
      campgroundId: session.campgroundId,
      actorId: actor.id,
      action: anomaly ? "till_movement_alert" : "till_movement",
      entity: "till_session",
      entityId: session.id,
      before: { expected: expectedBefore },
      after: {
        type,
        amountCents: dto.amountCents,
        currency,
        note: finalNote,
        sourceCartId,
        expectedAfter: nextExpected,
        anomaly
      }
    });
    return movement;
  }
  computeExpected(openingFloat, movements) {
    let expected = openingFloat;
    for (const m of movements) {
      switch (m.type) {
        case TillMovementType2.cash_sale:
        case TillMovementType2.paid_in:
        case TillMovementType2.adjustment:
          expected += m.amountCents;
          break;
        case TillMovementType2.cash_refund:
        case TillMovementType2.paid_out:
          expected -= m.amountCents;
          break;
      }
    }
    return expected;
  }
  async dailyReport(query, actor) {
    if (!actor?.campgroundId) throw new import_common262.BadRequestException("Missing actor context");
    const targetDate = new Date(query.date);
    if (isNaN(targetDate.getTime())) throw new import_common262.BadRequestException("Invalid date");
    const start = new Date(targetDate);
    start.setUTCHours(0, 0, 0, 0);
    const end = new Date(start);
    end.setUTCDate(end.getUTCDate() + 1);
    const sessions = await this.prisma.tillSession.findMany({
      where: {
        campgroundId: actor.campgroundId,
        openedAt: { gte: start, lt: end },
        terminalId: query.terminalId ?? void 0
      },
      include: { movements: true, openedBy: true, closedBy: true, terminal: true },
      orderBy: { openedAt: "asc" }
    });
    let totalOpeningFloat = 0;
    let totalCashSales = 0;
    let totalCashRefunds = 0;
    let totalPaidIn = 0;
    let totalPaidOut = 0;
    let totalExpected = 0;
    let totalCounted = 0;
    let totalOverShort = 0;
    const sessionSummaries = sessions.map((s) => {
      const currency = s.currency;
      const movements = s.movements.filter((m) => m.currency.toLowerCase() === currency.toLowerCase());
      const expected = this.computeExpected(s.openingFloatCents, movements);
      const cashSales = movements.filter((m) => m.type === TillMovementType2.cash_sale).reduce((n, m) => n + m.amountCents, 0);
      const cashRefunds = movements.filter((m) => m.type === TillMovementType2.cash_refund).reduce((n, m) => n + m.amountCents, 0);
      const paidIn = movements.filter((m) => m.type === TillMovementType2.paid_in).reduce((n, m) => n + m.amountCents, 0);
      const paidOut = movements.filter((m) => m.type === TillMovementType2.paid_out).reduce((n, m) => n + m.amountCents, 0);
      const counted = s.countedCloseCents ?? null;
      const overShort = counted !== null ? counted - expected : null;
      totalOpeningFloat += s.openingFloatCents;
      totalCashSales += cashSales;
      totalCashRefunds += cashRefunds;
      totalPaidIn += paidIn;
      totalPaidOut += paidOut;
      totalExpected += expected;
      if (counted !== null) {
        totalCounted += counted;
        totalOverShort += overShort ?? 0;
      }
      return {
        id: s.id,
        terminalId: s.terminalId,
        status: s.status,
        currency,
        openingFloatCents: s.openingFloatCents,
        cashSalesCents: cashSales,
        cashRefundsCents: cashRefunds,
        paidInCents: paidIn,
        paidOutCents: paidOut,
        expectedCloseCents: expected,
        countedCloseCents: counted,
        overShortCents: overShort,
        openedAt: s.openedAt,
        closedAt: s.closedAt,
        openedBy: s.openedBy ? { id: s.openedBy.id, email: s.openedBy.email } : null,
        closedBy: s.closedBy ? { id: s.closedBy.id, email: s.closedBy.email } : null,
        terminal: s.terminal ? { id: s.terminal.id, locationId: s.terminal.locationId } : null
      };
    });
    return {
      date: start.toISOString().slice(0, 10),
      totals: {
        openingFloatCents: totalOpeningFloat,
        cashSalesCents: totalCashSales,
        cashRefundsCents: totalCashRefunds,
        paidInCents: totalPaidIn,
        paidOutCents: totalPaidOut,
        expectedCloseCents: totalExpected,
        countedCloseCents: totalCounted,
        overShortCents: totalOverShort
      },
      sessions: sessionSummaries
    };
  }
  async dailyReportCsv(query, actor) {
    const report = await this.dailyReport(query, actor);
    const header = [
      "date",
      "terminalId",
      "status",
      "currency",
      "openingFloatCents",
      "cashSalesCents",
      "cashRefundsCents",
      "paidInCents",
      "paidOutCents",
      "expectedCloseCents",
      "countedCloseCents",
      "overShortCents",
      "openedAt",
      "closedAt",
      "openedByEmail",
      "closedByEmail"
    ];
    const rows = report.sessions.map((s) => [
      report.date,
      s.terminalId ?? "",
      s.status,
      s.currency,
      s.openingFloatCents,
      s.cashSalesCents,
      s.cashRefundsCents,
      s.paidInCents,
      s.paidOutCents,
      s.expectedCloseCents,
      s.countedCloseCents ?? "",
      s.overShortCents ?? "",
      s.openedAt?.toISOString?.() ?? "",
      s.closedAt?.toISOString?.() ?? "",
      s.openedBy?.email ?? "",
      s.closedBy?.email ?? ""
    ]);
    const totalRow = [
      report.date,
      "TOTAL",
      "",
      "",
      report.totals.openingFloatCents,
      report.totals.cashSalesCents,
      report.totals.cashRefundsCents,
      report.totals.paidInCents,
      report.totals.paidOutCents,
      report.totals.expectedCloseCents,
      report.totals.countedCloseCents,
      report.totals.overShortCents,
      "",
      "",
      "",
      ""
    ];
    const csvLines = [header, ...rows, totalRow].map((r) => r.join(","));
    return {
      filename: `till-daily-${report.date}.csv`,
      csv: csvLines.join("\n")
    };
  }
};
TillService = __decorateClass([
  (0, import_common262.Injectable)()
], TillService);

// src/pos/till.controller.ts
var import_common263 = require("@nestjs/common");
var TillController = class {
  constructor(service) {
    this.service = service;
  }
  open(dto, req) {
    return this.service.open(dto, req.user);
  }
  list(query, req) {
    return this.service.list(query, req.user);
  }
  get(id, req) {
    return this.service.get(id, req.user);
  }
  daily(query, req) {
    return this.service.dailyReport(query, req.user);
  }
  async dailyCsv(query, req, res) {
    const { filename, csv } = await this.service.dailyReportCsv(query, req.user);
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    return csv;
  }
  close(id, dto, req) {
    return this.service.close(id, dto, req.user);
  }
  paidIn(id, dto, req) {
    return this.service.paidIn(id, dto, req.user);
  }
  paidOut(id, dto, req) {
    return this.service.paidOut(id, dto, req.user);
  }
};
__decorateClass([
  (0, import_common263.Post)("open"),
  __decorateParam(0, (0, import_common263.Body)()),
  __decorateParam(1, (0, import_common263.Req)())
], TillController.prototype, "open", 1);
__decorateClass([
  (0, import_common263.Get)(),
  __decorateParam(0, (0, import_common263.Query)()),
  __decorateParam(1, (0, import_common263.Req)())
], TillController.prototype, "list", 1);
__decorateClass([
  (0, import_common263.Get)(":id"),
  __decorateParam(0, (0, import_common263.Param)("id")),
  __decorateParam(1, (0, import_common263.Req)())
], TillController.prototype, "get", 1);
__decorateClass([
  (0, import_common263.Get)("report/daily"),
  __decorateParam(0, (0, import_common263.Query)()),
  __decorateParam(1, (0, import_common263.Req)())
], TillController.prototype, "daily", 1);
__decorateClass([
  (0, import_common263.Get)("report/daily.csv"),
  __decorateParam(0, (0, import_common263.Query)()),
  __decorateParam(1, (0, import_common263.Req)()),
  __decorateParam(2, (0, import_common263.Res)({ passthrough: true }))
], TillController.prototype, "dailyCsv", 1);
__decorateClass([
  (0, import_common263.Post)(":id/close"),
  __decorateParam(0, (0, import_common263.Param)("id")),
  __decorateParam(1, (0, import_common263.Body)()),
  __decorateParam(2, (0, import_common263.Req)())
], TillController.prototype, "close", 1);
__decorateClass([
  (0, import_common263.Post)(":id/paid-in"),
  __decorateParam(0, (0, import_common263.Param)("id")),
  __decorateParam(1, (0, import_common263.Body)()),
  __decorateParam(2, (0, import_common263.Req)())
], TillController.prototype, "paidIn", 1);
__decorateClass([
  (0, import_common263.Post)(":id/paid-out"),
  __decorateParam(0, (0, import_common263.Param)("id")),
  __decorateParam(1, (0, import_common263.Body)()),
  __decorateParam(2, (0, import_common263.Req)())
], TillController.prototype, "paidOut", 1);
TillController = __decorateClass([
  (0, import_common263.UseGuards)(JwtAuthGuard),
  (0, import_common263.Controller)("pos/tills")
], TillController);

// src/pos/pos-provider.controller.ts
var import_common264 = require("@nestjs/common");
var PosProviderController = class {
  constructor(service) {
    this.service = service;
  }
  list(req) {
    return this.service.listIntegrations(req.user?.campgroundId);
  }
  configure(provider, dto, req) {
    return this.service.upsertIntegration(req.user?.campgroundId, provider, dto, req.user);
  }
  validate(provider, dto, req) {
    return this.service.validateCredentials(req.user?.campgroundId, provider, dto);
  }
  status(provider, req) {
    return this.service.syncStatus(req.user?.campgroundId, provider);
  }
  triggerSync(provider, dto, req) {
    return this.service.syncIntegration(req.user?.campgroundId, provider, dto.target);
  }
  webhook(provider, campgroundId, body, req) {
    const rawBody = req.rawBody ? req.rawBody.toString() : JSON.stringify(body ?? {});
    return this.service.handleWebhook(provider, campgroundId, body, req.headers, rawBody);
  }
};
__decorateClass([
  (0, import_common264.UseGuards)(JwtAuthGuard),
  (0, import_common264.Get)(),
  __decorateParam(0, (0, import_common264.Req)())
], PosProviderController.prototype, "list", 1);
__decorateClass([
  (0, import_common264.UseGuards)(JwtAuthGuard),
  (0, import_common264.Post)(":provider/config"),
  __decorateParam(0, (0, import_common264.Param)("provider")),
  __decorateParam(1, (0, import_common264.Body)()),
  __decorateParam(2, (0, import_common264.Req)())
], PosProviderController.prototype, "configure", 1);
__decorateClass([
  (0, import_common264.UseGuards)(JwtAuthGuard),
  (0, import_common264.Post)(":provider/validate"),
  __decorateParam(0, (0, import_common264.Param)("provider")),
  __decorateParam(1, (0, import_common264.Body)()),
  __decorateParam(2, (0, import_common264.Req)())
], PosProviderController.prototype, "validate", 1);
__decorateClass([
  (0, import_common264.UseGuards)(JwtAuthGuard),
  (0, import_common264.Get)(":provider/status"),
  __decorateParam(0, (0, import_common264.Param)("provider")),
  __decorateParam(1, (0, import_common264.Req)())
], PosProviderController.prototype, "status", 1);
__decorateClass([
  (0, import_common264.UseGuards)(JwtAuthGuard),
  (0, import_common264.Post)(":provider/sync"),
  __decorateParam(0, (0, import_common264.Param)("provider")),
  __decorateParam(1, (0, import_common264.Body)()),
  __decorateParam(2, (0, import_common264.Req)())
], PosProviderController.prototype, "triggerSync", 1);
__decorateClass([
  (0, import_common264.Post)(":provider/webhook/:campgroundId"),
  __decorateParam(0, (0, import_common264.Param)("provider")),
  __decorateParam(1, (0, import_common264.Param)("campgroundId")),
  __decorateParam(2, (0, import_common264.Body)()),
  __decorateParam(3, (0, import_common264.Req)())
], PosProviderController.prototype, "webhook", 1);
PosProviderController = __decorateClass([
  (0, import_common264.Controller)("pos/providers")
], PosProviderController);

// src/pos/pos-provider.service.ts
var import_common265 = require("@nestjs/common");
var import_client51 = require("@prisma/client");
var PosProviderService = class {
  constructor(prisma, registry, audit, idempotency, clover, square, toast) {
    this.prisma = prisma;
    this.registry = registry;
    this.audit = audit;
    this.idempotency = idempotency;
    this.logger = new import_common265.Logger(PosProviderService.name);
    [clover, square, toast].forEach(() => null);
  }
  normalizeProvider(provider) {
    const normalized = provider.toLowerCase();
    if (!Object.values(import_client51.PosProviderType).includes(normalized)) {
      throw new import_common265.BadRequestException("Unsupported provider");
    }
    return normalized;
  }
  normalizeCapabilities(capabilities) {
    if (!capabilities?.length) return [import_client51.PosProviderCapability.payments];
    return capabilities.map((c) => c.toLowerCase()).filter((c) => Object.values(import_client51.PosProviderCapability).includes(c));
  }
  mapIntegration(record) {
    return {
      id: record.id,
      campgroundId: record.campgroundId,
      provider: record.provider,
      displayName: record.displayName,
      status: record.status,
      capabilities: record.capabilities ?? [],
      credentials: record.credentials ?? {},
      locations: record.locations ?? void 0,
      devices: record.devices ?? void 0,
      webhookSecret: record.webhookSecret ?? null
    };
  }
  getAdapter(provider) {
    const adapter = this.registry.getAdapter(provider);
    if (!adapter) throw new import_common265.BadRequestException("Provider adapter not registered");
    return adapter;
  }
  async listIntegrations(campgroundId) {
    const records = await this.prisma.posProviderIntegration.findMany({ where: { campgroundId } });
    return records.map((r) => this.mapIntegration(r));
  }
  async upsertIntegration(campgroundId, providerInput, dto, actor) {
    const provider = this.normalizeProvider(providerInput);
    const capabilities = this.normalizeCapabilities(dto.capabilities);
    const status = dto.enabled === false ? import_client51.PosIntegrationStatus.disabled : dto.enabled === true ? import_client51.PosIntegrationStatus.enabled : void 0;
    const integration = await this.prisma.posProviderIntegration.upsert({
      where: { campgroundId_provider: { campgroundId, provider } },
      create: {
        campgroundId,
        provider,
        displayName: dto.displayName ?? provider,
        capabilities,
        credentials: dto.credentials ?? {},
        locations: dto.locations ?? {},
        devices: dto.devices ?? {},
        webhookSecret: dto.webhookSecret ?? null,
        status: status ?? import_client51.PosIntegrationStatus.enabled,
        lastValidatedAt: /* @__PURE__ */ new Date()
      },
      update: {
        displayName: dto.displayName ?? void 0,
        capabilities,
        credentials: dto.credentials ?? {},
        locations: dto.locations ?? {},
        devices: dto.devices ?? {},
        webhookSecret: dto.webhookSecret ?? void 0,
        status: status ?? void 0,
        lastValidatedAt: /* @__PURE__ */ new Date()
      }
    });
    await this.audit.record({
      campgroundId,
      actorId: actor?.id ?? null,
      action: "pos.provider.upsert",
      entity: "pos_provider",
      entityId: integration.id,
      after: { provider, capabilities, status: integration.status }
    });
    return this.mapIntegration(integration);
  }
  async validateCredentials(campgroundId, providerInput, payload) {
    const provider = this.normalizeProvider(providerInput);
    const adapter = this.getAdapter(provider);
    const capabilities = this.normalizeCapabilities(payload.capabilities);
    const integration = {
      id: payload.id ?? `temp-${provider}`,
      campgroundId,
      provider,
      capabilities,
      credentials: payload.credentials ?? {},
      locations: payload.locations ?? {},
      devices: payload.devices ?? {},
      webhookSecret: payload.webhookSecret ?? null
    };
    const result = await adapter.validateCredentials(integration);
    await this.prisma.posProviderIntegration.updateMany({
      where: { campgroundId, provider },
      data: {
        lastValidatedAt: /* @__PURE__ */ new Date(),
        status: result.ok ? import_client51.PosIntegrationStatus.enabled : import_client51.PosIntegrationStatus.error
      }
    });
    return result;
  }
  async syncIntegration(campgroundId, providerInput, target) {
    const provider = this.normalizeProvider(providerInput);
    const integration = await this.prisma.posProviderIntegration.findUnique({
      where: { campgroundId_provider: { campgroundId, provider } }
    });
    if (!integration) throw new import_common265.NotFoundException("Integration not configured");
    const adapter = this.getAdapter(provider);
    const record = this.mapIntegration(integration);
    const result = target === import_client51.PosSyncTarget.catalog ? await adapter.syncCatalog(record) : await adapter.syncTenders(record);
    const syncStatus = result.status ?? import_client51.PosSyncStatus.running;
    const syncPayload = {
      status: syncStatus,
      lastRunAt: /* @__PURE__ */ new Date(),
      lastError: syncStatus === import_client51.PosSyncStatus.failed ? result.message ?? "sync_failed" : null,
      metadata: result.metadata ?? null
    };
    await this.prisma.posProviderSync.upsert({
      where: { integrationId_type: { integrationId: integration.id, type: target } },
      create: {
        integrationId: integration.id,
        type: target,
        ...syncPayload
      },
      update: syncPayload
    });
    return { integration: record, result };
  }
  async syncStatus(campgroundId, providerInput) {
    const provider = providerInput ? this.normalizeProvider(providerInput) : null;
    return this.prisma.posProviderSync.findMany({
      where: {
        integration: {
          campgroundId,
          provider: provider ?? void 0
        }
      },
      include: { integration: true },
      orderBy: { updatedAt: "desc" },
      take: 20
    });
  }
  async routePayment(campgroundId, terminalId, payment) {
    if (!campgroundId) return null;
    const integration = await this.prisma.posProviderIntegration.findFirst({
      where: {
        campgroundId,
        status: import_client51.PosIntegrationStatus.enabled,
        capabilities: { has: import_client51.PosProviderCapability.payments }
      }
    });
    if (!integration) return null;
    const adapter = this.getAdapter(integration.provider);
    const result = await adapter.processPayment(this.mapIntegration(integration), { ...payment, terminalId });
    if (!result) return null;
    await this.audit.record({
      campgroundId,
      actorId: null,
      action: "pos.provider.payment_routed",
      entity: "pos_provider",
      entityId: integration.id,
      after: { provider: integration.provider, status: result.status }
    });
    return { ...result, provider: integration.provider };
  }
  async handleWebhook(providerInput, campgroundId, body, headers = {}, rawBody) {
    const provider = this.normalizeProvider(providerInput);
    const integrationRecord = await this.prisma.posProviderIntegration.findUnique({
      where: { campgroundId_provider: { campgroundId, provider } }
    });
    if (!integrationRecord) throw new import_common265.NotFoundException("Integration not configured");
    const integration = this.mapIntegration(integrationRecord);
    const adapter = this.getAdapter(provider);
    const signature = headers["x-pos-signature"] ?? headers["x-square-signature"] ?? headers["x-clover-signature"] ?? headers["x-toast-signature"] ?? "";
    const raw = rawBody || JSON.stringify(body ?? {});
    const verified = await adapter.verifyWebhookSignature({
      signature,
      rawBody: raw,
      secret: integration.webhookSecret ?? integration.credentials?.webhookSecret ?? null,
      integration
    });
    if (!verified) {
      throw new import_common265.UnauthorizedException("Invalid webhook signature");
    }
    const eventId = headers["x-event-id"] ?? (body?.eventId ?? body?.id ?? body?.data?.id);
    const idempotencyKey = eventId ? `pos-webhook-${provider}-${eventId}` : null;
    if (idempotencyKey) {
      const existing = await this.idempotency.start(idempotencyKey, body ?? {}, campgroundId, {
        endpoint: `pos/providers/${provider}/webhook`,
        sequence: eventId ?? void 0,
        rateAction: "apply"
      }).catch((err) => {
        this.logger.warn(`Idempotency start failed: ${err?.message ?? err}`);
        return null;
      });
      if (existing?.status === import_client51.IdempotencyStatus.succeeded && existing.responseJson) {
        return { ...existing.responseJson, deduped: true };
      }
      if (existing?.status === import_client51.IdempotencyStatus.inflight) {
        return { acknowledged: false, deduped: true, message: "webhook_inflight" };
      }
    }
    const result = adapter.handlePaymentWebhook ? await adapter.handlePaymentWebhook({ integration, body, headers }) : { acknowledged: true, message: "webhook_acknowledged" };
    if (idempotencyKey) {
      await this.idempotency.complete(idempotencyKey, result).catch(() => null);
    }
    return result;
  }
};
PosProviderService = __decorateClass([
  (0, import_common265.Injectable)()
], PosProviderService);

// src/pos/pos-provider.registry.ts
var import_common266 = require("@nestjs/common");
var PosProviderRegistry = class {
  constructor(clover, square, toast) {
    this.adapters = /* @__PURE__ */ new Map([
      [clover.provider, clover],
      [square.provider, square],
      [toast.provider, toast]
    ]);
  }
  getAdapter(provider) {
    return this.adapters.get(provider) ?? null;
  }
  supportedProviders() {
    return Array.from(this.adapters.keys());
  }
};
PosProviderRegistry = __decorateClass([
  (0, import_common266.Injectable)()
], PosProviderRegistry);

// src/pos/pos-provider.adapters.ts
var import_common267 = require("@nestjs/common");
var import_crypto23 = __toESM(require("crypto"));
var PosProviderType2 = {
  clover: "clover",
  square: "square",
  toast: "toast"
};
var PosSyncStatus2 = {
  running: "running",
  completed: "completed",
  failed: "failed"
};
var PosSyncTarget2 = {
  catalog: "catalog",
  tenders: "tenders",
  orders: "orders"
};
var BasePosProviderAdapter = class {
  constructor() {
    this.logger = new import_common267.Logger(BasePosProviderAdapter.name);
  }
  async validateCredentials(config2) {
    const hasCredentials = Boolean(config2.credentials && Object.keys(config2.credentials).length);
    return {
      ok: hasCredentials,
      message: hasCredentials ? "Credentials present (stubbed validation)" : "Missing credentials"
    };
  }
  async syncCatalog(config2) {
    this.logger.debug(`Catalog sync requested for ${config2.provider}`);
    return { started: true, target: PosSyncTarget2.catalog, status: PosSyncStatus2.running };
  }
  async syncTenders(config2) {
    this.logger.debug(`Tender sync requested for ${config2.provider}`);
    return { started: true, target: PosSyncTarget2.tenders, status: PosSyncStatus2.running };
  }
  async processPayment(config2, request) {
    this.logger.log(`Routing payment via ${config2.provider} (stub)`);
    return {
      status: "pending",
      processorIds: {
        provider: config2.provider,
        idempotencyKey: request.idempotencyKey
      },
      raw: { note: "stubbed payment response" }
    };
  }
  verifyWebhookSignature(input) {
    if (!input.secret) return true;
    const digest = import_crypto23.default.createHmac("sha256", input.secret).update(input.rawBody).digest("hex");
    return digest === input.signature;
  }
  async handlePaymentWebhook(input) {
    this.logger.debug(`Webhook received for ${input.integration.provider}`);
    return { acknowledged: true, message: "stubbed_webhook_handler" };
  }
};
BasePosProviderAdapter = __decorateClass([
  (0, import_common267.Injectable)()
], BasePosProviderAdapter);
var CloverAdapter = class extends BasePosProviderAdapter {
  constructor() {
    super(...arguments);
    this.provider = PosProviderType2.clover;
  }
};
CloverAdapter = __decorateClass([
  (0, import_common267.Injectable)()
], CloverAdapter);
var SquareAdapter = class extends BasePosProviderAdapter {
  constructor() {
    super(...arguments);
    this.provider = PosProviderType2.square;
  }
};
SquareAdapter = __decorateClass([
  (0, import_common267.Injectable)()
], SquareAdapter);
var ToastAdapter = class extends BasePosProviderAdapter {
  constructor() {
    super(...arguments);
    this.provider = PosProviderType2.toast;
  }
};
ToastAdapter = __decorateClass([
  (0, import_common267.Injectable)()
], ToastAdapter);

// src/pos/pos.module.ts
var PosModule = class {
};
PosModule = __decorateClass([
  (0, import_common268.Module)({
    imports: [StoredValueModule],
    controllers: [PosController, TillController, PosProviderController],
    providers: [
      PosService,
      PrismaService,
      IdempotencyService,
      StoredValueService,
      StripeService,
      TillService,
      AuditService,
      PosProviderService,
      PosProviderRegistry,
      CloverAdapter,
      SquareAdapter,
      ToastAdapter,
      EmailService
    ],
    exports: [PosService, TillService, PosProviderService]
  })
], PosModule);

// src/dynamic-pricing/dynamic-pricing.module.ts
var import_common271 = require("@nestjs/common");

// src/dynamic-pricing/dynamic-pricing.service.ts
var import_common269 = require("@nestjs/common");
var DynamicPricingService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async createRule(dto) {
    return this.prisma.dynamicPricingRule.create({
      data: {
        campgroundId: dto.campgroundId,
        name: dto.name,
        trigger: dto.trigger,
        conditions: dto.conditions,
        adjustmentType: dto.adjustmentType,
        adjustmentValue: dto.adjustmentValue,
        priority: dto.priority ?? 100,
        siteClassIds: dto.siteClassIds ?? [],
        isActive: dto.isActive ?? true,
        validFrom: dto.validFrom ? new Date(dto.validFrom) : null,
        validTo: dto.validTo ? new Date(dto.validTo) : null
      }
    });
  }
  async listRules(campgroundId, includeInactive = false) {
    return this.prisma.dynamicPricingRule.findMany({
      where: {
        campgroundId,
        ...includeInactive ? {} : { isActive: true }
      },
      orderBy: { priority: "asc" }
    });
  }
  async getRule(id) {
    const rule = await this.prisma.dynamicPricingRule.findUnique({ where: { id } });
    if (!rule) throw new import_common269.NotFoundException("Rule not found");
    return rule;
  }
  async updateRule(id, dto) {
    const existing = await this.getRule(id);
    return this.prisma.dynamicPricingRule.update({
      where: { id },
      data: {
        name: dto.name,
        trigger: dto.trigger,
        conditions: dto.conditions,
        adjustmentType: dto.adjustmentType,
        adjustmentValue: dto.adjustmentValue,
        priority: dto.priority,
        siteClassIds: dto.siteClassIds,
        isActive: dto.isActive,
        validFrom: dto.validFrom ? new Date(dto.validFrom) : void 0,
        validTo: dto.validTo ? new Date(dto.validTo) : void 0
      }
    });
  }
  async deleteRule(id) {
    await this.getRule(id);
    return this.prisma.dynamicPricingRule.delete({ where: { id } });
  }
  /**
   * Calculate price adjustment based on occupancy and rules
   */
  async calculateAdjustment(campgroundId, siteClassId, targetDate, basePrice) {
    const now = /* @__PURE__ */ new Date();
    const daysOut = Math.ceil((targetDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
    const occupancy = await this.getOccupancyForDate(campgroundId, targetDate);
    const rules = await this.prisma.dynamicPricingRule.findMany({
      where: {
        campgroundId,
        isActive: true,
        OR: [
          { validFrom: null, validTo: null },
          { validFrom: { lte: now }, validTo: { gte: now } }
        ]
      },
      orderBy: { priority: "asc" }
    });
    let adjustedPrice = basePrice;
    const appliedRules = [];
    for (const rule of rules) {
      if (rule.siteClassIds.length > 0 && siteClassId && !rule.siteClassIds.includes(siteClassId)) {
        continue;
      }
      const conditions = rule.conditions;
      if (!this.matchesConditions(conditions, occupancy, daysOut)) {
        continue;
      }
      if (rule.adjustmentType === "percent") {
        adjustedPrice = adjustedPrice * (1 + rule.adjustmentValue / 100);
      } else {
        adjustedPrice = adjustedPrice + rule.adjustmentValue;
      }
      appliedRules.push(rule.name);
    }
    return {
      adjustedPrice: Math.round(adjustedPrice),
      appliedRules
    };
  }
  matchesConditions(conditions, occupancy, daysOut) {
    if (conditions.occupancyMin !== void 0 && occupancy < conditions.occupancyMin) return false;
    if (conditions.occupancyMax !== void 0 && occupancy > conditions.occupancyMax) return false;
    if (conditions.daysOutMin !== void 0 && daysOut < conditions.daysOutMin) return false;
    if (conditions.daysOutMax !== void 0 && daysOut > conditions.daysOutMax) return false;
    return true;
  }
  async getOccupancyForDate(campgroundId, date) {
    const snapshot = await this.prisma.occupancySnapshot.findUnique({
      where: {
        campgroundId_date: {
          campgroundId,
          date
        }
      }
    });
    if (snapshot) {
      return snapshot.occupancyPct;
    }
    const totalSites = await this.prisma.site.count({
      where: { campgroundId, isActive: true }
    });
    if (totalSites === 0) return 0;
    const occupied = await this.prisma.reservation.count({
      where: {
        campgroundId,
        arrivalDate: { lte: date },
        departureDate: { gt: date },
        status: { in: ["confirmed", "checked_in"] }
      }
    });
    return occupied / totalSites * 100;
  }
  /**
   * Record occupancy snapshot for analytics
   */
  async recordOccupancySnapshot(campgroundId, date) {
    const totalSites = await this.prisma.site.count({
      where: { campgroundId, isActive: true }
    });
    const occupied = await this.prisma.reservation.count({
      where: {
        campgroundId,
        arrivalDate: { lte: date },
        departureDate: { gt: date },
        status: { in: ["confirmed", "checked_in"] }
      }
    });
    const blocked = await this.prisma.maintenanceTicket.count({
      where: {
        campgroundId,
        outOfOrder: true,
        OR: [
          { outOfOrderUntil: null },
          { outOfOrderUntil: { gte: date } }
        ]
      }
    });
    const available = totalSites - occupied - blocked;
    const occupancyPct = totalSites > 0 ? occupied / totalSites * 100 : 0;
    const revenue = await this.prisma.reservation.aggregate({
      where: {
        campgroundId,
        arrivalDate: { lte: date },
        departureDate: { gt: date },
        status: { in: ["confirmed", "checked_in", "checked_out"] }
      },
      _sum: { totalAmount: true }
    });
    return this.prisma.occupancySnapshot.upsert({
      where: { campgroundId_date: { campgroundId, date } },
      update: {
        totalSites,
        occupied,
        blocked,
        available,
        occupancyPct,
        revenueCents: revenue._sum.totalAmount ?? 0
      },
      create: {
        campgroundId,
        date,
        totalSites,
        occupied,
        blocked,
        available,
        occupancyPct,
        revenueCents: revenue._sum.totalAmount ?? 0
      }
    });
  }
  /**
   * Generate revenue forecast
   */
  async generateForecast(campgroundId, daysAhead = 30) {
    const forecasts = [];
    const now = /* @__PURE__ */ new Date();
    for (let i = 0; i < daysAhead; i++) {
      const targetDate = new Date(now);
      targetDate.setDate(now.getDate() + i);
      targetDate.setHours(0, 0, 0, 0);
      const reservations = await this.prisma.reservation.findMany({
        where: {
          campgroundId,
          arrivalDate: { lte: targetDate },
          departureDate: { gt: targetDate },
          status: { in: ["confirmed", "checked_in"] }
        },
        select: { totalAmount: true }
      });
      const projectedRev = reservations.reduce((sum, r) => sum + r.totalAmount, 0);
      const totalSites = await this.prisma.site.count({
        where: { campgroundId, isActive: true }
      });
      const occupancyPct = totalSites > 0 ? reservations.length / totalSites * 100 : 0;
      const forecast = await this.prisma.revenueForecast.upsert({
        where: { campgroundId_forecastDate: { campgroundId, forecastDate: targetDate } },
        update: {
          projectedRev,
          occupancyPct,
          confidence: i < 7 ? 0.9 : i < 14 ? 0.7 : 0.5
        },
        create: {
          campgroundId,
          forecastDate: targetDate,
          projectedRev,
          occupancyPct,
          confidence: i < 7 ? 0.9 : i < 14 ? 0.7 : 0.5
        }
      });
      forecasts.push(forecast);
    }
    return forecasts;
  }
  async getForecasts(campgroundId, startDate, endDate) {
    return this.prisma.revenueForecast.findMany({
      where: {
        campgroundId,
        forecastDate: { gte: startDate, lte: endDate }
      },
      orderBy: { forecastDate: "asc" }
    });
  }
};
DynamicPricingService = __decorateClass([
  (0, import_common269.Injectable)()
], DynamicPricingService);

// src/dynamic-pricing/dynamic-pricing.controller.ts
var import_common270 = require("@nestjs/common");
var DynamicPricingController = class {
  constructor(service) {
    this.service = service;
  }
  createRule(dto) {
    return this.service.createRule(dto);
  }
  listRules(campgroundId, includeInactive) {
    return this.service.listRules(campgroundId, includeInactive === "true");
  }
  getRule(id) {
    return this.service.getRule(id);
  }
  updateRule(id, dto) {
    return this.service.updateRule(id, dto);
  }
  deleteRule(id) {
    return this.service.deleteRule(id);
  }
  calculateAdjustment(campgroundId, siteClassId, date, basePrice) {
    return this.service.calculateAdjustment(
      campgroundId,
      siteClassId,
      new Date(date),
      parseInt(basePrice, 10)
    );
  }
  recordOccupancySnapshot(dto) {
    return this.service.recordOccupancySnapshot(dto.campgroundId, new Date(dto.date));
  }
  getOccupancy(campgroundId, date) {
    return this.service.getOccupancyForDate(campgroundId, new Date(date));
  }
  generateForecast(dto) {
    return this.service.generateForecast(dto.campgroundId, dto.daysAhead);
  }
  getForecasts(campgroundId, startDate, endDate) {
    return this.service.getForecasts(
      campgroundId,
      new Date(startDate),
      new Date(endDate)
    );
  }
};
__decorateClass([
  (0, import_common270.Post)("rules"),
  __decorateParam(0, (0, import_common270.Body)())
], DynamicPricingController.prototype, "createRule", 1);
__decorateClass([
  (0, import_common270.Get)("rules"),
  __decorateParam(0, (0, import_common270.Query)("campgroundId")),
  __decorateParam(1, (0, import_common270.Query)("includeInactive"))
], DynamicPricingController.prototype, "listRules", 1);
__decorateClass([
  (0, import_common270.Get)("rules/:id"),
  __decorateParam(0, (0, import_common270.Param)("id"))
], DynamicPricingController.prototype, "getRule", 1);
__decorateClass([
  (0, import_common270.Patch)("rules/:id"),
  __decorateParam(0, (0, import_common270.Param)("id")),
  __decorateParam(1, (0, import_common270.Body)())
], DynamicPricingController.prototype, "updateRule", 1);
__decorateClass([
  (0, import_common270.Delete)("rules/:id"),
  __decorateParam(0, (0, import_common270.Param)("id"))
], DynamicPricingController.prototype, "deleteRule", 1);
__decorateClass([
  (0, import_common270.Get)("calculate"),
  __decorateParam(0, (0, import_common270.Query)("campgroundId")),
  __decorateParam(1, (0, import_common270.Query)("siteClassId")),
  __decorateParam(2, (0, import_common270.Query)("date")),
  __decorateParam(3, (0, import_common270.Query)("basePrice"))
], DynamicPricingController.prototype, "calculateAdjustment", 1);
__decorateClass([
  (0, import_common270.Post)("occupancy-snapshot"),
  __decorateParam(0, (0, import_common270.Body)())
], DynamicPricingController.prototype, "recordOccupancySnapshot", 1);
__decorateClass([
  (0, import_common270.Get)("occupancy"),
  __decorateParam(0, (0, import_common270.Query)("campgroundId")),
  __decorateParam(1, (0, import_common270.Query)("date"))
], DynamicPricingController.prototype, "getOccupancy", 1);
__decorateClass([
  (0, import_common270.Post)("forecasts/generate"),
  __decorateParam(0, (0, import_common270.Body)())
], DynamicPricingController.prototype, "generateForecast", 1);
__decorateClass([
  (0, import_common270.Get)("forecasts"),
  __decorateParam(0, (0, import_common270.Query)("campgroundId")),
  __decorateParam(1, (0, import_common270.Query)("startDate")),
  __decorateParam(2, (0, import_common270.Query)("endDate"))
], DynamicPricingController.prototype, "getForecasts", 1);
DynamicPricingController = __decorateClass([
  (0, import_common270.Controller)("dynamic-pricing"),
  (0, import_common270.UseGuards)(JwtAuthGuard)
], DynamicPricingController);

// src/dynamic-pricing/dynamic-pricing.module.ts
var DynamicPricingModule = class {
};
DynamicPricingModule = __decorateClass([
  (0, import_common271.Module)({
    imports: [PrismaModule],
    controllers: [DynamicPricingController],
    providers: [DynamicPricingService],
    exports: [DynamicPricingService]
  })
], DynamicPricingModule);

// src/workflows/workflows.module.ts
var import_common274 = require("@nestjs/common");

// src/workflows/workflows.service.ts
var import_common272 = require("@nestjs/common");
var import_schedule15 = require("@nestjs/schedule");
var WorkflowsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  async createWorkflow(dto) {
    return this.prisma.communicationWorkflow.create({
      data: {
        campgroundId: dto.campgroundId,
        name: dto.name,
        description: dto.description,
        trigger: dto.trigger,
        triggerValue: dto.triggerValue,
        conditions: dto.conditions,
        status: dto.status ?? "draft",
        priority: dto.priority ?? 100
      }
    });
  }
  async listWorkflows(campgroundId, status) {
    return this.prisma.communicationWorkflow.findMany({
      where: {
        campgroundId,
        ...status ? { status } : {}
      },
      include: {
        steps: { orderBy: { stepOrder: "asc" } },
        _count: { select: { executions: true } }
      },
      orderBy: { priority: "asc" }
    });
  }
  async getWorkflow(id) {
    const workflow = await this.prisma.communicationWorkflow.findUnique({
      where: { id },
      include: {
        steps: { orderBy: { stepOrder: "asc" } },
        executions: { take: 10, orderBy: { createdAt: "desc" } }
      }
    });
    if (!workflow) throw new import_common272.NotFoundException("Workflow not found");
    return workflow;
  }
  async updateWorkflow(id, dto) {
    await this.getWorkflow(id);
    return this.prisma.communicationWorkflow.update({
      where: { id },
      data: dto
    });
  }
  async deleteWorkflow(id) {
    await this.getWorkflow(id);
    return this.prisma.communicationWorkflow.delete({ where: { id } });
  }
  async addStep(workflowId, dto) {
    await this.getWorkflow(workflowId);
    return this.prisma.workflowStep.create({
      data: {
        workflowId,
        stepOrder: dto.stepOrder,
        actionType: dto.actionType,
        config: dto.config,
        isActive: dto.isActive ?? true
      }
    });
  }
  async updateStep(stepId, dto) {
    return this.prisma.workflowStep.update({
      where: { id: stepId },
      data: dto
    });
  }
  async deleteStep(stepId) {
    return this.prisma.workflowStep.delete({ where: { id: stepId } });
  }
  /**
   * Trigger a workflow execution for a reservation/guest
   */
  async triggerWorkflow(workflowId, context) {
    const workflow = await this.getWorkflow(workflowId);
    if (workflow.status !== "active") {
      throw new Error("Workflow is not active");
    }
    return this.prisma.workflowExecution.create({
      data: {
        workflowId,
        reservationId: context.reservationId,
        guestId: context.guestId,
        status: "pending",
        currentStep: 0,
        context: context.data
      }
    });
  }
  async processPendingExecutions() {
    const pending = await this.prisma.workflowExecution.findMany({
      where: { status: { in: ["pending", "running"] } },
      include: {
        workflow: {
          include: { steps: { orderBy: { stepOrder: "asc" } } }
        }
      },
      take: 100
    });
    const results = [];
    for (const execution of pending) {
      try {
        const result = await this.processExecution(execution);
        results.push(result);
      } catch (error) {
        await this.prisma.workflowExecution.update({
          where: { id: execution.id },
          data: {
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error"
          }
        });
      }
    }
    return results;
  }
  async processExecution(execution) {
    const { workflow } = execution;
    const steps = workflow.steps.filter((s) => s.isActive);
    if (execution.currentStep >= steps.length) {
      return this.prisma.workflowExecution.update({
        where: { id: execution.id },
        data: {
          status: "completed",
          completedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    const step = steps[execution.currentStep];
    await this.prisma.workflowExecution.update({
      where: { id: execution.id },
      data: { status: "running", startedAt: execution.startedAt ?? /* @__PURE__ */ new Date() }
    });
    await this.executeStep(step, execution);
    return this.prisma.workflowExecution.update({
      where: { id: execution.id },
      data: { currentStep: execution.currentStep + 1 }
    });
  }
  async executeStep(step, execution) {
    const config2 = step.config;
    switch (step.actionType) {
      case "send_email":
        console.log(`[Workflow] Would send email: ${config2.templateId} to ${execution.guestId}`);
        break;
      case "send_sms":
        console.log(`[Workflow] Would send SMS to ${execution.guestId}`);
        break;
      case "wait":
        const delayMs = (config2.delayMinutes ?? 60) * 60 * 1e3;
        console.log(`[Workflow] Would wait ${config2.delayMinutes} minutes`);
        break;
      case "webhook":
        if (config2.url) {
          try {
            await fetch(config2.url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                executionId: execution.id,
                reservationId: execution.reservationId,
                guestId: execution.guestId,
                context: execution.context
              })
            });
          } catch (e) {
            console.error("[Workflow] Webhook failed:", e);
          }
        }
        break;
      case "condition":
        console.log(`[Workflow] Would evaluate condition`);
        break;
    }
  }
  /**
   * Check for workflows that should be triggered based on events
   */
  async checkTriggers(campgroundId, trigger, context) {
    const workflows = await this.prisma.communicationWorkflow.findMany({
      where: {
        campgroundId,
        trigger,
        status: "active"
      }
    });
    const executions = [];
    for (const workflow of workflows) {
      const execution = await this.triggerWorkflow(workflow.id, context);
      executions.push(execution);
    }
    return executions;
  }
};
__decorateClass([
  (0, import_schedule15.Cron)(import_schedule15.CronExpression.EVERY_MINUTE)
], WorkflowsService.prototype, "processPendingExecutions", 1);
WorkflowsService = __decorateClass([
  (0, import_common272.Injectable)()
], WorkflowsService);

// src/workflows/workflows.controller.ts
var import_common273 = require("@nestjs/common");
var WorkflowsController = class {
  constructor(service) {
    this.service = service;
  }
  createWorkflow(dto) {
    return this.service.createWorkflow(dto);
  }
  listWorkflows(campgroundId, status) {
    return this.service.listWorkflows(campgroundId, status);
  }
  getWorkflow(id) {
    return this.service.getWorkflow(id);
  }
  updateWorkflow(id, dto) {
    return this.service.updateWorkflow(id, dto);
  }
  deleteWorkflow(id) {
    return this.service.deleteWorkflow(id);
  }
  addStep(workflowId, dto) {
    return this.service.addStep(workflowId, dto);
  }
  updateStep(stepId, dto) {
    return this.service.updateStep(stepId, dto);
  }
  deleteStep(stepId) {
    return this.service.deleteStep(stepId);
  }
  triggerWorkflow(id, context) {
    return this.service.triggerWorkflow(id, context);
  }
  processPendingExecutions() {
    return this.service.processPendingExecutions();
  }
};
__decorateClass([
  (0, import_common273.Post)(),
  __decorateParam(0, (0, import_common273.Body)())
], WorkflowsController.prototype, "createWorkflow", 1);
__decorateClass([
  (0, import_common273.Get)(),
  __decorateParam(0, (0, import_common273.Query)("campgroundId")),
  __decorateParam(1, (0, import_common273.Query)("status"))
], WorkflowsController.prototype, "listWorkflows", 1);
__decorateClass([
  (0, import_common273.Get)(":id"),
  __decorateParam(0, (0, import_common273.Param)("id"))
], WorkflowsController.prototype, "getWorkflow", 1);
__decorateClass([
  (0, import_common273.Patch)(":id"),
  __decorateParam(0, (0, import_common273.Param)("id")),
  __decorateParam(1, (0, import_common273.Body)())
], WorkflowsController.prototype, "updateWorkflow", 1);
__decorateClass([
  (0, import_common273.Delete)(":id"),
  __decorateParam(0, (0, import_common273.Param)("id"))
], WorkflowsController.prototype, "deleteWorkflow", 1);
__decorateClass([
  (0, import_common273.Post)(":workflowId/steps"),
  __decorateParam(0, (0, import_common273.Param)("workflowId")),
  __decorateParam(1, (0, import_common273.Body)())
], WorkflowsController.prototype, "addStep", 1);
__decorateClass([
  (0, import_common273.Patch)("steps/:stepId"),
  __decorateParam(0, (0, import_common273.Param)("stepId")),
  __decorateParam(1, (0, import_common273.Body)())
], WorkflowsController.prototype, "updateStep", 1);
__decorateClass([
  (0, import_common273.Delete)("steps/:stepId"),
  __decorateParam(0, (0, import_common273.Param)("stepId"))
], WorkflowsController.prototype, "deleteStep", 1);
__decorateClass([
  (0, import_common273.Post)(":id/trigger"),
  __decorateParam(0, (0, import_common273.Param)("id")),
  __decorateParam(1, (0, import_common273.Body)())
], WorkflowsController.prototype, "triggerWorkflow", 1);
__decorateClass([
  (0, import_common273.Post)("process")
], WorkflowsController.prototype, "processPendingExecutions", 1);
WorkflowsController = __decorateClass([
  (0, import_common273.Controller)("workflows"),
  (0, import_common273.UseGuards)(JwtAuthGuard)
], WorkflowsController);

// src/workflows/workflows.module.ts
var WorkflowsModule = class {
};
WorkflowsModule = __decorateClass([
  (0, import_common274.Module)({
    imports: [PrismaModule],
    controllers: [WorkflowsController],
    providers: [WorkflowsService],
    exports: [WorkflowsService]
  })
], WorkflowsModule);

// src/staff/staff.module.ts
var import_common278 = require("@nestjs/common");

// src/staff/staff.service.ts
var import_common276 = require("@nestjs/common");

// src/staff/payroll.service.ts
var import_common275 = require("@nestjs/common");
function minutesBetween(entry) {
  if (!entry.clockOutAt) return 0;
  return Math.max(0, Math.round((entry.clockOutAt.getTime() - entry.clockInAt.getTime()) / 6e4));
}
function aggregateExportRows(rows) {
  const grouped = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = `${row.userId}::${row.earningCode ?? "REG"}::${row.roleCode ?? ""}`;
    const existing = grouped.get(key);
    if (existing) {
      existing.hours = Number((existing.hours + row.hours).toFixed(2));
    } else {
      grouped.set(key, { ...row, hours: Number(row.hours.toFixed(2)) });
    }
  }
  return Array.from(grouped.values());
}
function formatOnPayCsv(rows) {
  const header = ["EmployeeId", "EarningsCode", "Hours", "Rate", "RoleCode"];
  const lines = rows.map(
    (row) => [
      row.userId,
      row.earningCode ?? "REG",
      row.hours.toFixed(2),
      row.rate != null ? row.rate.toFixed(2) : "",
      row.roleCode ?? ""
    ].join(",")
  );
  return [header.join(","), ...lines].join("\n");
}
function formatGenericCsv(rows) {
  const header = ["UserId", "Hours", "EarningCode", "Rate", "RoleCode", "Notes"];
  const lines = rows.map(
    (row) => [
      row.userId,
      row.hours.toFixed(2),
      row.earningCode ?? "",
      row.rate != null ? row.rate.toFixed(2) : "",
      row.roleCode ?? "",
      (row.notes ?? "").replace(/,/g, ";")
    ].join(",")
  );
  return [header.join(","), ...lines].join("\n");
}
var PayrollService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  mapEntryToRow(entry, earningCodes, provider) {
    const minutes = minutesBetween(entry);
    const hours = Number((minutes / 60).toFixed(2));
    const roleCode = entry?.shift?.roleRef?.code ?? entry?.shift?.role ?? null;
    const earningCode = earningCodes.find((code) => code.roleCode === roleCode)?.earningCode ?? (provider === "onpay" ? "REG" : null);
    const rateRaw = entry?.shift?.roleRef?.hourlyRate;
    const rate = typeof rateRaw === "object" && rateRaw !== null ? Number(rateRaw) : rateRaw ?? null;
    return {
      userId: entry.userId,
      shiftId: entry.shiftId ?? null,
      timeEntryId: entry.id ?? null,
      hours,
      earningCode,
      rate,
      roleCode,
      notes: entry.note ?? null
    };
  }
  async generateExport(params) {
    const provider = params.provider ?? "onpay";
    const format = params.format ?? "csv";
    const exportRecord = await this.prisma.payrollExport.create({
      data: {
        campgroundId: params.campgroundId,
        periodStart: params.periodStart,
        periodEnd: params.periodEnd,
        provider,
        format,
        status: "pending",
        requestedById: params.requestedById
      }
    });
    try {
      const [entries, earningCodes] = await Promise.all([
        this.prisma.staffTimeEntry.findMany({
          where: {
            campgroundId: params.campgroundId,
            clockInAt: { gte: params.periodStart },
            clockOutAt: { lte: params.periodEnd },
            status: { in: ["approved", "submitted"] }
          },
          include: {
            shift: { select: { id: true, role: true, roleRef: true, roleId: true } }
          }
        }),
        this.prisma.payrollEarningCode.findMany({
          where: { campgroundId: params.campgroundId, provider }
        })
      ]);
      const rows = aggregateExportRows(
        entries.map((entry) => this.mapEntryToRow(entry, earningCodes, provider))
      );
      const csv = format === "csv" ? provider === "onpay" ? formatOnPayCsv(rows) : formatGenericCsv(rows) : void 0;
      await this.prisma.payrollExportLine.createMany({
        data: rows.map((row) => ({
          exportId: exportRecord.id,
          userId: row.userId,
          shiftId: row.shiftId,
          timeEntryId: row.timeEntryId,
          hours: row.hours,
          earningCode: row.earningCode,
          rate: row.rate,
          roleCode: row.roleCode,
          notes: row.notes
        }))
      });
      await this.prisma.payrollExport.update({
        where: { id: exportRecord.id },
        data: {
          status: "generated",
          rowCount: rows.length,
          totalHours: rows.reduce((sum, row) => sum + row.hours, 0),
          completedAt: /* @__PURE__ */ new Date()
        }
      });
      return {
        exportId: exportRecord.id,
        provider,
        format,
        rows,
        csv
      };
    } catch (err) {
      await this.prisma.payrollExport.update({
        where: { id: exportRecord.id },
        data: { status: "failed", failureReason: err.message }
      });
      throw err;
    }
  }
};
PayrollService = __decorateClass([
  (0, import_common275.Injectable)()
], PayrollService);

// src/staff/staff.service.ts
var StaffService = class {
  constructor(prisma, audit) {
    this.prisma = prisma;
    this.audit = audit;
    this.logger = new import_common276.Logger(StaffService.name);
  }
  calculateTotalMinutes(entries) {
    return entries.reduce((sum, entry) => sum + minutesBetween(entry), 0);
  }
  // ---- Shifts ----
  async createShift(dto) {
    const start = /* @__PURE__ */ new Date(`${dto.shiftDate}T${dto.startTime}`);
    const end = /* @__PURE__ */ new Date(`${dto.shiftDate}T${dto.endTime}`);
    const scheduledMinutes = Math.max(0, Math.round((end.getTime() - start.getTime()) / 6e4));
    return this.prisma.staffShift.create({
      data: {
        campgroundId: dto.campgroundId,
        userId: dto.userId,
        shiftDate: new Date(dto.shiftDate),
        startTime: start,
        endTime: end,
        scheduledMinutes,
        role: dto.role,
        notes: dto.notes,
        createdBy: dto.createdBy
      }
    });
  }
  async listShifts(campgroundId, startDate, endDate, userId, status) {
    return this.prisma.staffShift.findMany({
      where: {
        campgroundId,
        shiftDate: { gte: startDate, lte: endDate },
        ...userId ? { userId } : {},
        ...status ? { status } : {}
      },
      include: {
        user: { select: { id: true, firstName: true, lastName: true, email: true } }
      },
      orderBy: [{ shiftDate: "asc" }, { startTime: "asc" }]
    });
  }
  async updateShift(id, dto) {
    const existing = await this.prisma.staffShift.findUnique({ where: { id } });
    if (!existing) throw new import_common276.NotFoundException("Shift not found");
    const newStart = dto.startTime ? /* @__PURE__ */ new Date(`${dto.shiftDate || existing.shiftDate.toISOString().split("T")[0]}T${dto.startTime}`) : void 0;
    const newEnd = dto.endTime ? /* @__PURE__ */ new Date(`${dto.shiftDate || existing.shiftDate.toISOString().split("T")[0]}T${dto.endTime}`) : void 0;
    return this.prisma.staffShift.update({
      where: { id },
      data: {
        startTime: newStart,
        endTime: newEnd,
        scheduledMinutes: newStart && newEnd ? Math.max(0, Math.round((newEnd.getTime() - newStart.getTime()) / 6e4)) : void 0,
        role: dto.role,
        notes: dto.notes
      }
    });
  }
  async deleteShift(id) {
    return this.prisma.staffShift.delete({ where: { id } });
  }
  async clockIn(shiftId, source = "web", note) {
    const shift = await this.prisma.staffShift.findUnique({ where: { id: shiftId } });
    if (!shift) throw new import_common276.NotFoundException("Shift not found");
    const now = /* @__PURE__ */ new Date();
    const entry = await this.prisma.staffTimeEntry.create({
      data: {
        shiftId,
        campgroundId: shift.campgroundId,
        userId: shift.userId,
        clockInAt: now,
        source,
        note,
        status: "open"
      }
    });
    const updatedShift = await this.prisma.staffShift.update({
      where: { id: shiftId },
      data: {
        clockedInAt: shift.clockedInAt ?? now,
        status: "in_progress"
      }
    });
    return { shift: updatedShift, entry };
  }
  async clockOut(shiftId, note) {
    const shift = await this.prisma.staffShift.findUnique({ where: { id: shiftId } });
    if (!shift) throw new import_common276.NotFoundException("Shift not found");
    const openEntry = await this.prisma.staffTimeEntry.findFirst({
      where: { shiftId, status: { in: ["open", "submitted"] }, clockOutAt: null },
      orderBy: { clockInAt: "desc" }
    });
    if (!openEntry) throw new import_common276.BadRequestException("No open time entry for shift");
    const now = /* @__PURE__ */ new Date();
    const updatedEntry = await this.prisma.staffTimeEntry.update({
      where: { id: openEntry.id },
      data: { clockOutAt: now, status: "submitted", note: note ?? openEntry.note }
    });
    const entries = await this.prisma.staffTimeEntry.findMany({
      where: { shiftId },
      orderBy: { clockInAt: "asc" }
    });
    const actualMinutes = this.calculateTotalMinutes(entries);
    const updatedShift = await this.prisma.staffShift.update({
      where: { id: shiftId },
      data: {
        clockedOutAt: now,
        actualMinutes,
        status: "submitted"
      }
    });
    return { shift: updatedShift, entry: updatedEntry, minutes: actualMinutes };
  }
  async approveShift(shiftId, approverId, note) {
    const shift = await this.prisma.staffShift.findUnique({
      where: { id: shiftId },
      include: { timeEntries: true }
    });
    if (!shift) throw new import_common276.NotFoundException("Shift not found");
    const minutes = this.calculateTotalMinutes(shift.timeEntries);
    const approvedAt = /* @__PURE__ */ new Date();
    const approval = await this.prisma.shiftApproval.create({
      data: {
        shiftId,
        approverId,
        status: "approved",
        note,
        approvedAt
      }
    });
    await this.prisma.staffShift.update({
      where: { id: shiftId },
      data: {
        status: "approved",
        actualMinutes: minutes,
        approvedAt,
        approvedById: approverId,
        approvalNote: note
      }
    });
    await this.prisma.staffTimeEntry.updateMany({
      where: { shiftId },
      data: { status: "approved", approvedAt, approvedById: approverId }
    });
    return { approval, minutes };
  }
  async rejectShift(shiftId, approverId, note) {
    const shift = await this.prisma.staffShift.findUnique({ where: { id: shiftId } });
    if (!shift) throw new import_common276.NotFoundException("Shift not found");
    const rejectedAt = /* @__PURE__ */ new Date();
    const approval = await this.prisma.shiftApproval.create({
      data: { shiftId, approverId, status: "rejected", note, approvedAt: rejectedAt }
    });
    await this.prisma.staffShift.update({
      where: { id: shiftId },
      data: { status: "rejected", approvedAt: rejectedAt, approvedById: approverId, approvalNote: note }
    });
    await this.prisma.staffTimeEntry.updateMany({
      where: { shiftId },
      data: { status: "rejected", approvedAt: rejectedAt, approvedById: approverId }
    });
    return { approval };
  }
  async submitShift(shiftId) {
    return this.prisma.staffShift.update({
      where: { id: shiftId },
      data: { status: "submitted" }
    });
  }
  // ---- Roles ----
  async upsertRole(dto) {
    return this.prisma.staffRole.upsert({
      where: {
        campgroundId_code: {
          campgroundId: dto.campgroundId,
          code: dto.code
        }
      },
      update: {
        name: dto.name,
        hourlyRate: dto.hourlyRate ?? void 0,
        earningCode: dto.earningCode ?? void 0,
        isActive: dto.isActive ?? true
      },
      create: {
        campgroundId: dto.campgroundId,
        code: dto.code,
        name: dto.name,
        hourlyRate: dto.hourlyRate ?? null,
        earningCode: dto.earningCode ?? null,
        isActive: dto.isActive ?? true
      }
    });
  }
  async listRoles(campgroundId) {
    return this.prisma.staffRole.findMany({
      where: { campgroundId, isActive: true },
      orderBy: { code: "asc" }
    });
  }
  // ---- Overrides ----
  async requestOverride(dto) {
    const record = await this.prisma.overrideRequest.create({
      data: {
        campgroundId: dto.campgroundId,
        userId: dto.userId,
        type: dto.type,
        reason: dto.reason,
        targetEntity: dto.targetEntity ?? null,
        targetId: dto.targetId ?? null,
        deltaAmount: dto.deltaAmount ?? null,
        metadata: dto.metadata ?? null,
        status: "pending"
      }
    });
    await this.audit.record({
      campgroundId: dto.campgroundId,
      actorId: dto.userId,
      action: "override.request",
      entity: dto.targetEntity ?? "override",
      entityId: record.id,
      after: record
    });
    return record;
  }
  async decideOverride(id, approverId, status, note) {
    const existing = await this.prisma.overrideRequest.findUnique({ where: { id } });
    if (!existing) throw new import_common276.NotFoundException("Override not found");
    const now = /* @__PURE__ */ new Date();
    const updated = await this.prisma.overrideRequest.update({
      where: { id },
      data: {
        approverId,
        status,
        approvedAt: status === "approved" ? now : null,
        rejectedAt: status === "rejected" ? now : null,
        reason: note ?? existing.reason
      }
    });
    await this.audit.record({
      campgroundId: existing.campgroundId,
      actorId: approverId,
      action: `override.${status}`,
      entity: existing.targetEntity ?? "override",
      entityId: existing.targetId ?? id,
      before: existing,
      after: updated
    });
    return updated;
  }
  async listOverrides(campgroundId, status) {
    return this.prisma.overrideRequest.findMany({
      where: { campgroundId, status: status ?? void 0 },
      orderBy: { createdAt: "desc" },
      take: 200
    });
  }
  // ---- Availability ----
  async setAvailability(dto) {
    return this.prisma.staffAvailability.upsert({
      where: {
        campgroundId_userId_dayOfWeek: {
          campgroundId: dto.campgroundId,
          userId: dto.userId,
          dayOfWeek: dto.dayOfWeek
        }
      },
      update: {
        startTime: dto.startTime,
        endTime: dto.endTime,
        isAvailable: dto.isAvailable ?? true
      },
      create: {
        campgroundId: dto.campgroundId,
        userId: dto.userId,
        dayOfWeek: dto.dayOfWeek,
        startTime: dto.startTime,
        endTime: dto.endTime,
        isAvailable: dto.isAvailable ?? true
      }
    });
  }
  async getAvailability(campgroundId, userId) {
    return this.prisma.staffAvailability.findMany({
      where: {
        campgroundId,
        ...userId ? { userId } : {}
      },
      include: {
        user: { select: { id: true, firstName: true, lastName: true } }
      },
      orderBy: [{ userId: "asc" }, { dayOfWeek: "asc" }]
    });
  }
  // ---- Push Notifications ----
  async sendNotification(campgroundId, userId, type, title, body, data) {
    const pushEnabled = process.env.PUSH_NOTIFICATIONS_ENABLED === "true";
    const fcmKey = process.env.FCM_SERVER_KEY;
    const notification = await this.prisma.pushNotification.create({
      data: {
        campgroundId,
        userId,
        type,
        title,
        body,
        data,
        sentAt: /* @__PURE__ */ new Date()
      }
    });
    if (pushEnabled && fcmKey && userId) {
      try {
        const subs = await this.prisma.pushSubscription.findMany({
          where: { userId },
          select: { endpoint: true, keys: true }
        });
        for (const sub of subs) {
          await fetch("https://fcm.googleapis.com/fcm/send", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `key=${fcmKey}`
            },
            body: JSON.stringify({
              to: sub.endpoint,
              notification: { title, body },
              data
            })
          }).catch(() => {
            this.logger?.warn?.(`[Push] Failed to send to ${sub.endpoint}`);
          });
        }
      } catch (err) {
        this.logger?.error?.("[Push] Delivery failed", err);
      }
    } else {
      console.log(`[Push] (noop) ${type}: ${title} to user ${userId ?? "n/a"}`);
    }
    return notification;
  }
  async getNotifications(userId, limit = 50, unreadOnly = false) {
    return this.prisma.pushNotification.findMany({
      where: {
        userId,
        ...unreadOnly ? { readAt: null } : {}
      },
      orderBy: { createdAt: "desc" },
      take: limit
    });
  }
  async markNotificationRead(id) {
    return this.prisma.pushNotification.update({
      where: { id },
      data: { readAt: /* @__PURE__ */ new Date() }
    });
  }
  async markAllNotificationsRead(userId) {
    return this.prisma.pushNotification.updateMany({
      where: { userId, readAt: null },
      data: { readAt: /* @__PURE__ */ new Date() }
    });
  }
  // ---- Performance Tracking ----
  async recordPerformance(campgroundId, userId, periodStart, periodEnd, metrics) {
    return this.prisma.staffPerformance.upsert({
      where: {
        campgroundId_userId_periodStart_periodEnd: {
          campgroundId,
          userId,
          periodStart,
          periodEnd
        }
      },
      update: metrics,
      create: {
        campgroundId,
        userId,
        periodStart,
        periodEnd,
        ...metrics
      }
    });
  }
  async getPerformance(campgroundId, userId, startDate, endDate) {
    return this.prisma.staffPerformance.findMany({
      where: {
        campgroundId,
        ...userId ? { userId } : {},
        ...startDate ? { periodStart: { gte: startDate } } : {},
        ...endDate ? { periodEnd: { lte: endDate } } : {}
      },
      include: {
        user: { select: { id: true, firstName: true, lastName: true } }
      },
      orderBy: { periodStart: "desc" }
    });
  }
  /**
   * Calculate performance metrics for a staff member
   */
  async calculatePerformanceMetrics(campgroundId, userId, periodStart, periodEnd) {
    const tasks = await this.prisma.task.findMany({
      where: {
        tenantId: campgroundId,
        assignedToUserId: userId,
        state: "done",
        updatedAt: { gte: periodStart, lte: periodEnd }
      }
    });
    const tasksCompleted = tasks.length;
    const tasksSlaOnTime = tasks.filter((t) => t.slaStatus === "on_track").length;
    const shifts = await this.prisma.staffShift.findMany({
      where: {
        campgroundId,
        userId,
        shiftDate: { gte: periodStart, lte: periodEnd },
        clockedInAt: { not: null },
        clockedOutAt: { not: null }
      }
    });
    let hoursWorked = 0;
    for (const shift of shifts) {
      if (shift.actualMinutes != null) {
        hoursWorked += shift.actualMinutes / 60;
      } else if (shift.clockedInAt && shift.clockedOutAt) {
        hoursWorked += minutesBetween({ clockInAt: shift.clockedInAt, clockOutAt: shift.clockedOutAt }) / 60;
      }
    }
    return this.recordPerformance(campgroundId, userId, periodStart, periodEnd, {
      tasksCompleted,
      tasksSlaOnTime,
      hoursWorked: Math.round(hoursWorked * 10) / 10
    });
  }
};
StaffService = __decorateClass([
  (0, import_common276.Injectable)()
], StaffService);

// src/staff/staff.controller.ts
var import_common277 = require("@nestjs/common");
var StaffController = class {
  constructor(service, payroll) {
    this.service = service;
    this.payroll = payroll;
  }
  createShift(dto) {
    return this.service.createShift(dto);
  }
  listShifts(campgroundId, startDate, endDate, userId, status) {
    return this.service.listShifts(
      campgroundId,
      new Date(startDate),
      new Date(endDate),
      userId,
      status
    );
  }
  updateShift(id, dto) {
    return this.service.updateShift(id, dto);
  }
  deleteShift(id) {
    return this.service.deleteShift(id);
  }
  clockIn(id, body) {
    return this.service.clockIn(id, body?.source, body?.note);
  }
  clockOut(id, body) {
    return this.service.clockOut(id, body?.note);
  }
  submit(id) {
    return this.service.submitShift(id);
  }
  approve(id, body) {
    return this.service.approveShift(id, body.approverId, body.note);
  }
  reject(id, body) {
    return this.service.rejectShift(id, body.approverId, body.note);
  }
  listRoles(campgroundId) {
    return this.service.listRoles(campgroundId);
  }
  upsertRole(body) {
    return this.service.upsertRole(body);
  }
  requestOverride(dto) {
    return this.service.requestOverride(dto);
  }
  decideOverride(id, body) {
    return this.service.decideOverride(id, body.approverId, body.status, body.note);
  }
  listOverrides(campgroundId, status) {
    return this.service.listOverrides(campgroundId, status);
  }
  generateExport(dto) {
    return this.payroll.generateExport({
      campgroundId: dto.campgroundId,
      periodStart: new Date(dto.periodStart),
      periodEnd: new Date(dto.periodEnd),
      requestedById: dto.requestedById,
      provider: dto.provider,
      format: dto.format
    });
  }
  setAvailability(dto) {
    return this.service.setAvailability(dto);
  }
  getAvailability(campgroundId, userId) {
    return this.service.getAvailability(campgroundId, userId);
  }
  sendNotification(dto) {
    return this.service.sendNotification(
      dto.campgroundId,
      dto.userId,
      dto.type,
      dto.title,
      dto.body,
      dto.data
    );
  }
  getNotifications(userId, limit, unreadOnly) {
    return this.service.getNotifications(
      userId,
      limit ? parseInt(limit, 10) : void 0,
      unreadOnly === "true"
    );
  }
  markNotificationRead(id) {
    return this.service.markNotificationRead(id);
  }
  markAllNotificationsRead(userId) {
    return this.service.markAllNotificationsRead(userId);
  }
  getPerformance(campgroundId, userId, startDate, endDate) {
    return this.service.getPerformance(
      campgroundId,
      userId,
      startDate ? new Date(startDate) : void 0,
      endDate ? new Date(endDate) : void 0
    );
  }
  calculatePerformance(dto) {
    return this.service.calculatePerformanceMetrics(
      dto.campgroundId,
      dto.userId,
      new Date(dto.periodStart),
      new Date(dto.periodEnd)
    );
  }
};
__decorateClass([
  (0, import_common277.Post)("shifts"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "createShift", 1);
__decorateClass([
  (0, import_common277.Get)("shifts"),
  __decorateParam(0, (0, import_common277.Query)("campgroundId")),
  __decorateParam(1, (0, import_common277.Query)("startDate")),
  __decorateParam(2, (0, import_common277.Query)("endDate")),
  __decorateParam(3, (0, import_common277.Query)("userId")),
  __decorateParam(4, (0, import_common277.Query)("status"))
], StaffController.prototype, "listShifts", 1);
__decorateClass([
  (0, import_common277.Patch)("shifts/:id"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "updateShift", 1);
__decorateClass([
  (0, import_common277.Delete)("shifts/:id"),
  __decorateParam(0, (0, import_common277.Param)("id"))
], StaffController.prototype, "deleteShift", 1);
__decorateClass([
  (0, import_common277.Post)("shifts/:id/clock-in"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "clockIn", 1);
__decorateClass([
  (0, import_common277.Post)("shifts/:id/clock-out"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "clockOut", 1);
__decorateClass([
  (0, import_common277.Post)("shifts/:id/submit"),
  __decorateParam(0, (0, import_common277.Param)("id"))
], StaffController.prototype, "submit", 1);
__decorateClass([
  (0, import_common277.Post)("shifts/:id/approve"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "approve", 1);
__decorateClass([
  (0, import_common277.Post)("shifts/:id/reject"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "reject", 1);
__decorateClass([
  (0, import_common277.Get)("roles"),
  __decorateParam(0, (0, import_common277.Query)("campgroundId"))
], StaffController.prototype, "listRoles", 1);
__decorateClass([
  (0, import_common277.Post)("roles"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "upsertRole", 1);
__decorateClass([
  (0, import_common277.Post)("overrides"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "requestOverride", 1);
__decorateClass([
  (0, import_common277.Post)("overrides/:id/decision"),
  __decorateParam(0, (0, import_common277.Param)("id")),
  __decorateParam(1, (0, import_common277.Body)())
], StaffController.prototype, "decideOverride", 1);
__decorateClass([
  (0, import_common277.Get)("overrides"),
  __decorateParam(0, (0, import_common277.Query)("campgroundId")),
  __decorateParam(1, (0, import_common277.Query)("status"))
], StaffController.prototype, "listOverrides", 1);
__decorateClass([
  (0, import_common277.Post)("payroll/export"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "generateExport", 1);
__decorateClass([
  (0, import_common277.Post)("availability"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "setAvailability", 1);
__decorateClass([
  (0, import_common277.Get)("availability"),
  __decorateParam(0, (0, import_common277.Query)("campgroundId")),
  __decorateParam(1, (0, import_common277.Query)("userId"))
], StaffController.prototype, "getAvailability", 1);
__decorateClass([
  (0, import_common277.Post)("notifications"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "sendNotification", 1);
__decorateClass([
  (0, import_common277.Get)("notifications/:userId"),
  __decorateParam(0, (0, import_common277.Param)("userId")),
  __decorateParam(1, (0, import_common277.Query)("limit")),
  __decorateParam(2, (0, import_common277.Query)("unreadOnly"))
], StaffController.prototype, "getNotifications", 1);
__decorateClass([
  (0, import_common277.Patch)("notifications/:id/read"),
  __decorateParam(0, (0, import_common277.Param)("id"))
], StaffController.prototype, "markNotificationRead", 1);
__decorateClass([
  (0, import_common277.Post)("notifications/:userId/read-all"),
  __decorateParam(0, (0, import_common277.Param)("userId"))
], StaffController.prototype, "markAllNotificationsRead", 1);
__decorateClass([
  (0, import_common277.Get)("performance"),
  __decorateParam(0, (0, import_common277.Query)("campgroundId")),
  __decorateParam(1, (0, import_common277.Query)("userId")),
  __decorateParam(2, (0, import_common277.Query)("startDate")),
  __decorateParam(3, (0, import_common277.Query)("endDate"))
], StaffController.prototype, "getPerformance", 1);
__decorateClass([
  (0, import_common277.Post)("performance/calculate"),
  __decorateParam(0, (0, import_common277.Body)())
], StaffController.prototype, "calculatePerformance", 1);
StaffController = __decorateClass([
  (0, import_common277.Controller)("staff"),
  (0, import_common277.UseGuards)(JwtAuthGuard)
], StaffController);

// src/staff/staff.module.ts
var StaffModule = class {
};
StaffModule = __decorateClass([
  (0, import_common278.Module)({
    imports: [PrismaModule, AuditModule],
    controllers: [StaffController],
    providers: [StaffService, PayrollService],
    exports: [StaffService, PayrollService]
  })
], StaffModule);

// src/portfolio/portfolio.module.ts
var import_common281 = require("@nestjs/common");

// src/portfolio/portfolio.service.ts
var import_common279 = require("@nestjs/common");
var PortfolioService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  // ---- Dashboards ----
  async createDashboard(dto) {
    if (dto.isDefault) {
      await this.prisma.portfolioDashboard.updateMany({
        where: { orgId: dto.orgId, isDefault: true },
        data: { isDefault: false }
      });
    }
    return this.prisma.portfolioDashboard.create({
      data: {
        orgId: dto.orgId,
        name: dto.name,
        layout: dto.layout,
        isDefault: dto.isDefault ?? false,
        createdById: dto.createdById
      }
    });
  }
  async listDashboards(orgId) {
    return this.prisma.portfolioDashboard.findMany({
      where: { orgId },
      include: {
        createdBy: { select: { id: true, firstName: true, lastName: true } }
      },
      orderBy: [{ isDefault: "desc" }, { createdAt: "desc" }]
    });
  }
  async getDashboard(id) {
    const dashboard = await this.prisma.portfolioDashboard.findUnique({
      where: { id },
      include: { organization: true }
    });
    if (!dashboard) throw new import_common279.NotFoundException("Dashboard not found");
    return dashboard;
  }
  async updateDashboard(id, dto) {
    if (dto.isDefault) {
      const existing = await this.getDashboard(id);
      await this.prisma.portfolioDashboard.updateMany({
        where: { orgId: existing.orgId, isDefault: true },
        data: { isDefault: false }
      });
    }
    return this.prisma.portfolioDashboard.update({
      where: { id },
      data: {
        name: dto.name,
        layout: dto.layout,
        isDefault: dto.isDefault
      }
    });
  }
  async deleteDashboard(id) {
    return this.prisma.portfolioDashboard.delete({ where: { id } });
  }
  // ---- Portfolio Metrics ----
  async recordMetrics(orgId, campgroundId, date, metrics) {
    const results = [];
    for (const metric of metrics) {
      const previous = await this.prisma.portfolioMetric.findFirst({
        where: {
          orgId,
          campgroundId,
          metricType: metric.metricType,
          metricDate: { lt: date }
        },
        orderBy: { metricDate: "desc" }
      });
      const changePercent = previous ? (metric.value - previous.value) / previous.value * 100 : null;
      const result = await this.prisma.portfolioMetric.upsert({
        where: {
          orgId_campgroundId_metricDate_metricType: {
            orgId,
            campgroundId: campgroundId ?? "",
            metricDate: date,
            metricType: metric.metricType
          }
        },
        update: {
          value: metric.value,
          previousValue: previous?.value,
          changePercent
        },
        create: {
          orgId,
          campgroundId,
          metricDate: date,
          metricType: metric.metricType,
          value: metric.value,
          previousValue: previous?.value,
          changePercent
        }
      });
      results.push(result);
    }
    return results;
  }
  async getMetrics(orgId, campgroundId, metricType, startDate, endDate) {
    return this.prisma.portfolioMetric.findMany({
      where: {
        orgId,
        ...campgroundId ? { campgroundId } : {},
        ...metricType ? { metricType } : {},
        ...startDate || endDate ? {
          metricDate: {
            ...startDate ? { gte: startDate } : {},
            ...endDate ? { lte: endDate } : {}
          }
        } : {}
      },
      include: {
        campground: { select: { id: true, name: true } }
      },
      orderBy: { metricDate: "desc" }
    });
  }
  /**
   * Get aggregated metrics across all properties in organization
   */
  async getPortfolioSummary(orgId, date) {
    const campgrounds = await this.prisma.campground.findMany({
      where: { organizationId: orgId },
      select: { id: true, name: true }
    });
    const metrics = await this.prisma.portfolioMetric.findMany({
      where: {
        orgId,
        metricDate: date
      }
    });
    const summary = {};
    for (const metric of metrics) {
      if (!summary[metric.metricType]) {
        summary[metric.metricType] = { total: 0, byProperty: {} };
      }
      if (metric.campgroundId) {
        summary[metric.metricType].byProperty[metric.campgroundId] = metric.value;
        summary[metric.metricType].total += metric.value;
      } else {
        summary[metric.metricType].total = metric.value;
      }
    }
    return {
      date,
      campgrounds,
      metrics: summary
    };
  }
  // ---- Centralized Rate Push ----
  async createRatePush(orgId, name, rateConfig, targetCampIds, createdBy) {
    return this.prisma.centralizedRatePush.create({
      data: {
        orgId,
        name,
        rateConfig,
        targetCampIds,
        status: "draft",
        createdBy
      }
    });
  }
  async listRatePushes(orgId) {
    return this.prisma.centralizedRatePush.findMany({
      where: { orgId },
      orderBy: { createdAt: "desc" }
    });
  }
  async applyRatePush(id, appliedBy) {
    const push = await this.prisma.centralizedRatePush.findUnique({ where: { id } });
    if (!push) throw new import_common279.NotFoundException("Rate push not found");
    const results = {};
    for (const campId of push.targetCampIds) {
      try {
        results[campId] = { success: true };
      } catch (error) {
        results[campId] = {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    }
    const allSuccess = Object.values(results).every((r) => r.success);
    return this.prisma.centralizedRatePush.update({
      where: { id },
      data: {
        status: allSuccess ? "applied" : "failed",
        appliedAt: /* @__PURE__ */ new Date(),
        appliedBy,
        results
      }
    });
  }
  /**
   * Calculate and record daily metrics for all properties
   */
  async calculateDailyMetrics(orgId, date) {
    const campgrounds = await this.prisma.campground.findMany({
      where: { organizationId: orgId }
    });
    for (const camp of campgrounds) {
      const totalSites = await this.prisma.site.count({
        where: { campgroundId: camp.id, isActive: true }
      });
      const occupied = await this.prisma.reservation.count({
        where: {
          campgroundId: camp.id,
          arrivalDate: { lte: date },
          departureDate: { gt: date },
          status: { in: ["confirmed", "checked_in"] }
        }
      });
      const occupancyPct = totalSites > 0 ? occupied / totalSites * 100 : 0;
      const revenue = await this.prisma.reservation.aggregate({
        where: {
          campgroundId: camp.id,
          arrivalDate: { lte: date },
          departureDate: { gt: date },
          status: { in: ["confirmed", "checked_in", "checked_out"] }
        },
        _sum: { totalAmount: true }
      });
      const revenueCents = revenue._sum.totalAmount ?? 0;
      const adr = occupied > 0 ? revenueCents / occupied : 0;
      const revpar = totalSites > 0 ? revenueCents / totalSites : 0;
      const bookings = await this.prisma.reservation.count({
        where: {
          campgroundId: camp.id,
          createdAt: {
            gte: new Date(date.setHours(0, 0, 0, 0)),
            lt: new Date(date.setHours(23, 59, 59, 999))
          }
        }
      });
      await this.recordMetrics(orgId, camp.id, date, [
        { metricType: "occupancy", value: occupancyPct },
        { metricType: "revenue", value: revenueCents },
        { metricType: "adr", value: adr },
        { metricType: "revpar", value: revpar },
        { metricType: "bookings", value: bookings }
      ]);
    }
    const allMetrics = await this.prisma.portfolioMetric.findMany({
      where: { orgId, metricDate: date, campgroundId: { not: null } }
    });
    const aggregates = {};
    for (const m of allMetrics) {
      if (!aggregates[m.metricType]) aggregates[m.metricType] = 0;
      aggregates[m.metricType] += m.value;
    }
    const campCount = campgrounds.length || 1;
    if (aggregates.occupancy) aggregates.occupancy /= campCount;
    await this.recordMetrics(
      orgId,
      null,
      date,
      Object.entries(aggregates).map(([metricType, value]) => ({ metricType, value }))
    );
  }
};
PortfolioService = __decorateClass([
  (0, import_common279.Injectable)()
], PortfolioService);

// src/portfolio/portfolio.controller.ts
var import_common280 = require("@nestjs/common");
var PortfolioController = class {
  constructor(service) {
    this.service = service;
  }
  createDashboard(dto) {
    return this.service.createDashboard(dto);
  }
  listDashboards(orgId) {
    return this.service.listDashboards(orgId);
  }
  getDashboard(id) {
    return this.service.getDashboard(id);
  }
  updateDashboard(id, dto) {
    return this.service.updateDashboard(id, dto);
  }
  deleteDashboard(id) {
    return this.service.deleteDashboard(id);
  }
  recordMetrics(dto) {
    return this.service.recordMetrics(
      dto.orgId,
      dto.campgroundId ?? null,
      new Date(dto.date),
      dto.metrics
    );
  }
  getMetrics(orgId, campgroundId, metricType, startDate, endDate) {
    return this.service.getMetrics(
      orgId,
      campgroundId,
      metricType,
      startDate ? new Date(startDate) : void 0,
      endDate ? new Date(endDate) : void 0
    );
  }
  getPortfolioSummary(orgId, date) {
    return this.service.getPortfolioSummary(orgId, new Date(date));
  }
  calculateDailyMetrics(dto) {
    return this.service.calculateDailyMetrics(dto.orgId, new Date(dto.date));
  }
  createRatePush(dto) {
    return this.service.createRatePush(
      dto.orgId,
      dto.name,
      dto.rateConfig,
      dto.targetCampIds,
      dto.createdBy
    );
  }
  listRatePushes(orgId) {
    return this.service.listRatePushes(orgId);
  }
  applyRatePush(id, dto) {
    return this.service.applyRatePush(id, dto.appliedBy);
  }
};
__decorateClass([
  (0, import_common280.Post)("dashboards"),
  __decorateParam(0, (0, import_common280.Body)())
], PortfolioController.prototype, "createDashboard", 1);
__decorateClass([
  (0, import_common280.Get)("dashboards"),
  __decorateParam(0, (0, import_common280.Query)("orgId"))
], PortfolioController.prototype, "listDashboards", 1);
__decorateClass([
  (0, import_common280.Get)("dashboards/:id"),
  __decorateParam(0, (0, import_common280.Param)("id"))
], PortfolioController.prototype, "getDashboard", 1);
__decorateClass([
  (0, import_common280.Patch)("dashboards/:id"),
  __decorateParam(0, (0, import_common280.Param)("id")),
  __decorateParam(1, (0, import_common280.Body)())
], PortfolioController.prototype, "updateDashboard", 1);
__decorateClass([
  (0, import_common280.Delete)("dashboards/:id"),
  __decorateParam(0, (0, import_common280.Param)("id"))
], PortfolioController.prototype, "deleteDashboard", 1);
__decorateClass([
  (0, import_common280.Post)("metrics"),
  __decorateParam(0, (0, import_common280.Body)())
], PortfolioController.prototype, "recordMetrics", 1);
__decorateClass([
  (0, import_common280.Get)("metrics"),
  __decorateParam(0, (0, import_common280.Query)("orgId")),
  __decorateParam(1, (0, import_common280.Query)("campgroundId")),
  __decorateParam(2, (0, import_common280.Query)("metricType")),
  __decorateParam(3, (0, import_common280.Query)("startDate")),
  __decorateParam(4, (0, import_common280.Query)("endDate"))
], PortfolioController.prototype, "getMetrics", 1);
__decorateClass([
  (0, import_common280.Get)("summary"),
  __decorateParam(0, (0, import_common280.Query)("orgId")),
  __decorateParam(1, (0, import_common280.Query)("date"))
], PortfolioController.prototype, "getPortfolioSummary", 1);
__decorateClass([
  (0, import_common280.Post)("metrics/calculate"),
  __decorateParam(0, (0, import_common280.Body)())
], PortfolioController.prototype, "calculateDailyMetrics", 1);
__decorateClass([
  (0, import_common280.Post)("rate-push"),
  __decorateParam(0, (0, import_common280.Body)())
], PortfolioController.prototype, "createRatePush", 1);
__decorateClass([
  (0, import_common280.Get)("rate-push"),
  __decorateParam(0, (0, import_common280.Query)("orgId"))
], PortfolioController.prototype, "listRatePushes", 1);
__decorateClass([
  (0, import_common280.Post)("rate-push/:id/apply"),
  __decorateParam(0, (0, import_common280.Param)("id")),
  __decorateParam(1, (0, import_common280.Body)())
], PortfolioController.prototype, "applyRatePush", 1);
PortfolioController = __decorateClass([
  (0, import_common280.Controller)("portfolio"),
  (0, import_common280.UseGuards)(JwtAuthGuard)
], PortfolioController);

// src/portfolio/portfolio.module.ts
var PortfolioModule = class {
};
PortfolioModule = __decorateClass([
  (0, import_common281.Module)({
    imports: [PrismaModule],
    controllers: [PortfolioController],
    providers: [PortfolioService],
    exports: [PortfolioService]
  })
], PortfolioModule);

// src/uploads/uploads.module.ts
var import_common284 = require("@nestjs/common");

// src/uploads/uploads.service.ts
var import_common282 = require("@nestjs/common");
var import_client_s3 = require("@aws-sdk/client-s3");
var import_s3_request_presigner = require("@aws-sdk/s3-request-presigner");
var import_crypto24 = require("crypto");
var import_fs = require("fs");
var import_path = require("path");
var UploadsService = class {
  constructor() {
    this.bucket = process.env.UPLOADS_S3_BUCKET || null;
    this.region = process.env.UPLOADS_S3_REGION || null;
    this.cdnBase = process.env.UPLOADS_CDN_BASE || null;
    if (this.bucket && this.region && process.env.UPLOADS_S3_ACCESS_KEY && process.env.UPLOADS_S3_SECRET_KEY) {
      this.s3 = new import_client_s3.S3Client({
        region: this.region,
        credentials: {
          accessKeyId: process.env.UPLOADS_S3_ACCESS_KEY,
          secretAccessKey: process.env.UPLOADS_S3_SECRET_KEY
        }
      });
    } else {
      this.s3 = null;
    }
  }
  ensureEnabled() {
    if (!this.s3 || !this.bucket || !this.region) {
      throw new import_common282.ServiceUnavailableException("Uploads are disabled (missing S3 config).");
    }
  }
  async signUpload(filename, contentType) {
    this.ensureEnabled();
    const ext = filename.includes(".") ? filename.split(".").pop() : "bin";
    const key = `uploads/${(0, import_crypto24.randomUUID)()}.${ext}`;
    const command = new import_client_s3.PutObjectCommand({
      Bucket: this.bucket,
      Key: key,
      ContentType: contentType,
      ACL: "public-read"
    });
    const uploadUrl = await (0, import_s3_request_presigner.getSignedUrl)(this.s3, command, { expiresIn: 300 });
    const publicUrl = this.cdnBase ? `${this.cdnBase.replace(/\/$/, "")}/${key}` : `https://${this.bucket}.s3.${this.region}.amazonaws.com/${key}`;
    return { uploadUrl, publicUrl, key };
  }
  /**
   * Directly upload a buffer to S3 when configured; otherwise write to /tmp and return a file:// URL.
   */
  async uploadBuffer(buffer, opts) {
    const ext = (opts.extension ?? opts.contentType.split("/")[1] ?? "bin").replace(/[^a-z0-9]/gi, "") || "bin";
    const key = `${opts.prefix ?? "uploads"}/${(0, import_crypto24.randomUUID)()}.${ext}`;
    if (this.s3 && this.bucket && this.region) {
      const command = new import_client_s3.PutObjectCommand({
        Bucket: this.bucket,
        Key: key,
        Body: buffer,
        ContentType: opts.contentType,
        ACL: "public-read"
      });
      await this.s3.send(command);
      const publicUrl = this.cdnBase ? `${this.cdnBase.replace(/\/$/, "")}/${key}` : `https://${this.bucket}.s3.${this.region}.amazonaws.com/${key}`;
      return { url: publicUrl, key };
    }
    const filePath = (0, import_path.join)("/tmp", key);
    await import_fs.promises.mkdir((0, import_path.dirname)(filePath), { recursive: true });
    await import_fs.promises.writeFile(filePath, buffer);
    return { url: `file://${filePath}`, key };
  }
};
UploadsService = __decorateClass([
  (0, import_common282.Injectable)()
], UploadsService);

// src/uploads/uploads.controller.ts
var import_common283 = require("@nestjs/common");
var UploadsController = class {
  constructor(uploads) {
    this.uploads = uploads;
  }
  async sign(body) {
    if (!body?.filename || !body?.contentType) {
      return { error: "filename and contentType required" };
    }
    return this.uploads.signUpload(body.filename, body.contentType);
  }
};
__decorateClass([
  (0, import_common283.Post)("sign"),
  __decorateParam(0, (0, import_common283.Body)())
], UploadsController.prototype, "sign", 1);
UploadsController = __decorateClass([
  (0, import_common283.Controller)("uploads")
], UploadsController);

// src/uploads/uploads.module.ts
var UploadsModule = class {
};
UploadsModule = __decorateClass([
  (0, import_common284.Module)({
    controllers: [UploadsController],
    providers: [UploadsService],
    exports: [UploadsService]
  })
], UploadsModule);

// src/waivers/waivers.module.ts
var import_common286 = require("@nestjs/common");

// src/waivers/waivers.service.ts
var import_common285 = require("@nestjs/common");
var WaiversService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.logger = new import_common285.Logger(WaiversService.name);
  }
  /**
   * Generate a lightweight PDF (base64 data URL) for a waiver.
   * If WAIVER_PDF_ENABLED is not true, returns a noop stub with telemetry.
   */
  async generateWaiverPdf(waiverId) {
    const waiver = await this.prisma.digitalWaiver.findUnique({ where: { id: waiverId } });
    if (!waiver) throw new import_common285.NotFoundException("Waiver not found");
    const pdfEnabled = process.env.WAIVER_PDF_ENABLED === "true";
    if (!pdfEnabled) {
      this.logger.warn(`[WaiverPDF] Skipped generation (feature flag disabled) for ${waiverId}`);
      return { waiverId, status: "skipped" };
    }
    const content = `Waiver for guest ${waiver.guestId || ""} at campground ${waiver.campgroundId}
Status: ${waiver.status}
Generated: ${(/* @__PURE__ */ new Date()).toISOString()}`;
    const base64 = Buffer.from(content).toString("base64");
    const dataUrl = `data:application/pdf;base64,${base64}`;
    await this.prisma.digitalWaiver.update({
      where: { id: waiverId },
      data: { pdfUrl: dataUrl }
    });
    this.logger.log(`[WaiverPDF] Generated inline PDF for ${waiverId}`);
    return { waiverId, pdfUrl: dataUrl };
  }
  /**
   * Start an ID verification flow.
   * If no provider keys are configured, records a noop attempt with telemetry.
   */
  async startIdVerification(guestId, reservationId, provider) {
    const stripeKey = process.env.STRIPE_IDENTITY_KEY;
    const jumioKey = process.env.JUMIO_API_KEY;
    const chosenProvider = provider || (stripeKey ? "stripe_identity" : jumioKey ? "jumio" : "noop");
    const campgroundId = await this.resolveCampgroundId(reservationId);
    if (!campgroundId) {
      throw new import_common285.NotFoundException("Campground required for ID verification");
    }
    const verification = await this.prisma.idVerification.create({
      data: {
        guestId,
        reservationId: reservationId ?? null,
        campgroundId,
        status: chosenProvider === "noop" ? "pending" : "pending",
        provider: chosenProvider,
        metadata: { startedAt: (/* @__PURE__ */ new Date()).toISOString(), provider: chosenProvider }
      }
    });
    if (chosenProvider === "noop") {
      this.logger.warn(`[IDV] No provider configured; recorded noop verification for guest ${guestId}`);
    } else {
      this.logger.log(`[IDV] Started verification via ${chosenProvider} for guest ${guestId}`);
    }
    return verification;
  }
  async completeVerification(id, success) {
    return this.prisma.idVerification.update({
      where: { id },
      data: {
        status: success ? "verified" : "failed",
        verifiedAt: success ? /* @__PURE__ */ new Date() : null,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async resolveCampgroundId(reservationId) {
    if (!reservationId) return null;
    const reservation = await this.prisma.reservation.findUnique({
      where: { id: reservationId },
      select: { campgroundId: true }
    });
    return reservation?.campgroundId ?? null;
  }
};
WaiversService = __decorateClass([
  (0, import_common285.Injectable)()
], WaiversService);

// src/waivers/waivers.module.ts
var WaiversModule = class {
};
WaiversModule = __decorateClass([
  (0, import_common286.Module)({
    imports: [PrismaModule],
    providers: [WaiversService],
    exports: [WaiversService]
  })
], WaiversModule);

// src/health/health.module.ts
var import_common289 = require("@nestjs/common");

// src/health/health.controller.ts
var import_common287 = require("@nestjs/common");
var HealthController = class {
  constructor(health) {
    this.health = health;
  }
  getLiveness() {
    return this.health.liveness();
  }
  async getHealthz() {
    const result = await this.health.liveness();
    if (!result.ok) {
      throw new import_common287.HttpException(result, import_common287.HttpStatus.SERVICE_UNAVAILABLE);
    }
    return result;
  }
  async getReady() {
    const result = await this.health.readiness();
    if (!result.ok) {
      throw new import_common287.HttpException(result, import_common287.HttpStatus.SERVICE_UNAVAILABLE);
    }
    return result;
  }
  async getReadyz() {
    const result = await this.health.readiness();
    if (!result.ok) {
      throw new import_common287.HttpException(result, import_common287.HttpStatus.SERVICE_UNAVAILABLE);
    }
    return result;
  }
};
__decorateClass([
  (0, import_common287.Get)("health")
], HealthController.prototype, "getLiveness", 1);
__decorateClass([
  (0, import_common287.Get)("healthz")
], HealthController.prototype, "getHealthz", 1);
__decorateClass([
  (0, import_common287.Get)("ready")
], HealthController.prototype, "getReady", 1);
__decorateClass([
  (0, import_common287.Get)("readyz")
], HealthController.prototype, "getReadyz", 1);
HealthController = __decorateClass([
  (0, import_common287.Controller)()
], HealthController);

// src/health/health.service.ts
var import_common288 = require("@nestjs/common");
var HealthService = class {
  constructor(prisma, redis, observability) {
    this.prisma = prisma;
    this.redis = redis;
    this.observability = observability;
    this.logger = new import_common288.Logger(HealthService.name);
    this.readyChecksEnabled = (process.env.ENABLE_READY_PROBE ?? process.env.ready_checks_enabled ?? "true").toString().toLowerCase() === "true";
  }
  liveness() {
    return {
      ok: true,
      status: "up",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptimeMs: Math.round(process.uptime() * 1e3)
    };
  }
  async readiness() {
    if (!this.readyChecksEnabled) {
      return {
        ok: true,
        status: "skipped",
        skipped: true,
        message: "Ready checks disabled via config",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        uptimeMs: Math.round(process.uptime() * 1e3)
      };
    }
    const db = await this.safeCheck(async () => {
      const start = Date.now();
      await this.prisma.$queryRaw`SELECT 1`;
      return { ok: true, latencyMs: Date.now() - start };
    }, "db");
    const redis = await this.safeCheck(async () => {
      if (!this.redis.isEnabled) {
        return { ok: true, skipped: true, message: "redis not configured" };
      }
      const start = Date.now();
      await this.redis.ping();
      return { ok: true, latencyMs: Date.now() - start };
    }, "redis");
    const snapshot = this.observability.snapshot();
    const queues = Object.entries(snapshot.jobs.queues || {}).map(([name, state]) => ({
      name,
      running: state.running,
      queued: state.queued
    }));
    const ok = db.ok && redis.ok;
    this.observability.recordReady(ok, {
      db: db.ok,
      redis: redis.ok
    });
    return {
      ok,
      status: ok ? "ok" : "degraded",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptimeMs: Math.round(process.uptime() * 1e3),
      checks: { db, redis },
      queues,
      perf: {
        api: {
          count: snapshot.api.count,
          p95: snapshot.api.p95,
          errorRate: snapshot.api.count ? snapshot.api.errors / snapshot.api.count : 0
        },
        jobs: {
          count: snapshot.jobs.count,
          p95: snapshot.jobs.p95,
          failureRate: snapshot.jobs.count ? snapshot.jobs.errors / snapshot.jobs.count : 0
        },
        targets: snapshot.targets
      }
    };
  }
  // Backwards compatibility shim for previous callers
  async check() {
    return this.readiness();
  }
  async safeCheck(fn, component) {
    try {
      return await fn();
    } catch (err) {
      this.logger.warn(`Health check failed for ${component}: ${err?.message ?? err}`);
      return { ok: false, message: err?.message ?? "check failed" };
    }
  }
};
HealthService = __decorateClass([
  (0, import_common288.Injectable)()
], HealthService);

// src/health/health.module.ts
var HealthModule = class {
};
HealthModule = __decorateClass([
  (0, import_common289.Module)({
    imports: [PrismaModule, RedisModule, ObservabilityModule],
    controllers: [HealthController],
    providers: [HealthService],
    exports: [HealthService]
  })
], HealthModule);

// src/onboarding/onboarding.module.ts
var import_common292 = require("@nestjs/common");

// src/onboarding/onboarding.service.ts
var import_common290 = require("@nestjs/common");
var import_client52 = require("@prisma/client");
var import_class_transformer4 = require("class-transformer");
var import_class_validator10 = require("class-validator");
var import_crypto25 = __toESM(require("crypto"));

// src/onboarding/onboarding.constants.ts
var ONBOARDING_STEPS = [
  { key: "account_profile", title: "Account & profile", description: "Contact info, timezone, and branding basics." },
  { key: "payment_gateway", title: "Payments", description: "Choose your gateway and payout details." },
  { key: "taxes_and_fees", title: "Taxes & fees", description: "Set tax rates, service and platform fees." },
  { key: "inventory_sites", title: "Inventory & sites", description: "Add sites, classes, and capacity." },
  { key: "rates_and_fees", title: "Rates", description: "Base rates, deposits, and adjustments." },
  { key: "policies", title: "Policies", description: "Check-in/out, cancellations, quiet hours." },
  { key: "communications_templates", title: "Communications", description: "Default emails/SMS, sender identity." },
  { key: "pos_hardware", title: "POS hardware", description: "Card readers, kiosks, printers, networks." },
  { key: "imports", title: "Imports", description: "Legacy data, PMS exports, docs to import." }
];
var ONBOARDING_STEP_ORDER = ONBOARDING_STEPS.map((s) => s.key);
var ONBOARDING_TOTAL_STEPS = ONBOARDING_STEP_ORDER.length;

// src/onboarding/dto.ts
var import_class_transformer3 = require("class-transformer");
var import_class_validator9 = require("class-validator");
var CreateOnboardingInviteDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsEmail)()
], CreateOnboardingInviteDto.prototype, "email", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], CreateOnboardingInviteDto.prototype, "organizationId", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], CreateOnboardingInviteDto.prototype, "campgroundId", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], CreateOnboardingInviteDto.prototype, "campgroundName", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.Min)(1)
], CreateOnboardingInviteDto.prototype, "expiresInHours", 2);
var StartOnboardingDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsString)()
], StartOnboardingDto.prototype, "token", 2);
var UpdateOnboardingStepDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsString)()
], UpdateOnboardingStepDto.prototype, "step", 2);
__decorateClass([
  (0, import_class_validator9.IsObject)()
], UpdateOnboardingStepDto.prototype, "payload", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], UpdateOnboardingStepDto.prototype, "token", 2);
var AccountProfileDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsString)()
], AccountProfileDto.prototype, "campgroundName", 2);
__decorateClass([
  (0, import_class_validator9.IsString)()
], AccountProfileDto.prototype, "contactName", 2);
__decorateClass([
  (0, import_class_validator9.IsEmail)()
], AccountProfileDto.prototype, "contactEmail", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], AccountProfileDto.prototype, "phone", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], AccountProfileDto.prototype, "timezone", 2);
var PaymentGatewayDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsString)()
], PaymentGatewayDto.prototype, "provider", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PaymentGatewayDto.prototype, "accountId", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PaymentGatewayDto.prototype, "payoutSchedule", 2);
var TaxesAndFeesDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_validator9.Min)(0)
], TaxesAndFeesDto.prototype, "lodgingTaxRate", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_validator9.Min)(0)
], TaxesAndFeesDto.prototype, "localTaxRate", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], TaxesAndFeesDto.prototype, "feeNotes", 2);
var InventorySitesDto = class {
};
__decorateClass([
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_validator9.Min)(0)
], InventorySitesDto.prototype, "siteCount", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], InventorySitesDto.prototype, "primaryRigTypes", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsBoolean)()
], InventorySitesDto.prototype, "hasGroups", 2);
var RatesAndFeesDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_validator9.Min)(0)
], RatesAndFeesDto.prototype, "baseNightlyRate", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_transformer3.Type)(() => Number),
  (0, import_class_validator9.IsNumber)(),
  (0, import_class_validator9.Min)(0)
], RatesAndFeesDto.prototype, "depositPercent", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], RatesAndFeesDto.prototype, "addOnNotes", 2);
var PoliciesDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PoliciesDto.prototype, "checkInTime", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PoliciesDto.prototype, "checkOutTime", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PoliciesDto.prototype, "cancellationPolicy", 2);
var CommunicationsTemplatesDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsBoolean)()
], CommunicationsTemplatesDto.prototype, "enableSms", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], CommunicationsTemplatesDto.prototype, "senderName", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], CommunicationsTemplatesDto.prototype, "welcomeTemplate", 2);
var PosHardwareDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsBoolean)()
], PosHardwareDto.prototype, "hasTerminals", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsBoolean)()
], PosHardwareDto.prototype, "needsKiosk", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], PosHardwareDto.prototype, "primaryProvider", 2);
var ImportsDto = class {
};
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], ImportsDto.prototype, "sourceSystem", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsBoolean)()
], ImportsDto.prototype, "needsDataMigration", 2);
__decorateClass([
  (0, import_class_validator9.IsOptional)(),
  (0, import_class_validator9.IsString)()
], ImportsDto.prototype, "attachmentsHint", 2);

// src/onboarding/onboarding.service.ts
var STEP_VALIDATORS = {
  account_profile: AccountProfileDto,
  payment_gateway: PaymentGatewayDto,
  taxes_and_fees: TaxesAndFeesDto,
  inventory_sites: InventorySitesDto,
  rates_and_fees: RatesAndFeesDto,
  policies: PoliciesDto,
  communications_templates: CommunicationsTemplatesDto,
  pos_hardware: PoliciesDto,
  // reuse lightweight validator
  imports: ImportsDto
};
var OnboardingService = class {
  constructor(prisma, email, idempotency) {
    this.prisma = prisma;
    this.email = email;
    this.idempotency = idempotency;
    this.logger = new import_common290.Logger(OnboardingService.name);
  }
  async createInvite(dto, actor) {
    const token = import_crypto25.default.randomBytes(24).toString("hex");
    const expiresAt = new Date(Date.now() + (dto.expiresInHours ?? 72) * 60 * 60 * 1e3);
    const invite = await this.prisma.onboardingInvite.create({
      data: {
        email: dto.email,
        organizationId: dto.organizationId ?? null,
        campgroundId: dto.campgroundId ?? null,
        invitedById: actor?.id ?? null,
        token,
        expiresAt,
        lastSentAt: /* @__PURE__ */ new Date()
      }
    });
    await this.sendInviteEmail(invite.token, invite.email, dto.campgroundName ?? "your campground", expiresAt);
    return { inviteId: invite.id, token, expiresAt };
  }
  async resendInvite(inviteId, actor) {
    const existing = await this.prisma.onboardingInvite.findUnique({ where: { id: inviteId } });
    if (!existing) throw new import_common290.UnauthorizedException("Invite not found");
    const token = import_crypto25.default.randomBytes(24).toString("hex");
    const expiresAt = new Date(Date.now() + 72 * 60 * 60 * 1e3);
    const invite = await this.prisma.onboardingInvite.update({
      where: { id: inviteId },
      data: {
        token,
        expiresAt,
        lastSentAt: /* @__PURE__ */ new Date(),
        invitedById: actor?.id ?? existing.invitedById ?? null
      }
    });
    await this.sendInviteEmail(token, invite.email, "your campground", expiresAt);
    return { inviteId: invite.id, token, expiresAt };
  }
  async startSession(input) {
    const invite = await this.requireInvite(input.token);
    const session = invite.session ?? await this.prisma.onboardingSession.create({
      data: {
        inviteId: invite.id,
        organizationId: invite.organizationId ?? null,
        campgroundId: invite.campgroundId ?? null,
        status: import_client52.OnboardingStatus.in_progress,
        currentStep: OnboardingStep.account_profile,
        completedSteps: [],
        expiresAt: invite.expiresAt
      }
    });
    if (!invite.redeemedAt) {
      await this.prisma.onboardingInvite.update({
        where: { id: invite.id },
        data: { redeemedAt: /* @__PURE__ */ new Date() }
      }).catch(() => null);
    }
    const progress = this.buildProgress(session);
    return { session, progress };
  }
  async getSession(sessionId, token) {
    const session = await this.requireSession(sessionId, token);
    const progress = this.buildProgress(session);
    return { session, progress };
  }
  async saveStep(sessionId, token, step, payload, idempotencyKey, sequence) {
    const session = await this.requireSession(sessionId, token);
    const scope = { campgroundId: session.campgroundId ?? null, tenantId: session.organizationId ?? null };
    const existing = await this.guardIdempotency(idempotencyKey, { step, payload }, scope, `onboarding/${step}`, sequence);
    if (existing?.status === import_client52.IdempotencyStatus.succeeded && existing.responseJson) {
      return existing.responseJson;
    }
    if (existing?.status === import_client52.IdempotencyStatus.inflight && existing.createdAt && Date.now() - new Date(existing.createdAt).getTime() < 6e4) {
      throw new import_common290.ConflictException("Onboarding step already in progress");
    }
    const sanitized = this.validatePayload(step, payload);
    const completed = new Set(session.completedSteps ?? []);
    completed.add(step);
    const progress = this.buildProgress({
      ...session,
      currentStep: step,
      completedSteps: Array.from(completed),
      data: { ...session.data ?? {}, [step]: sanitized }
    });
    const nextStatus = progress.remainingSteps.length === 0 ? import_client52.OnboardingStatus.completed : import_client52.OnboardingStatus.in_progress;
    const updated = await this.prisma.onboardingSession.update({
      where: { id: sessionId },
      data: {
        currentStep: progress.nextStep ?? step,
        completedSteps: Array.from(completed),
        status: nextStatus,
        data: { ...session.data ?? {}, [step]: sanitized },
        progress
      }
    });
    const response = { session: updated, progress };
    if (idempotencyKey) await this.idempotency.complete(idempotencyKey, response);
    return response;
  }
  buildProgress(session) {
    const completed = new Set(session.completedSteps ?? []);
    const nextStep = ONBOARDING_STEP_ORDER.find((s) => !completed.has(s)) ?? null;
    const percentage = Math.round(completed.size / ONBOARDING_TOTAL_STEPS * 100);
    return {
      currentStep: session.currentStep ?? OnboardingStep.account_profile,
      nextStep,
      completedSteps: Array.from(completed),
      remainingSteps: ONBOARDING_STEP_ORDER.filter((s) => !completed.has(s)),
      percentage
    };
  }
  validatePayload(step, payload) {
    const dtoClass = STEP_VALIDATORS[step];
    if (!dtoClass) return payload;
    const instance = (0, import_class_transformer4.plainToInstance)(dtoClass, payload ?? {}, { enableImplicitConversion: true });
    const errors = (0, import_class_validator10.validateSync)(instance, { whitelist: true, forbidUnknownValues: true });
    if (errors.length > 0) {
      const detail = errors.flatMap((err) => Object.values(err.constraints ?? {})).filter(Boolean).join(", ");
      throw new import_common290.BadRequestException(`Invalid payload for ${step}: ${detail || "validation failed"}`);
    }
    return (0, import_class_transformer4.instanceToPlain)(instance);
  }
  async requireInvite(token) {
    const invite = await this.prisma.onboardingInvite.findUnique({
      where: { token },
      include: { session: true }
    });
    if (!invite || invite.expiresAt < /* @__PURE__ */ new Date()) {
      throw new import_common290.UnauthorizedException("Onboarding invite is invalid or expired");
    }
    return invite;
  }
  async requireSession(sessionId, token) {
    const invite = await this.requireInvite(token);
    const session = await this.prisma.onboardingSession.findUnique({ where: { id: sessionId } }) ?? invite.session;
    if (!session || session.inviteId !== invite.id) {
      throw new import_common290.UnauthorizedException("Onboarding session not found for token");
    }
    if (session.expiresAt && session.expiresAt < /* @__PURE__ */ new Date()) {
      throw new import_common290.UnauthorizedException("Onboarding session expired");
    }
    return session;
  }
  async sendInviteEmail(token, email, campgroundName, expiresAt) {
    const baseUrl = process.env.FRONTEND_BASE_URL || process.env.NEXT_PUBLIC_APP_URL || "https://app.campreserv.com";
    const url = `${baseUrl}/onboarding/${token}`;
    const html = `
      <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 640px; margin: 0 auto; padding: 24px; background: #f8fafc;">
        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 24px;">
          <p style="color: #0f172a; font-weight: 600; font-size: 18px; margin: 0 0 12px 0;">Complete onboarding for ${campgroundName}</p>
          <p style="color: #475569; margin: 0 0 16px 0;">We saved your progress so you can finish anytime in the next few days.</p>
          <a href="${url}" style="display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 12px 18px; border-radius: 10px; font-weight: 700;">Start onboarding</a>
          <p style="color: #64748b; margin: 16px 0 0 0; font-size: 12px;">This link expires on ${inviteExpiryString(expiresAt)}. If it stops working, request a new invite from your Campreserv contact.</p>
        </div>
      </div>
    `;
    await this.email.sendEmail({
      to: email,
      subject: "Finish setting up your campground",
      html
    });
  }
  async guardIdempotency(key, body, scope, endpoint, sequence) {
    if (!key) return null;
    return this.idempotency.start(key, body ?? {}, scope.campgroundId ?? null, {
      tenantId: scope.tenantId ?? null,
      endpoint,
      sequence,
      rateAction: "apply"
    });
  }
};
OnboardingService = __decorateClass([
  (0, import_common290.Injectable)()
], OnboardingService);
function inviteExpiryString(date) {
  try {
    return date.toLocaleString("en-US", { month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" });
  } catch {
    return date.toISOString();
  }
}

// src/onboarding/onboarding.controller.ts
var import_common291 = require("@nestjs/common");
var OnboardingController = class {
  constructor(onboarding) {
    this.onboarding = onboarding;
  }
  createInvite(dto, req) {
    return this.onboarding.createInvite(dto, req.user);
  }
  resendInvite(id, req) {
    return this.onboarding.resendInvite(id, req.user);
  }
  startSession(dto) {
    return this.onboarding.startSession(dto);
  }
  getSession(id, token) {
    if (!token) throw new import_common291.BadRequestException("Missing onboarding token");
    return this.onboarding.getSession(id, token);
  }
  saveStep(id, dto, tokenHeader, idempotencyKey, clientSeq, altSeq) {
    const token = dto.token ?? tokenHeader;
    if (!token) throw new import_common291.BadRequestException("Missing onboarding token");
    const sequence = clientSeq ?? altSeq ?? void 0;
    return this.onboarding.saveStep(id, token, dto.step, dto.payload, idempotencyKey, sequence);
  }
};
__decorateClass([
  (0, import_common291.UseGuards)(JwtAuthGuard),
  (0, import_common291.Post)("invitations"),
  __decorateParam(0, (0, import_common291.Body)()),
  __decorateParam(1, (0, import_common291.Req)())
], OnboardingController.prototype, "createInvite", 1);
__decorateClass([
  (0, import_common291.UseGuards)(JwtAuthGuard),
  (0, import_common291.Post)("invitations/:id/resend"),
  __decorateParam(0, (0, import_common291.Param)("id")),
  __decorateParam(1, (0, import_common291.Req)())
], OnboardingController.prototype, "resendInvite", 1);
__decorateClass([
  (0, import_common291.Post)("session/start"),
  __decorateParam(0, (0, import_common291.Body)())
], OnboardingController.prototype, "startSession", 1);
__decorateClass([
  (0, import_common291.Get)("session/:id"),
  __decorateParam(0, (0, import_common291.Param)("id")),
  __decorateParam(1, (0, import_common291.Query)("token"))
], OnboardingController.prototype, "getSession", 1);
__decorateClass([
  (0, import_common291.Patch)("session/:id/step"),
  __decorateParam(0, (0, import_common291.Param)("id")),
  __decorateParam(1, (0, import_common291.Body)()),
  __decorateParam(2, (0, import_common291.Headers)("x-onboarding-token")),
  __decorateParam(3, (0, import_common291.Headers)("idempotency-key")),
  __decorateParam(4, (0, import_common291.Headers)("x-client-seq")),
  __decorateParam(5, (0, import_common291.Headers)("client-seq"))
], OnboardingController.prototype, "saveStep", 1);
OnboardingController = __decorateClass([
  (0, import_common291.Controller)("onboarding")
], OnboardingController);

// src/onboarding/onboarding.module.ts
var OnboardingModule = class {
};
OnboardingModule = __decorateClass([
  (0, import_common292.Module)({
    imports: [PrismaModule, EmailModule],
    controllers: [OnboardingController],
    providers: [OnboardingService, IdempotencyService],
    exports: [OnboardingService]
  })
], OnboardingModule);

// src/billing/billing.module.ts
var import_common296 = require("@nestjs/common");

// src/billing/billing.controller.ts
var import_common293 = require("@nestjs/common");
var import_client53 = require("@prisma/client");
var BillingController = class {
  constructor(billing) {
    this.billing = billing;
  }
  createMeter(campgroundId, body) {
    return this.billing.createMeter(campgroundId, body.siteId, body.type, body.serialNumber, body.ratePlanId, {
      billingMode: body.billingMode,
      billTo: body.billTo,
      multiplier: body.multiplier,
      autoEmail: body.autoEmail
    });
  }
  listRatePlans(campgroundId) {
    return this.billing.listRatePlans(campgroundId);
  }
  listMeters(campgroundId) {
    return this.billing.listMeters(campgroundId);
  }
  addRead(meterId, body) {
    return this.billing.addMeterRead(meterId, Number(body.readingValue), new Date(body.readAt), body.readBy, body.note, body.source);
  }
  importReads(body) {
    const reads = body.reads.map((r) => ({
      ...r,
      readAt: new Date(r.readAt),
      readingValue: Number(r.readingValue)
    }));
    return this.billing.importMeterReads(body.campgroundId, reads);
  }
  listReads(meterId, start, end) {
    return this.billing.listReads(meterId, start ? new Date(start) : void 0, end ? new Date(end) : void 0);
  }
  updateMeter(meterId, body) {
    return this.billing.updateMeter(meterId, body);
  }
  billMeter(meterId) {
    return this.billing.billMeterNow(meterId);
  }
  seedMeters(siteClassId) {
    return this.billing.seedMetersForSiteClass(siteClassId);
  }
  createCycle(reservationId, body) {
    return this.billing.createBillingCycle(reservationId, body.cadence, new Date(body.periodStart), new Date(body.periodEnd));
  }
  generateInvoice(cycleId) {
    return this.billing.generateInvoiceForCycle(cycleId);
  }
  listInvoices(reservationId) {
    return this.billing.listInvoicesByReservation(reservationId);
  }
  getInvoice(invoiceId) {
    return this.billing.getInvoice(invoiceId);
  }
  writeOff(invoiceId, body) {
    return this.billing.writeOffInvoice(invoiceId, body.reason, body.actorId);
  }
  overrideLine(invoiceId, lineId, body) {
    return this.billing.overrideInvoiceLine(invoiceId, lineId, Number(body.amountCents), body.note, body.actorId);
  }
  runLateFees() {
    return this.billing.applyLateFeesForOverdue();
  }
};
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("campgrounds/:campgroundId/meters"),
  __decorateParam(0, (0, import_common293.Param)("campgroundId")),
  __decorateParam(1, (0, import_common293.Body)())
], BillingController.prototype, "createMeter", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Get)("campgrounds/:campgroundId/utility-rate-plans"),
  __decorateParam(0, (0, import_common293.Param)("campgroundId"))
], BillingController.prototype, "listRatePlans", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Get)("campgrounds/:campgroundId/meters"),
  __decorateParam(0, (0, import_common293.Param)("campgroundId"))
], BillingController.prototype, "listMeters", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("meters/:meterId/reads"),
  __decorateParam(0, (0, import_common293.Param)("meterId")),
  __decorateParam(1, (0, import_common293.Body)())
], BillingController.prototype, "addRead", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("meters/import"),
  __decorateParam(0, (0, import_common293.Body)())
], BillingController.prototype, "importReads", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Get)("meters/:meterId/reads"),
  __decorateParam(0, (0, import_common293.Param)("meterId")),
  __decorateParam(1, (0, import_common293.Query)("start")),
  __decorateParam(2, (0, import_common293.Query)("end"))
], BillingController.prototype, "listReads", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Patch)("meters/:meterId"),
  __decorateParam(0, (0, import_common293.Param)("meterId")),
  __decorateParam(1, (0, import_common293.Body)())
], BillingController.prototype, "updateMeter", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("meters/:meterId/bill"),
  __decorateParam(0, (0, import_common293.Param)("meterId"))
], BillingController.prototype, "billMeter", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("site-classes/:siteClassId/meters/seed"),
  __decorateParam(0, (0, import_common293.Param)("siteClassId"))
], BillingController.prototype, "seedMeters", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("reservations/:reservationId/billing-cycles"),
  __decorateParam(0, (0, import_common293.Param)("reservationId")),
  __decorateParam(1, (0, import_common293.Body)())
], BillingController.prototype, "createCycle", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("billing/cycles/:cycleId/generate"),
  __decorateParam(0, (0, import_common293.Param)("cycleId"))
], BillingController.prototype, "generateInvoice", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Get)("reservations/:reservationId/invoices"),
  __decorateParam(0, (0, import_common293.Param)("reservationId"))
], BillingController.prototype, "listInvoices", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Get)("invoices/:invoiceId"),
  __decorateParam(0, (0, import_common293.Param)("invoiceId"))
], BillingController.prototype, "getInvoice", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("invoices/:invoiceId/writeoff"),
  __decorateParam(0, (0, import_common293.Param)("invoiceId")),
  __decorateParam(1, (0, import_common293.Body)())
], BillingController.prototype, "writeOff", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("invoices/:invoiceId/override-line/:lineId"),
  __decorateParam(0, (0, import_common293.Param)("invoiceId")),
  __decorateParam(1, (0, import_common293.Param)("lineId")),
  __decorateParam(2, (0, import_common293.Body)())
], BillingController.prototype, "overrideLine", 1);
__decorateClass([
  Roles(import_client53.UserRole.owner, import_client53.UserRole.manager, import_client53.UserRole.finance),
  (0, import_common293.Post)("billing/late-fees/run")
], BillingController.prototype, "runLateFees", 1);
BillingController = __decorateClass([
  (0, import_common293.UseGuards)(JwtAuthGuard, RolesGuard),
  (0, import_common293.Controller)()
], BillingController);

// src/billing/billing.service.ts
var import_common294 = require("@nestjs/common");
var BillingService = class {
  constructor(prisma) {
    this.prisma = prisma;
    this.logger = new import_common294.Logger(BillingService.name);
  }
  async createMeter(campgroundId, siteId, type, serialNumber, ratePlanId, config2) {
    return this.prisma.utilityMeter.create({
      data: {
        campgroundId,
        siteId,
        type,
        serialNumber,
        ratePlanId: ratePlanId || null,
        billingMode: config2?.billingMode || "cycle",
        billTo: config2?.billTo || "reservation",
        multiplier: config2?.multiplier ?? 1,
        autoEmail: config2?.autoEmail ?? false
      }
    });
  }
  async listMeters(campgroundId) {
    return this.prisma.utilityMeter.findMany({
      where: { campgroundId },
      include: { ratePlan: true }
    });
  }
  async listRatePlans(campgroundId) {
    return this.prisma.utilityRatePlan.findMany({
      where: { campgroundId },
      orderBy: { effectiveFrom: "desc" }
    });
  }
  async addMeterRead(meterId, readingValue, readAt, readBy, note, source = "manual") {
    return this.prisma.utilityMeterRead.create({
      data: {
        meterId,
        readingValue,
        readAt,
        readBy: readBy || null,
        note: note || null,
        source
      }
    });
  }
  async importMeterReads(campgroundId, reads) {
    const meterIds = Array.from(new Set(reads.map((r) => r.meterId)));
    const meters = await this.prisma.utilityMeter.findMany({ where: { id: { in: meterIds }, campgroundId } });
    const allowed = new Set(meters.map((m) => m.id));
    const validReads = reads.filter((r) => allowed.has(r.meterId));
    await this.prisma.$transaction(
      validReads.map(
        (r) => this.prisma.utilityMeterRead.create({
          data: {
            meterId: r.meterId,
            readingValue: r.readingValue,
            readAt: r.readAt,
            note: r.note || null,
            readBy: r.readBy || null,
            source: r.source || "import"
          }
        })
      )
    );
    return { imported: validReads.length, skipped: reads.length - validReads.length };
  }
  async listReads(meterId, start, end) {
    return this.prisma.utilityMeterRead.findMany({
      where: {
        meterId,
        ...start || end ? {
          readAt: {
            gte: start,
            lte: end
          }
        } : {}
      },
      orderBy: { readAt: "asc" }
    });
  }
  async updateMeter(meterId, data) {
    return this.prisma.utilityMeter.update({
      where: { id: meterId },
      data: {
        ratePlanId: data.ratePlanId ?? void 0,
        billingMode: data.billingMode ?? void 0,
        billTo: data.billTo ?? void 0,
        multiplier: data.multiplier ?? void 0,
        autoEmail: data.autoEmail ?? void 0,
        active: data.active ?? void 0,
        serialNumber: data.serialNumber ?? void 0
      }
    });
  }
  async billMeterNow(meterId) {
    const meter = await this.prisma.utilityMeter.findUnique({
      where: { id: meterId },
      include: {
        reads: { orderBy: { readAt: "asc" } },
        ratePlan: true
      }
    });
    if (!meter) throw new Error("Meter not found");
    if (!meter.active) throw new Error("Meter inactive");
    const reservation = await this.prisma.reservation.findFirst({
      where: {
        siteId: meter.siteId,
        status: { in: ["pending", "confirmed", "checked_in"] }
      },
      orderBy: { arrivalDate: "desc" }
    });
    if (!reservation) throw new Error("No active reservation on this site");
    const reads = meter.reads;
    if (!reads || reads.length < 2) throw new Error("Need at least two reads to bill");
    const lastBilledAt = meter.lastBilledReadAt ? new Date(meter.lastBilledReadAt) : null;
    const candidates = lastBilledAt ? reads.filter((r) => r.readAt > lastBilledAt) : reads.slice(-1);
    const endRead = candidates[candidates.length - 1];
    const prevReadCandidates = reads.filter((r) => r.readAt < endRead.readAt);
    const startRead = prevReadCandidates.length > 0 ? prevReadCandidates[prevReadCandidates.length - 1] : reads[0];
    const usage = Math.max(0, Number(endRead.readingValue) - Number(startRead.readingValue));
    const multiplier = Number(meter.multiplier ?? 1);
    const billedUsage = usage * (Number.isFinite(multiplier) ? multiplier : 1);
    const rate = meter.ratePlan?.baseRateCents ?? 0;
    const amountCents = Math.round(billedUsage * rate);
    if (amountCents <= 0) throw new Error("No billable usage");
    const cadence = meter.billingMode || "per_reading";
    const cycle = await this.prisma.billingCycle.create({
      data: {
        reservationId: reservation.id,
        campgroundId: meter.campgroundId,
        cadence,
        periodStart: startRead.readAt,
        periodEnd: endRead.readAt,
        status: "closed",
        generatedAt: /* @__PURE__ */ new Date(),
        closedAt: /* @__PURE__ */ new Date()
      }
    });
    const invoice = await this.prisma.invoice.create({
      data: {
        billingCycleId: cycle.id,
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        number: this.buildInvoiceNumber(reservation.campgroundId),
        dueDate: endRead.readAt,
        subtotalCents: amountCents,
        totalCents: amountCents,
        balanceCents: amountCents,
        lines: {
          create: [
            {
              type: "utility",
              description: `${meter.type} usage ${billedUsage.toFixed(2)} @ ${rate}c`,
              quantity: billedUsage,
              unitCents: rate,
              amountCents,
              meta: {
                meterId: meter.id,
                usage: billedUsage,
                utilityType: meter.type,
                ratePlanId: meter.ratePlanId ?? void 0,
                readStartAt: startRead.readAt,
                readEndAt: endRead.readAt
              }
            }
          ]
        }
      },
      include: { lines: true }
    });
    const line = invoice.lines[0];
    await this.createLedgerPair({
      campgroundId: reservation.campgroundId,
      reservationId: reservation.id,
      invoiceId: invoice.id,
      invoiceLineId: line.id,
      amountCents: line.amountCents,
      revenueGl: "UTILITY",
      description: line.description
    });
    await this.prisma.utilityMeter.update({
      where: { id: meter.id },
      data: { lastBilledReadAt: endRead.readAt }
    });
    return this.getInvoice(invoice.id);
  }
  async seedMetersForSiteClass(siteClassId) {
    const siteClass = await this.prisma.siteClass.findUnique({
      where: { id: siteClassId },
      include: { sites: true }
    });
    if (!siteClass) throw new Error("Site class not found");
    if (!siteClass.meteredEnabled || !siteClass.meteredType) {
      throw new Error("Site class is not marked as metered");
    }
    const type = siteClass.meteredType;
    const sites = siteClass.sites;
    if (!sites || sites.length === 0) return { created: 0 };
    const existing = await this.prisma.utilityMeter.findMany({
      where: { siteId: { in: sites.map((s) => s.id) }, type, active: true }
    });
    const existingBySite = new Set(existing.map((m) => m.siteId));
    let created = 0;
    for (const site of sites) {
      if (existingBySite.has(site.id)) continue;
      await this.prisma.utilityMeter.create({
        data: {
          campgroundId: site.campgroundId,
          siteId: site.id,
          type,
          ratePlanId: siteClass.meteredRatePlanId || null,
          billingMode: siteClass.meteredBillingMode || "cycle",
          billTo: siteClass.meteredBillTo || "reservation",
          multiplier: siteClass.meteredMultiplier ?? 1,
          autoEmail: siteClass.meteredAutoEmail ?? false
        }
      });
      created += 1;
    }
    return { created, totalSites: sites.length };
  }
  async createBillingCycle(reservationId, cadence, periodStart, periodEnd) {
    const reservation = await this.prisma.reservation.findUnique({ where: { id: reservationId } });
    if (!reservation) throw new Error("Reservation not found");
    return this.prisma.billingCycle.create({
      data: {
        reservationId,
        campgroundId: reservation.campgroundId,
        cadence,
        periodStart,
        periodEnd
      }
    });
  }
  async upsertCurrentCycle(reservationId, cadence) {
    const reservation = await this.prisma.reservation.findUnique({ where: { id: reservationId } });
    if (!reservation) throw new Error("Reservation not found");
    const now = /* @__PURE__ */ new Date();
    const anchor = reservation.billingAnchorDate || reservation.arrivalDate;
    const lengthDays = cadence === "weekly" ? 7 : 30;
    const periodsSinceStart = Math.max(0, Math.floor((now.getTime() - anchor.getTime()) / (lengthDays * 24 * 3600 * 1e3)));
    const periodStart = new Date(anchor.getTime() + periodsSinceStart * lengthDays * 24 * 3600 * 1e3);
    const periodEnd = new Date(periodStart.getTime() + lengthDays * 24 * 3600 * 1e3);
    const existing = await this.prisma.billingCycle.findFirst({
      where: {
        reservationId,
        periodStart,
        periodEnd
      }
    });
    if (existing) return existing;
    return this.createBillingCycle(reservationId, cadence, periodStart, periodEnd);
  }
  buildInvoiceNumber(campgroundId) {
    return `INV-${campgroundId.slice(0, 6)}-${Date.now()}`;
  }
  async calcUtilityCharges(reservation, cycle) {
    const meters = await this.prisma.utilityMeter.findMany({
      where: {
        campgroundId: reservation.campgroundId,
        siteId: reservation.siteId,
        active: true
      },
      include: {
        reads: {
          where: {
            readAt: {
              lte: cycle.periodEnd
            }
          },
          orderBy: { readAt: "asc" }
        },
        ratePlan: true
      }
    });
    const charges = [];
    for (const meter of meters) {
      if (meter.billingMode && meter.billingMode !== "cycle") continue;
      const reads = meter.reads;
      if (!reads || reads.length === 0) continue;
      const startRead = [...reads].filter((r) => r.readAt <= cycle.periodStart).pop() || reads[0];
      const endRead = [...reads].filter((r) => r.readAt <= cycle.periodEnd).pop() || reads[reads.length - 1];
      const usage = Math.max(0, Number(endRead.readingValue) - Number(startRead.readingValue));
      const multiplier = Number(meter.multiplier ?? 1);
      const billedUsage = usage * (Number.isFinite(multiplier) ? multiplier : 1);
      const plan = meter.ratePlan;
      const rate = plan?.baseRateCents ?? 0;
      const amountCents = Math.round(billedUsage * rate);
      charges.push({
        type: meter.type,
        meterId: meter.id,
        usage: billedUsage,
        ratePlanId: plan?.id ?? null,
        rateCents: rate,
        amountCents,
        description: `${meter.type} usage ${billedUsage.toFixed(2)} @ ${rate}c`,
        meta: { meterId: meter.id, usage: billedUsage, planId: plan?.id ?? null }
      });
    }
    return charges;
  }
  estimateRentPerCycle(reservation, cadence) {
    const start = reservation.arrivalDate instanceof Date ? reservation.arrivalDate : new Date(reservation.arrivalDate);
    const end = reservation.departureDate instanceof Date ? reservation.departureDate : new Date(reservation.departureDate);
    const stayDays = Math.max(1, Math.ceil((end.getTime() - start.getTime()) / (24 * 3600 * 1e3)));
    const divisor = cadence === "weekly" ? Math.max(1, Math.ceil(stayDays / 7)) : Math.max(1, Math.ceil(stayDays / 30));
    return Math.round((reservation.baseSubtotal ?? reservation.totalAmount ?? 0) / divisor);
  }
  async createLedgerPair(opts) {
    const occurredAt = opts.occurredAt ?? /* @__PURE__ */ new Date();
    const entries = await postBalancedLedgerEntries(
      this.prisma,
      [
        {
          campgroundId: opts.campgroundId,
          reservationId: opts.reservationId || null,
          glCode: "AR",
          account: "Accounts Receivable",
          description: opts.description,
          amountCents: opts.amountCents,
          direction: "debit",
          occurredAt,
          externalRef: opts.invoiceLineId ?? opts.invoiceId,
          dedupeKey: `inv:${opts.invoiceId}:${opts.invoiceLineId ?? "line"}:ar`
        },
        {
          campgroundId: opts.campgroundId,
          reservationId: opts.reservationId || null,
          glCode: opts.revenueGl,
          account: opts.revenueGl,
          description: `${opts.description} revenue`,
          amountCents: opts.amountCents,
          direction: "credit",
          occurredAt,
          externalRef: opts.invoiceLineId ?? opts.invoiceId,
          dedupeKey: `inv:${opts.invoiceId}:${opts.invoiceLineId ?? "line"}:rev`
        }
      ],
      { requireGlCode: true }
    );
    const debit = entries.find((e) => e.direction === "debit");
    if (debit) {
      await this.prisma.arLedgerEntry.create({
        data: {
          ledgerEntryId: debit.id,
          invoiceId: opts.invoiceId,
          invoiceLineId: opts.invoiceLineId || null,
          type: "ar_open"
        }
      });
    }
  }
  async generateInvoiceForCycle(cycleId) {
    const cycle = await this.prisma.billingCycle.findUnique({
      where: { id: cycleId },
      include: { reservation: true }
    });
    if (!cycle) throw new Error("Cycle not found");
    const existing = await this.prisma.invoice.findFirst({ where: { billingCycleId: cycleId } });
    if (existing) return existing;
    const reservation = cycle.reservation;
    const cadence = cycle.cadence || reservation.billingCadence || "monthly";
    const rentCents = this.estimateRentPerCycle(reservation, cadence);
    const utilityCharges = await this.calcUtilityCharges(reservation, cycle);
    const lines = [];
    if (rentCents > 0) {
      lines.push({
        type: "rent",
        description: `Rent ${cadence}`,
        quantity: 1,
        unitCents: rentCents,
        amountCents: rentCents,
        meta: {}
      });
    }
    for (const charge of utilityCharges) {
      if (charge.amountCents <= 0) continue;
      lines.push({
        type: "utility",
        description: charge.description,
        quantity: charge.usage,
        unitCents: charge.rateCents ?? charge.amountCents,
        amountCents: charge.amountCents,
        meta: {
          meterId: charge.meterId,
          usage: charge.usage,
          utilityType: charge.type,
          ratePlanId: charge.ratePlanId ?? void 0
        }
      });
    }
    const subtotal = lines.reduce((acc, l) => acc + l.amountCents, 0);
    const total = subtotal;
    const invoice = await this.prisma.invoice.create({
      data: {
        billingCycleId: cycleId,
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        number: this.buildInvoiceNumber(reservation.campgroundId),
        dueDate: cycle.periodEnd,
        subtotalCents: subtotal,
        totalCents: total,
        balanceCents: total,
        lines: {
          create: lines
        }
      },
      include: { lines: true }
    });
    for (const line of invoice.lines) {
      const gl = line.type === "rent" ? "RENT" : line.type === "late_fee" ? "LATE_FEE" : "UTILITY";
      await this.createLedgerPair({
        campgroundId: reservation.campgroundId,
        reservationId: reservation.id,
        invoiceId: invoice.id,
        invoiceLineId: line.id,
        amountCents: line.amountCents,
        revenueGl: gl,
        description: line.description
      });
    }
    await this.prisma.billingCycle.update({
      where: { id: cycleId },
      data: { generatedAt: /* @__PURE__ */ new Date(), status: "closed" }
    });
    return invoice;
  }
  async recalcInvoiceTotals(invoiceId) {
    const invoice = await this.prisma.invoice.findUnique({ where: { id: invoiceId }, include: { lines: true } });
    if (!invoice) return;
    const subtotal = invoice.lines.reduce((acc, l) => acc + l.amountCents, 0);
    const total = subtotal;
    const paid = invoice.totalCents - invoice.balanceCents;
    const balance = Math.max(0, total - paid);
    await this.prisma.invoice.update({
      where: { id: invoiceId },
      data: {
        subtotalCents: subtotal,
        totalCents: total,
        balanceCents: balance
      }
    });
  }
  async applyLateFeesForOverdue() {
    const now = /* @__PURE__ */ new Date();
    const invoices = await this.prisma.invoice.findMany({
      where: {
        status: "open",
        dueDate: { lt: now },
        balanceCents: { gt: 0 }
      },
      include: {
        billingCycle: true,
        lines: true,
        reservation: true
      }
    });
    for (const invoice of invoices) {
      const hasLateFee = invoice.lines.some((l) => l.type === "late_fee");
      if (hasLateFee) continue;
      const rule = await this.prisma.lateFeeRule.findFirst({
        where: {
          campgroundId: invoice.campgroundId,
          cadence: invoice.billingCycle?.cadence ?? "monthly",
          active: true
        },
        orderBy: { effectiveFrom: "desc" }
      });
      if (!rule) continue;
      const amount = rule.feeType === "percent" ? Math.round(invoice.balanceCents * (rule.feePercentBp ?? 0) / 1e4) : rule.feeCents ?? 0;
      if (amount <= 0) continue;
      const lateLine = await this.prisma.invoiceLine.create({
        data: {
          invoiceId: invoice.id,
          type: "late_fee",
          description: "Late fee",
          quantity: 1,
          unitCents: amount,
          amountCents: amount
        }
      });
      await this.createLedgerPair({
        campgroundId: invoice.campgroundId,
        reservationId: invoice.reservationId,
        invoiceId: invoice.id,
        invoiceLineId: lateLine.id,
        amountCents: amount,
        revenueGl: "LATE_FEE",
        description: "Late fee"
      });
      await this.recalcInvoiceTotals(invoice.id);
    }
  }
  async writeOffInvoice(invoiceId, reason, actorId) {
    const invoice = await this.prisma.invoice.findUnique({ where: { id: invoiceId } });
    if (!invoice) throw new Error("Invoice not found");
    if (invoice.status === "written_off") return invoice;
    const amount = invoice.balanceCents;
    const beforeSnapshot = { status: invoice.status, balanceCents: invoice.balanceCents };
    await this.prisma.invoiceLine.create({
      data: {
        invoiceId,
        type: "adjustment",
        description: `Write-off: ${reason}`,
        quantity: 1,
        unitCents: -amount,
        amountCents: -amount,
        meta: { reason }
      }
    });
    await this.prisma.ledgerEntry.create({
      data: {
        campgroundId: invoice.campgroundId,
        reservationId: invoice.reservationId,
        glCode: "BAD_DEBT",
        account: "Bad Debt",
        description: `Write-off ${invoice.number}`,
        amountCents: amount,
        direction: "debit"
      }
    });
    const credit = await this.prisma.ledgerEntry.create({
      data: {
        campgroundId: invoice.campgroundId,
        reservationId: invoice.reservationId,
        glCode: "AR",
        account: "Accounts Receivable",
        description: `Write-off ${invoice.number}`,
        amountCents: amount,
        direction: "credit"
      }
    });
    await this.prisma.arLedgerEntry.create({
      data: {
        ledgerEntryId: credit.id,
        invoiceId,
        type: "writeoff"
      }
    });
    await this.prisma.invoice.update({
      where: { id: invoiceId },
      data: { status: "written_off", balanceCents: 0, closedAt: /* @__PURE__ */ new Date() }
    });
    await this.recalcInvoiceTotals(invoiceId);
    await this.prisma.auditLog.create({
      data: {
        campgroundId: invoice.campgroundId,
        actorId: actorId || null,
        action: "invoice.writeoff",
        entity: "invoice",
        entityId: invoiceId,
        before: beforeSnapshot,
        after: { status: "written_off", reason }
      }
    });
    return this.prisma.invoice.findUnique({ where: { id: invoiceId }, include: { lines: true } });
  }
  async overrideInvoiceLine(invoiceId, lineId, amountCents, note, actorId) {
    const invoice = await this.prisma.invoice.findUnique({ where: { id: invoiceId } });
    if (!invoice) throw new Error("Invoice not found");
    const line = await this.prisma.invoiceLine.findUnique({ where: { id: lineId } });
    if (!line || line.invoiceId !== invoiceId) throw new Error("Line not found");
    const before = { ...line };
    await this.prisma.invoiceLine.update({
      where: { id: lineId },
      data: {
        amountCents,
        unitCents: amountCents,
        meta: {
          ...line.meta,
          overrideNote: note,
          overriddenBy: actorId || "system"
        }
      }
    });
    await this.recalcInvoiceTotals(invoiceId);
    await this.prisma.auditLog.create({
      data: {
        campgroundId: invoice.campgroundId,
        actorId: actorId || null,
        action: "invoice.override_line",
        entity: "invoice_line",
        entityId: lineId,
        before,
        after: { amountCents, note }
      }
    });
    return this.getInvoice(invoiceId);
  }
  async listInvoicesByReservation(reservationId) {
    return this.prisma.invoice.findMany({
      where: { reservationId },
      include: { lines: true, billingCycle: true }
    });
  }
  async getInvoice(id) {
    return this.prisma.invoice.findUnique({
      where: { id },
      include: { lines: true, billingCycle: true }
    });
  }
  async generateCyclesAndInvoices() {
    const reservations = await this.prisma.reservation.findMany({
      where: {
        billingCadence: { in: ["weekly", "monthly"] },
        status: { in: ["pending", "confirmed", "checked_in"] }
      }
    });
    for (const reservation of reservations) {
      const cadence = reservation.billingCadence || "monthly";
      const cycle = await this.upsertCurrentCycle(reservation.id, cadence);
      const now = /* @__PURE__ */ new Date();
      if (cycle.periodEnd <= now) {
        await this.generateInvoiceForCycle(cycle.id).catch((err) => {
          this.logger.warn(`Failed to generate invoice for cycle ${cycle.id}: ${err instanceof Error ? err.message : err}`);
        });
      }
    }
  }
};
BillingService = __decorateClass([
  (0, import_common294.Injectable)()
], BillingService);

// src/billing/billing.jobs.ts
var import_common295 = require("@nestjs/common");
var import_schedule16 = require("@nestjs/schedule");
var BillingJobs = class {
  constructor(billing) {
    this.billing = billing;
    this.logger = new import_common295.Logger(BillingJobs.name);
  }
  async generateInvoices() {
    this.logger.log("[BillingJobs] running daily invoice generation");
    await this.billing.generateCyclesAndInvoices();
  }
  async applyLateFees() {
    this.logger.log("[BillingJobs] applying late fees");
    await this.billing.applyLateFeesForOverdue();
  }
};
__decorateClass([
  (0, import_schedule16.Cron)(import_schedule16.CronExpression.EVERY_DAY_AT_1AM)
], BillingJobs.prototype, "generateInvoices", 1);
__decorateClass([
  (0, import_schedule16.Cron)(import_schedule16.CronExpression.EVERY_DAY_AT_2AM)
], BillingJobs.prototype, "applyLateFees", 1);
BillingJobs = __decorateClass([
  (0, import_common295.Injectable)()
], BillingJobs);

// src/billing/billing.module.ts
var BillingModule = class {
};
BillingModule = __decorateClass([
  (0, import_common296.Module)({
    imports: [],
    controllers: [BillingController],
    providers: [BillingService, BillingJobs, PrismaService],
    exports: [BillingService]
  })
], BillingModule);

// src/referrals/referrals.module.ts
var import_common299 = require("@nestjs/common");

// src/referrals/referrals.controller.ts
var import_common297 = require("@nestjs/common");
var ReferralsController = class {
  constructor(referrals) {
    this.referrals = referrals;
  }
  list(campgroundId) {
    return this.referrals.listPrograms(campgroundId);
  }
  create(campgroundId, dto) {
    return this.referrals.createProgram(campgroundId, dto);
  }
  update(campgroundId, id, dto) {
    return this.referrals.updateProgram(campgroundId, id, dto);
  }
};
__decorateClass([
  (0, import_common297.Get)(),
  __decorateParam(0, (0, import_common297.Param)("campgroundId"))
], ReferralsController.prototype, "list", 1);
__decorateClass([
  (0, import_common297.Post)(),
  __decorateParam(0, (0, import_common297.Param)("campgroundId")),
  __decorateParam(1, (0, import_common297.Body)())
], ReferralsController.prototype, "create", 1);
__decorateClass([
  (0, import_common297.Patch)(":id"),
  __decorateParam(0, (0, import_common297.Param)("campgroundId")),
  __decorateParam(1, (0, import_common297.Param)("id")),
  __decorateParam(2, (0, import_common297.Body)())
], ReferralsController.prototype, "update", 1);
ReferralsController = __decorateClass([
  (0, import_common297.UseGuards)(JwtAuthGuard),
  (0, import_common297.Controller)("campgrounds/:campgroundId/referral-programs")
], ReferralsController);

// src/referrals/referrals.service.ts
var import_common298 = require("@nestjs/common");
var ReferralsService = class {
  constructor(prisma) {
    this.prisma = prisma;
  }
  listPrograms(campgroundId) {
    return this.prisma.referralProgram.findMany({
      where: { campgroundId },
      orderBy: [{ isActive: "desc" }, { createdAt: "desc" }]
    });
  }
  async createProgram(campgroundId, dto) {
    const exists = await this.prisma.referralProgram.findFirst({
      where: {
        campgroundId,
        OR: [{ code: dto.code }, dto.linkSlug ? { linkSlug: dto.linkSlug } : void 0].filter(Boolean)
      }
    });
    if (exists) {
      throw new import_common298.BadRequestException("Referral code or link already exists");
    }
    return this.prisma.referralProgram.create({
      data: {
        campgroundId,
        code: dto.code,
        linkSlug: dto.linkSlug ?? null,
        source: dto.source ?? null,
        channel: dto.channel ?? null,
        incentiveType: dto.incentiveType,
        incentiveValue: dto.incentiveValue,
        isActive: dto.isActive ?? true,
        notes: dto.notes ?? null
      }
    });
  }
  async updateProgram(campgroundId, id, dto) {
    const existing = await this.prisma.referralProgram.findUnique({ where: { id } });
    if (!existing || existing.campgroundId !== campgroundId) {
      throw new import_common298.NotFoundException("Referral program not found");
    }
    if (dto.code || dto.linkSlug) {
      const conflict = await this.prisma.referralProgram.findFirst({
        where: {
          campgroundId,
          id: { not: id },
          OR: [
            dto.code ? { code: dto.code } : void 0,
            dto.linkSlug ? { linkSlug: dto.linkSlug } : void 0
          ].filter(Boolean)
        }
      });
      if (conflict) {
        throw new import_common298.BadRequestException("Referral code or link already in use");
      }
    }
    return this.prisma.referralProgram.update({
      where: { id },
      data: {
        code: dto.code ?? void 0,
        linkSlug: dto.linkSlug ?? void 0,
        source: dto.source ?? void 0,
        channel: dto.channel ?? void 0,
        incentiveType: dto.incentiveType ?? void 0,
        incentiveValue: dto.incentiveValue ?? void 0,
        isActive: dto.isActive ?? void 0,
        notes: dto.notes ?? void 0
      }
    });
  }
};
ReferralsService = __decorateClass([
  (0, import_common298.Injectable)()
], ReferralsService);

// src/referrals/referrals.module.ts
var ReferralsModule = class {
};
ReferralsModule = __decorateClass([
  (0, import_common299.Module)({
    imports: [PrismaModule],
    controllers: [ReferralsController],
    providers: [ReferralsService]
  })
], ReferralsModule);

// src/app.module.ts
var AppModule = class {
};
AppModule = __decorateClass([
  (0, import_common300.Module)({
    imports: [
      import_config2.ConfigModule.forRoot({ isGlobal: true }),
      import_schedule17.ScheduleModule.forRoot(),
      AuthModule,
      GuestAuthModule,
      RedisModule,
      OrganizationsModule,
      CampgroundsModule,
      SitesModule,
      GuestsModule,
      ReservationsModule,
      SiteClassesModule,
      SiteMapModule,
      DashboardModule,
      MaintenanceModule,
      PricingModule,
      PricingV2Module,
      MembershipsModule,
      LedgerModule,
      PaymentsModule,
      DepositPoliciesModule,
      UpsellsModule,
      GiftCardsModule,
      StoreModule,
      BlackoutsModule,
      PromotionsModule,
      PublicReservationsModule,
      MessagesModule,
      EventsModule,
      EmailModule,
      WaitlistModule,
      InternalMessagesModule,
      LoyaltyModule,
      TaxRulesModule,
      SeasonalRatesModule,
      GuestEquipmentModule,
      RepeatChargesModule,
      ActivitiesModule,
      IncidentsModule,
      OperationsModule,
      InternalConversationsModule,
      HoldsModule,
      AuditModule,
      CommunicationsModule,
      CampaignsModule,
      OtaModule,
      SupportModule,
      NpsModule,
      ReviewsModule,
      FormsModule,
      SocialPlannerModule,
      GamificationModule,
      AnalyticsModule,
      AiModule,
      PushSubscriptionsModule,
      PerfModule,
      IntegrationsModule,
      ObservabilityModule,
      HealthModule,
      DeveloperApiModule,
      PrivacyModule,
      PermissionsModule,
      PortfoliosModule,
      LocalizationModule,
      CurrencyTaxModule,
      ApprovalsModule,
      AbandonedCartModule,
      BackupModule,
      AutoCollectModule,
      TasksModule,
      SelfCheckinModule,
      GroupsModule,
      // Phase 4 modules
      NotificationTriggersModule,
      StoredValueModule,
      PosModule,
      AccessControlModule,
      BillingModule,
      // Phase 3 modules
      DynamicPricingModule,
      WorkflowsModule,
      StaffModule,
      PortfolioModule,
      UploadsModule,
      WaiversModule,
      SignaturesModule,
      OnboardingModule,
      ReferralsModule
    ],
    providers: [PrismaService]
  })
], AppModule);

// src/app.bootstrap.ts
var dotenv = __toESM(require("dotenv"));

// src/perf/perf.interceptor.ts
var import_common301 = require("@nestjs/common");
var import_rxjs = require("rxjs");
var PerfInterceptor = class {
  constructor(perfService, observability) {
    this.perfService = perfService;
    this.observability = observability;
  }
  intercept(context, next) {
    const http = context.switchToHttp();
    const req = http.getRequest();
    const res = http.getResponse();
    const anyReq = req;
    const start = Date.now();
    const route = `${req.method} ${anyReq.route?.path ?? anyReq.path ?? req.url ?? ""}`.trim() || "unknown";
    const headers = anyReq.headers ?? {};
    const orgHeader = anyReq.organizationId ?? headers["x-organization-id"] ?? headers.get?.("x-organization-id");
    const orgId = Array.isArray(orgHeader) ? orgHeader[0] : orgHeader ?? null;
    const ip = headers["x-forwarded-for"]?.split(",")[0]?.trim() || anyReq.ip || anyReq.connection?.remoteAddress || null;
    const record = (statusCode) => {
      const durationMs = Date.now() - start;
      this.perfService.recordSample({
        durationMs,
        statusCode,
        route,
        orgId,
        ip
      });
      this.observability?.recordApiRequest({
        method: req.method,
        path: route,
        status: statusCode,
        durationMs
      });
    };
    return next.handle().pipe(
      (0, import_rxjs.tap)(() => record(res.statusCode ?? 200)),
      (0, import_rxjs.catchError)((err) => {
        const status = typeof err?.getStatus === "function" ? err.getStatus() : 500;
        record(status);
        throw err;
      })
    );
  }
};
PerfInterceptor = __decorateClass([
  (0, import_common301.Injectable)()
], PerfInterceptor);

// src/perf/rate-limit.interceptor.ts
var import_common302 = require("@nestjs/common");
var RateLimitInterceptor = class {
  constructor(rateLimitService, perfService) {
    this.rateLimitService = rateLimitService;
    this.perfService = perfService;
  }
  intercept(context, next) {
    const http = context.switchToHttp();
    const req = http.getRequest();
    const ip = req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.ip || req.connection?.remoteAddress || null;
    const orgHeader = req.organizationId ?? req.headers["x-organization-id"];
    const orgId = Array.isArray(orgHeader) ? orgHeader[0] : orgHeader ?? null;
    const result = this.rateLimitService.shouldAllow(ip, orgId);
    if (!result.allowed) {
      this.perfService.recordLimiterHit(result.reason);
      throw new import_common302.HttpException("Too Many Requests", import_common302.HttpStatus.TOO_MANY_REQUESTS);
    }
    return next.handle();
  }
};
RateLimitInterceptor = __decorateClass([
  (0, import_common302.Injectable)()
], RateLimitInterceptor);

// src/logger/redacting.logger.ts
var import_common303 = require("@nestjs/common");
var redactEmail = (value) => value.replace(/\b[\w.-]+@[\w.-]+\.\w+\b/g, "[redacted_email]");
var redactPhone = (value) => value.replace(/\+?\d[\d\s().-]{7,}\b/g, "[redacted_phone]");
var redactCardLast4 = (value) => value.replace(/last4["']?\s*:\s*["']?\d{4}["']?/gi, 'last4:"[redacted_last4]"');
var redact = (value, keyHint) => {
  if (typeof value === "string") {
    if (keyHint === "last4") return "[redacted_last4]";
    return redactCardLast4(redactPhone(redactEmail(value)));
  }
  if (Array.isArray(value)) return value.map((v) => redact(v));
  if (value && typeof value === "object") {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, redact(v, k)]));
  }
  return value;
};
var RedactingLogger = class {
  log(message, ...optionalParams) {
    console.log(redact(message), ...optionalParams.map((value) => redact(value)));
  }
  error(message, ...optionalParams) {
    console.error(redact(message), ...optionalParams.map((value) => redact(value)));
  }
  warn(message, ...optionalParams) {
    console.warn(redact(message), ...optionalParams.map((value) => redact(value)));
  }
  debug(message, ...optionalParams) {
    console.debug(redact(message), ...optionalParams.map((value) => redact(value)));
  }
  verbose(message, ...optionalParams) {
    console.debug(redact(message), ...optionalParams.map((value) => redact(value)));
  }
};
RedactingLogger = __decorateClass([
  (0, import_common303.Injectable)()
], RedactingLogger);

// src/app.bootstrap.ts
async function createApp() {
  dotenv.config();
  const app = await import_core2.NestFactory.create(AppModule, {
    logger: new RedactingLogger(),
    bodyParser: false
  });
  app.enableCors({
    origin: true,
    credentials: true,
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS",
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "X-Campground-Id",
      "X-Organization-Id",
      "X-Portfolio-Id",
      "X-Park-Id",
      "X-Locale",
      "X-Currency",
      "X-Client",
      "Accept",
      "X-Requested-With"
    ],
    optionsSuccessStatus: 204,
    preflightContinue: false
  });
  app.use((req, res, next) => {
    const origin = req.headers.origin || "*";
    res.header("Access-Control-Allow-Origin", origin);
    res.header("Vary", "Origin");
    res.header(
      "Access-Control-Allow-Headers",
      req.headers["access-control-request-headers"] || "Content-Type, Authorization, X-Campground-Id, X-Organization-Id, X-Portfolio-Id, X-Park-Id, X-Locale, X-Currency, X-Client, Accept, X-Requested-With"
    );
    res.header(
      "Access-Control-Allow-Methods",
      req.headers["access-control-request-method"] || "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS"
    );
    res.header("Access-Control-Allow-Credentials", "true");
    if (req.method === "OPTIONS") {
      return res.status(204).send();
    }
    next();
  });
  app.setGlobalPrefix("api");
  app.useGlobalPipes(new import_common304.ValidationPipe({ whitelist: true, transform: true }));
  app.use((req, _res, next) => {
    const headers = req.headers;
    const cgHeader = headers["x-campground-id"];
    const orgHeader = headers["x-organization-id"];
    req.campgroundId = Array.isArray(cgHeader) ? cgHeader[0] : cgHeader || null;
    req.organizationId = Array.isArray(orgHeader) ? orgHeader[0] : orgHeader || null;
    next();
  });
  const bodyParser = await import("body-parser");
  app.use(
    bodyParser.json({
      verify: (req, _res, buf) => {
        req.rawBody = buf;
      }
    })
  );
  app.use(
    bodyParser.urlencoded({
      extended: true,
      verify: (req, _res, buf) => {
        req.rawBody = buf;
      }
    })
  );
  const perfService = app.get(PerfService);
  const rateLimitService = app.get(RateLimitService);
  const observabilityService = app.get(ObservabilityService);
  app.useGlobalInterceptors(
    new RateLimitInterceptor(rateLimitService, perfService),
    new PerfInterceptor(perfService, observabilityService)
  );
  return app;
}

// src/serverless.ts
var cachedServer;
async function bootstrap() {
  const app = await createApp();
  await app.init();
  const expressApp = app.getHttpAdapter().getInstance();
  return (0, import_serverless_express.default)({ app: expressApp });
}
var handler = async (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;
  if (!cachedServer) {
    cachedServer = await bootstrap();
  }
  return cachedServer(event, context, callback);
};
var serverless_default = handler;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
